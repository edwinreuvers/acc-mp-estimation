[
  {
    "objectID": "data/readme.html",
    "href": "data/readme.html",
    "title": "Data",
    "section": "",
    "text": "All data of this study can be found on the Github repository. Data consists of:",
    "crumbs": [
      "{{< iconify fa6-regular floppy-disk >}} Data",
      "Data"
    ]
  },
  {
    "objectID": "data/readme.html#top-level-hierarchy",
    "href": "data/readme.html#top-level-hierarchy",
    "title": "Data",
    "section": "Top-level hierarchy",
    "text": "Top-level hierarchy\n\nLevel 1 â€“ Rat\n\nGMsX/ â†’ Simulated data\n\nâ€˜Experimentalâ€™ data here are simulated datasets created with a Hill-type MTC model using parameters from literature.\n\nEach folder represents a parameter set (X = 1, 2, 3, ...).\n\nGMeX/ â†’ In situ rats\n\nExperimental data here come from actual in situ experiments on rat gastrocnemius medialis muscle.\n\nEach folder corresponds to an individual rat (X = 1, 2, 3, ...).\n\n\n\n\nLevel 2 â€“ Kind of Data\nWithin each rat folder, data are grouped by type:\n\ndataExp/\nFolder containing experimental data.\n\nFor GMsX/, this is simulated data.\n\nFor GMeX/, this is actual experimental data.\n\ndataMC/ (simulated data only)\nFolder containing Monte Carloâ€“perturbed datasets.\n\nContains 01, 02, â€¦, 50, representing 50 independent perturbed datasets.\n\nparameters/\nModel parameters for the rat or parameter set.\nsimsExp/\nSimulations result performed using data of dataExp as input.\nsimsMC/ (simulated data only)\nSimulations results performed using data of dataMC as input.\n\nStructure mirrors expMC/.\n\n\n\n\nLevel 3 â€“ Experiment\nWithin dataExp/, dataMC/, simsExp/, and simsMC/, data are organized by experiment type:\n\nQR/ â€“ Quick-release\n\nSR/ â€“ Step-ramp\n\nISOM/ â€“ Isometric\n\nSSC/ â€“ Stretchâ€“shortening cycles (in situ only), where files with SSC_PA have a 4 mm MTC length excursions and files with SSC_PB have an 8 mm MTC length excursion\n\n\n\nLevel 4 - Dataset\nNote, the pertubed data for the Monte Carlo simulations introduce and extra level.\n\n01/ â€“ Set number 01\n02/ â€“ Set number 02\n03/ â€“ Set number 03\nâ€¦\n50/ â€“ Set number 50",
    "crumbs": [
      "{{< iconify fa6-regular floppy-disk >}} Data",
      "Data"
    ]
  },
  {
    "objectID": "data/readme.html#folder-structure",
    "href": "data/readme.html#folder-structure",
    "title": "Data",
    "section": "Folder Structure",
    "text": "Folder Structure\ndata/\nâ”œâ”€ GMs1/                      # 'rat 1' (i.e., parameter set 1)\nâ”‚   â”œâ”€ dataExp/               # 'Experimental data' (here: data generated by simulations)\nâ”‚   â”‚   â”œâ”€ QR/                # Quick-release data\nâ”‚   â”‚   â”œâ”€ SR/                # Step-ramp data\nâ”‚   â”‚   â””â”€ ISOM/              # Isometric data\nâ”‚   â”‚\nâ”‚   â”œâ”€ dataMC/                 # Monte Carlo perturbed experimental datasets\nâ”‚   â”‚   â”œâ”€ QR/                # Quick-release data\nâ”‚   â”‚   â”‚   â”œâ”€ 01/            # Dataset 01\nâ”‚   â”‚   â”‚   â”œâ”€ 02/\nâ”‚   â”‚   â”‚   â”œâ”€ 03/\nâ”‚   â”‚   â”‚   â”œâ”€ ../\nâ”‚   â”‚   â”‚   â””â”€ 50/\nâ”‚   â”‚   â”œâ”€ SR/\nâ”‚   â”‚   â”‚   â”œâ”€ 01/            \nâ”‚   â”‚   â”‚   â”œâ”€ 02/\nâ”‚   â”‚   â”‚   â”œâ”€ 03/\nâ”‚   â”‚   â”‚   â”œâ”€ ../\nâ”‚   â”‚   â”‚   â””â”€ 50/\nâ”‚   â”‚   â””â”€  SR/\nâ”‚   â”‚       â”œâ”€ 01/            \nâ”‚   â”‚       â”œâ”€ 02/\nâ”‚   â”‚       â”œâ”€ 03/\nâ”‚   â”‚       â”œâ”€ ../\nâ”‚   â”‚       â””â”€ 50/\nâ”‚   â”‚\nâ”‚   â”œâ”€ parameters/            # Folder containing pickles with parameter values\nâ”‚   â”‚   â”œâ”€ GMs1_OR.pkl        # 'Actual' parameter values\nâ”‚   â”‚   â”œâ”€ GMs1_TM.pkl        # Estimated parameters (w/ Traditional Method)\nâ”‚   â”‚   â”œâ”€ GMs1_IM.pkl        # Estimated parameters (w/ Improved Method)\nâ”‚   â”‚   â”œâ”€ GMs1_TM_QR.pkl     # Estimated parameters (Traditional Method, Quick-release data to estimate excitation dynamics)\nâ”‚   â”‚   â”œâ”€ GMs1_TM_SR.pkl     # Estimated parameters (Traditional Method, Step-ramp data to estimate excitation dynamics)\nâ”‚   â”‚   â”‚\nâ”‚   â”‚   â”œâ”€ interdep/          # Folder containing files of the interdependency analysis\nâ”‚   â”‚   â”‚   â”œâ”€ GMs1_a_095.pkl # Estimated parameters (a = 95% of baseline)\nâ”‚   â”‚   â”‚   â”œâ”€ GMs1_a_105.pkl # Estimated parameters (a = 105% of baseline)\nâ”‚   â”‚   â”‚   â””â”€ ... etc\nâ”‚   â”‚   â”‚\nâ”‚   â”‚   â””â”€ mc/                # Folder containing files of the Monte Carlo simulations\nâ”‚   â”‚       â”œâ”€ GMs1_MC01.pkl  # Estimated parameters of Monte Carlo simulation no. 1\nâ”‚   â”‚       â”œâ”€ GMs1_MC02.pkl  # Estimated parameters of Monte Carlo simulation no. 2\nâ”‚   â”‚       â””â”€ ... etc\nâ”‚   â”‚ \nâ”‚   â”œâ”€ simsExp/               # Simulations based on experimental data (i.e., lmtc(t) and stim(t) as inputs)\nâ”‚   â”‚   â”œâ”€ QR/\nâ”‚   â”‚   â”œâ”€ SR/\nâ”‚   â”‚   â””â”€ ISOM/\nâ”‚   â”‚\nâ”‚   â””â”€ simsMC/                # Simulations based on monte carlo datasets\nâ”‚       â”œâ”€ QR/\nâ”‚       â”‚   â”œâ”€ 01/\nâ”‚       â”‚   â”œâ”€ 02/\nâ”‚       â”‚   â”œâ”€ ../\nâ”‚       â”‚   â””â”€ 50/\nâ”‚       â”œâ”€ SR/\nâ”‚       â”‚   â”œâ”€ 01/\nâ”‚       â”‚   â”œâ”€ 02/\nâ”‚       â”‚   â”œâ”€ ../\nâ”‚       â”‚   â””â”€ 50/\nâ”‚       â””â”€ ISOM/\nâ”‚           â”œâ”€ 01/\nâ”‚           â”œâ”€ 02/\nâ”‚           â”œâ”€ ../\nâ”‚           â””â”€ 50/\nâ”‚\nâ”œâ”€ GMs2/\nâ”‚   â”œâ”€ dataExp/\nâ”‚   â”œâ”€ dataMC/\nâ”‚   â”œâ”€ parameters/\nâ”‚   â”œâ”€ simsData/\nâ”‚   â””â”€ simsExpMC/\nâ”‚\nâ”œâ”€ GMs3/\nâ”‚   â”œâ”€ dataExp/\nâ”‚   â”œâ”€ dataMC/\nâ”‚   â”œâ”€ parameters/\nâ”‚   â”œâ”€ simsData/\nâ”‚   â””â”€ simsExpMC/\nâ”‚\nâ”œâ”€ GMe1/                      # Datafolder or rat 1 of the in situ experiment                    \nâ”‚   â”œâ”€ dataExp/               # Experimentally measured data\nâ”‚   â”‚   â”œâ”€ QR/                # Quick-release data\nâ”‚   â”‚   â”œâ”€ SR/                # Step-ramp data\nâ”‚   â”‚   â”œâ”€ ISOM/              # Isometric data\nâ”‚   â”‚   â””â”€ SSC_PA/            # Stretch-shortening cycles data\nâ”‚   â”‚\nâ”‚   â”œâ”€ parameters/\nâ”‚   â”‚\nâ”‚   â””â”€ simsExp/               # Simulations based on experimental data (i.e., lmtc(t) and stim(t) as inputs)\nâ”‚       â”œâ”€ QR/\nâ”‚       â”œâ”€ SR/\nâ”‚       â””â”€ ISOM/\n|\nâ”œâ”€ GMe2/\nâ”‚   â”œâ”€ dataExp/\nâ”‚   â”œâ”€ parameters/\nâ”‚   â””â”€ simsExp/\n|\nâ””â”€ GMe3/\n    â”œâ”€ dataExp/\n    â”œâ”€ parameters/\n    â””â”€ simsExp/",
    "crumbs": [
      "{{< iconify fa6-regular floppy-disk >}} Data",
      "Data"
    ]
  },
  {
    "objectID": "tables/all_tables.html",
    "href": "tables/all_tables.html",
    "title": "Tables",
    "section": "",
    "text": "On this page you can find all tables and code to produce the tables of the manuscript."
  },
  {
    "objectID": "tables/all_tables.html#results",
    "href": "tables/all_tables.html#results",
    "title": "Tables",
    "section": "Results",
    "text": "Results\n\nTable 1\n\n\nCode\nimport os, pickle, sys\nimport numpy as np\nimport pandas as pd\nfrom great_tables import GT, style, md, loc\n\ncwd = os.getcwd()\nbaseDir = os.path.join(cwd,'..')\ndataDir = os.path.join(baseDir,'data')\nfuncDir = os.path.join(baseDir,'analysis', 'functions')\nsys.path.append(funcDir)\n\nfrom gt_tex import make_latex, delete_rows, insert_rows\n\n# Custom function\ndef compute_pdiffs(oPar, nPar, keys):\n    \"\"\"Compute percentage differences for all PARAM_KEYS.\"\"\"\n    return [((nPar[k]-oPar[k])/oPar[k])*100 for k in keys]\n\ndef format_single(values,form='{:2.0f}'):\n    \"\"\"Format list of diffs for UM/CM cases.\"\"\"\n    return [form.format(val) for val in values]\n\ndef format_mean_std(values,form='{:2.0f}'):\n    \"\"\"Format mean Â± std for MC case.\"\"\"\n    values_mean, values_std = np.mean(values, axis=0), np.std(values, axis=0)\n    return [f\"{form.format(m)} Â± {form.format(s)}\" for m, s in zip(values_mean, values_std)]\n\n#%% Extract parameters\nrows = np.array([\n    ['a',           '$a$',],\n    ['b',           '$b$',],\n    ['fmax',        '$F_{CE}^{max}$'],\n    ['kpee',        '$k_{PEE}$'],\n    ['ksee',        '$k_{SEE}$'],\n    ['lce_opt',     '$L_{CE}^{opt}$'],\n    ['lpee0',       '$L_{PEE}^0$'],\n    ['lsee0',       '$L_{SEE}^0$'],\n    ['tact',        '$\\\\tau_{act}$'],\n    ['tdeact',      '$\\\\tau_{deact}$'],\n])\nrow_keys, row_labels = map(list, zip(*rows))\n\nrecords = {}\nfor vPar in ['TM', 'IM', 'MC']:         \n    for mus in ['GMs1', 'GMs2', 'GMs3']:  \n        # Actual parameters\n        parFile = os.path.join(dataDir,mus,'parameters',mus+'_OR.pkl')\n        orPar = pickle.load(open(parFile, 'rb'))\n\n        if vPar != \"MC\":\n            parFile = os.path.join(dataDir,mus,'parameters',mus+'_'+vPar+'.pkl')\n            estPar = pickle.load(open(parFile, 'rb'))[0] \n            diffs = format_single(compute_pdiffs(orPar, estPar, row_keys),'{:2.0f}')\n        else:\n            A = []\n            for iMC in range(1, 51):\n                parFile = os.path.join(dataDir,mus,'parameters','mc',mus+f'_MC{iMC:02d}'+'.pkl')\n                estPar = pickle.load(open(parFile, 'rb'))[0]\n                A.append(compute_pdiffs(orPar, estPar, row_keys))\n            diffs = format_mean_std(np.array(A),'{:2.0f}')\n\n        # Store with a flat column name\n        col_name = f'{vPar}_{mus}'\n        records[col_name] = diffs\n\n#%% Create pandas dataframe\ndf = pd.DataFrame(records, index=row_labels)\n\n# %% TeX table\ndf_tex = df.copy().reset_index()\ndf_tex.index = row_labels\n\ntex_table = (GT(df_tex)\n    .cols_align(align='center') \n    .cols_align(align='left', columns=\"index\")\n    .cols_label(index='', TM_GMs1='GM1',TM_GMs2='GM2',TM_GMs3='GM3', IM_GMs1='GM1',IM_GMs2='GM2',IM_GMs3='GM3', MC_GMs1='GM1',MC_GMs2='GM2',MC_GMs3='GM3')\n    .tab_spanner(label='Traditional method', columns=['TM_GMs1', 'TM_GMs2', 'TM_GMs3'])\n    .tab_spanner(label='Improved method', columns=['IM_GMs1', 'IM_GMs2', 'IM_GMs3'])\n    .tab_spanner(label='Monte Carlo', columns=['MC_GMs1', 'MC_GMs2', 'MC_GMs3'])\n    .tab_style(\n    style=style.text(weight=\"bold\"),\n    locations=loc.body(columns=\"GM_GMs1\", rows=[1, 2]))\n)\n\nlatex_str = make_latex(tex_table.as_latex())\nlatex_str = delete_rows(latex_str, row_numbers=[0,1])\nadd_rows = {\n    0: r\" & \\multicolumn{3}{c|}{\\itshape Traditional method} & \\multicolumn{3}{c|}{\\itshape Improved method} & \\multicolumn{3}{c|}{\\itshape Monte Carlo} \\\\ \\hline\",\n    1: r\" & \\bfseries GM1 & \\bfseries GM2 & \\bfseries GM3 & \\bfseries GM1 & \\bfseries GM2 & \\bfseries GM3 & \\bfseries GM1 & \\bfseries GM2 & \\bfseries GM3 \\\\ \\hline\",\n}\nlatex_str = insert_rows(latex_str, add_rows)\n\n# Write to a .tex file\nwith open(\"tbl-r-pdiff.tex\", \"w\", encoding=\"utf-8\") as f:\n    f.write(latex_str)\n\n# %% Create GT\ndf_gt = df.reset_index()\n\ntm_w = '6%'\nmc_w = '12%'\n\ngt_table = (GT(df_gt)\n    .cols_align(align='center') \n    .cols_align(align='left', columns=\"index\")\n    .cols_label(index='', TM_GMs1='GM1',TM_GMs2='GM2',TM_GMs3='GM3', IM_GMs1='GM1',IM_GMs2='GM2',IM_GMs3='GM3', MC_GMs1='GM1',MC_GMs2='GM2',MC_GMs3='GM3')\n    .tab_spanner(label='Traditional method', columns=['TM_GMs1', 'TM_GMs2', 'TM_GMs3'])\n    .tab_spanner(label='Improved method', columns=['IM_GMs1', 'IM_GMs2', 'IM_GMs3'])\n    .tab_spanner(label='Monte Carlo', columns=['MC_GMs1', 'MC_GMs2', 'MC_GMs3'])\n    .cols_width(cases={'index': '6%', 'TM_GMs1':tm_w,'TM_GMs2':tm_w,'TM_GMs3':tm_w, 'IM_GMs1':tm_w,'IM_GMs2':tm_w,'IM_GMs3':tm_w, 'MC_GMs1':mc_w,'MC_GMs2':mc_w,'MC_GMs3':mc_w})\n)\n#gt_table.tab_options(column_labels_font_weight=\"bold\") # Bold headers\ngt_table\n\n\n\n\nTableÂ 1: Percentage differences between estimated and actual MTC parameter values.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTraditional method\nImproved method\nMonte Carlo\n\n\nGM1\nGM2\nGM3\nGM1\nGM2\nGM3\nGM1\nGM2\nGM3\n\n\n\n\n$a$\n1\n4\n2\n1\n3\n1\n1 Â± 2\n6 Â± 2\n1 Â± 2\n\n\n$b$\n-0\n2\n-1\n1\n2\n1\n1 Â± 2\n5 Â± 2\n1 Â± 2\n\n\n$F_{CE}^{max}$\n0\n-1\n0\n-0\n-1\n-0\n-0 Â± 1\n-2 Â± 1\n-0 Â± 1\n\n\n$k_{PEE}$\n3\n-9\n9\n-0\n0\n-0\n3 Â± 17\n3 Â± 16\n6 Â± 31\n\n\n$k_{SEE}$\n-39\n-27\n-37\n0\n-1\n0\n-37 Â± 6\n-36 Â± 6\n-36 Â± 6\n\n\n$L_{CE}^{opt}$\n-1\n-2\n-3\n-0\n0\n-0\n0 Â± 3\n0 Â± 2\n0 Â± 3\n\n\n$L_{PEE}^0$\n0\n-1\n-0\n-0\n0\n-0\n0 Â± 3\n1 Â± 2\n0 Â± 2\n\n\n$L_{SEE}^0$\n-1\n-0\n-0\n0\n-0\n0\n-0 Â± 1\n-0 Â± 1\n-0 Â± 1\n\n\n$\\tau_{act}$\n-21\n-16\n-21\n-0\n-1\n-0\n1 Â± 3\n-0 Â± 4\n1 Â± 4\n\n\n$\\tau_{deact}$\n-5\n-4\n-5\n0\n0\n0\n0 Â± 1\n0 Â± 1\n0 Â± 1\n\n\n\n\n\n\n        \n\n\n\n\n\n\n\n\n\nTable 2\n\n\nCode\n# %% Imports\nimport os\nimport sys\nimport pickle\nimport numpy as np\nimport pandas as pd\nfrom great_tables import GT, style, loc\n\n# Paths\ncwd = os.getcwd()\nbaseDir = os.path.join(cwd,'..')\ndataDir = os.path.join(baseDir,'data')\nfuncDir = os.path.join(baseDir,'analysis','functions')\nsys.path.append(funcDir)\n\n# Custom import\nfrom gt_tex import make_latex, delete_rows, insert_rows\n\ndef format_mean_std(values):\n    return f\"{form.format(np.mean(values))} Â± {form.format(np.std(values))}\"\n\n#%% Extract parameters\nform = \"{:0.1f}\"\n\n# Cols: changed parameters\ncols = [\n    ['a',             '$a$'], \n    ['b',             '$b$'], \n    ['fmax',          '$F_{CE}^{max}$'], \n    ['ksee',          '$k_{SEE}$'],\n    ['lce_opt',       '$L_{CE}^{opt}$'],\n    ['lsee0',         '$L_{SEE}^0$']]\ncol_keys, col_labels = map(list, zip(*cols))\n\n# Rows: affected parameters\nrows = [\n    ['a',             '$a$'], \n    ['b',             '$b$'], \n    ['fmax',          '$F_{CE}^{max}$'], \n    ['kpee',          '$k_{PEE}$'],\n    ['ksee',          '$k_{SEE}$'],\n    ['lce_opt',       '$L_{CE}^{opt}$'],\n    ['lpee0',         '$L_{PEE}^0$'], \n    ['lsee0',         '$L_{SEE}^0$'],\n    ['tact',          '$\\\\tau_{act}$'],\n    ['tdeact',        '$\\\\tau_{deact}$']]\nrow_keys, row_labels = map(list, zip(*rows))\n\nrecords = {}\nfor sPar in col_keys:   # outer loop: sensitivity parameter (columns)\n    all_ratios = {k: [] for k in row_keys}\n    for mus in ['GMs1', 'GMs2', 'GMs3']:\n        tmPar = pickle.load(open(os.path.join(dataDir,mus,'parameters',f\"{mus}_TM.pkl\"), 'rb'))[0]\n        \n        for fChange in [0.95, 1.05]:\n            saPar = pickle.load(open(os.path.join(dataDir, mus, \"parameters\",'interdep', f\"{mus}_{sPar}_{fChange*100:03.0f}.pkl\"), 'rb'))[0]\n            for k in row_keys:\n                all_ratios[k].append(saPar[k] / tmPar[k])\n    \n    # signed % diff from 1\n    diffs_signed = {}\n    for k, vals in all_ratios.items():\n        vals = np.array(vals)\n        sign = np.sign(vals - 1)[1]  \n        diffs_signed[k] = sign * np.abs(vals - 1) * 100\n    \n    # format mean Â± std\n    col_vals = [format_mean_std(diffs_signed[k]) for k in row_keys]\n    records[sPar] = col_vals\n\n# DataFrame with PARAM_KEYS as rows and sensitivity param as columns\ndf = pd.DataFrame(records, index=row_keys)\n\n# Apply dash overrides\nfor label in col_keys:\n    df.loc[label, label] = \"-\"\n\n# %% TeX table\ngt_df = df.copy()\ngt_df.index = row_labels\ngt_df = gt_df.reset_index()\nlabel_dict = {'index': '', **dict(zip(col_keys, col_labels))}\n\ngt_table = (GT(gt_df)\n    .cols_align(align='center') \n    .cols_align(align='left', columns=\"index\")\n    .cols_label(**label_dict)\n)\n\nlatex_str = make_latex(gt_table.as_latex())\nlatex_str = delete_rows(latex_str, row_numbers=[0])\nadd_rows = {\n    0: r\" & $\\mathbold{a}$ & $\\mathbold{b}$ & $\\mathbold{F_{CE}^{max}}$ & $\\mathbold{k_{SEE}}$ & $\\mathbold{L_{CE}^{opt}}$ & $\\mathbold{L_{SEE}^{0}}$ \\\\ \\hline\",\n}\nlatex_str = insert_rows(latex_str, add_rows)\n\n# Write to a .tex file\nwith open(\"tbl-r-interdep.tex\", \"w\", encoding=\"utf-8\") as f:\n    f.write(latex_str)\n\n# %% GT\ngt_df = df.copy()\ngt_df.index = row_labels\ngt_df = gt_df.reset_index()\nlabel_dict = {'index': '', **dict(zip(col_keys, col_labels))}\n\ncolw = \"14.28%\"\ngt_table = (\n    GT(gt_df)\n    .cols_align(align='center') \n    .cols_align(align='left', columns=\"index\")\n    .cols_label(**label_dict)\n    .tab_style(\n        style=style.text(weight=\"bold\"),    \n        locations=loc.column_labels()        \n    )\n    .cols_width(cases={\n        'index': colw, \n        'a': colw, \n        'b': colw, \n        'fmax': colw, \n        'ksee': colw, \n        'lce_opt': colw, \n        'lsee0': colw\n    })\n).tab_options(column_labels_font_weight=\"bold\") # Bold headers\n\ngt_table\n\n\n\n\nTableÂ 2: Interdependency of the estimated MTC parameter values. Each entry shows the percentage change in the row parameter resulting from a 5% change in the column parameter. All values are expressed as percentage changes.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n$a$\n$b$\n$F_{CE}^{max}$\n$k_{SEE}$\n$L_{CE}^{opt}$\n$L_{SEE}^0$\n\n\n\n\n$a$\n-\n10.1 Â± 1.3\n-14.0 Â± 1.0\n-0.6 Â± 0.2\n3.4 Â± 1.0\n-10.3 Â± 2.0\n\n\n$b$\n2.3 Â± 1.2\n-\n-14.3 Â± 3.1\n1.1 Â± 0.3\n3.9 Â± 1.1\n-10.8 Â± 1.6\n\n\n$F_{CE}^{max}$\n-0.6 Â± 0.1\n-0.6 Â± 0.1\n-\n-0.6 Â± 0.2\n-1.2 Â± 0.5\n3.5 Â± 0.5\n\n\n$k_{PEE}$\n-6.8 Â± 2.9\n-6.8 Â± 2.9\n-6.9 Â± 3.5\n-6.8 Â± 3.2\n-6.8 Â± 2.9\n-6.8 Â± 3.3\n\n\n$k_{SEE}$\n52.4 Â± 12.6\n52.4 Â± 12.8\n54.3 Â± 17.0\n-\n52.4 Â± 12.8\n52.5 Â± 14.3\n\n\n$L_{CE}^{opt}$\n1.9 Â± 0.6\n1.9 Â± 0.6\n-5.4 Â± 2.2\n1.9 Â± 0.6\n-\n-14.2 Â± 3.0\n\n\n$L_{PEE}^0$\n-0.6 Â± 0.7\n-0.6 Â± 0.7\n-0.6 Â± 0.7\n-0.6 Â± 0.7\n-0.6 Â± 0.7\n-10.6 Â± 1.2\n\n\n$L_{SEE}^0$\n0.5 Â± 0.2\n0.5 Â± 0.2\n1.8 Â± 0.6\n0.5 Â± 0.2\n-1.7 Â± 0.6\n-\n\n\n$\\tau_{act}$\n23.4 Â± 4.2\n23.4 Â± 4.6\n24.2 Â± 5.9\n23.3 Â± 5.0\n23.7 Â± 4.3\n20.9 Â± 6.3\n\n\n$\\tau_{deact}$\n4.8 Â± 0.7\n4.9 Â± 0.8\n5.0 Â± 3.1\n4.8 Â± 0.9\n4.9 Â± 1.4\n5.1 Â± 3.0"
  },
  {
    "objectID": "tables/all_tables.html#supplementary-material",
    "href": "tables/all_tables.html#supplementary-material",
    "title": "Tables",
    "section": "Supplementary material",
    "text": "Supplementary material\n\nTable S1\n\n\nCode\n# %% Imports\nimport os, pickle, sys\nimport numpy as np\nimport pandas as pd\nfrom great_tables import GT, style, loc\n\n# Paths\ncwd = os.getcwd()\nbaseDir = os.path.join(cwd,'..')\ndataDir = os.path.join(baseDir,'data')\nfuncDir = os.path.join(baseDir,'functions')\nsys.path.append(funcDir)\n\n# Custom import\nfrom gt_tex import make_latex, insert_rows, fix_reference, delete_rows, replace_latex_table_cell, insert_multicolumn\n\n#%% Extract parameters\n# to-do bshape\nparams = np.array([\n    ['a',           '$a$',                    'N',        'Contraction dynamics',     '@van_zandwijk_evaluation_1997'],\n    ['b',           '$b$',                    'mm',       'Contraction dynamics',     '@van_zandwijk_evaluation_1997'],\n    ['vfactmin',    '$b_{scale}^{min}$',      '-',        'Contraction dynamics',     '@van_soest_contribution_1993'],\n    ['bshape',      '$b_{shape}$',            '-',        'Contraction dynamics',     '@van_soest_contribution_1993'],\n    ['fasymp',      '$F_{asymp}$',            '-',        'Contraction dynamics',     '@rijkelijkhuizen_forcevelocity_2003'],\n    ['fmax',        '$F_{CE}^{max}$',         'N',        'Contraction dynamics',     '@van_zandwijk_evaluation_1997'],\n    ['kpee',        '$k_{PEE}$',              'N/mm&lt;sup&gt;2&lt;/sup&gt;',  'Contraction dynamics',     '@van_zandwijk_evaluation_1997'],\n    ['ksee',        '$k_{SEE}$',              'N/mm&lt;sup&gt;2&lt;/sup&gt;',  'Contraction dynamics',     '@van_zandwijk_evaluation_1997'],\n    ['lce_opt',     '$L_{CE}^{opt}$',         'mm',       'Contraction dynamics',     '@van_zandwijk_evaluation_1997'],\n    ['lpee0',       '$L_{PEE}^0$',            'mm',       'Contraction dynamics',     '@van_zandwijk_evaluation_1997'],\n    ['lsee0',       '$L_{SEE}^0$',            'mm',       'Contraction dynamics',     '@van_zandwijk_evaluation_1997'],\n    ['r_as',        '$r_{as}$',               '-',        'Contraction dynamics',     'Arbitrary small value'],\n    ['slopfac',     '$r_{slope}$',            'mm',       'Contraction dynamics',     '@katz_relation_1939'],\n    ['w',           '$w$',                    '-',        'Contraction dynamics',     '@burkholder_sarcomere_2001'],\n    ['a_act',       '$a_{act}$',              '?',        'Excitation dynamics',      '@bortolotto_mhc_2000'],\n    ['b_act1',      '$b_{act,1}$',            '?',        'Excitation dynamics',      '@bortolotto_mhc_2000'],\n    ['b_act2',      '$b_{act,2}$',            '?',        'Excitation dynamics',      '@stephenson_effects_1982'],\n    ['b_act3',      '$b_{act,3}$',            '?',        'Excitation dynamics',      '@stephenson_effects_1982'],\n    ['kCa',         '$kCa$',                  'mol/L',    'Excitation dynamics',      '@kistemaker_length-dependent_2005'],\n    ['gamma_0',     '$\\\\gamma_0$',            '-',        'Excitation dynamics',      'Arbitrary small value'],\n    ['q0',          '$q_0$',                  '-',        'Excitation dynamics',      '@hatze_myocybernetic_1981'],\n    ['tact',        '$\\\\tau_{act}$',          'ms',       'Excitation dynamics',      '@van_zandwijk_evaluation_1997'],\n    ['tdeact',      '$\\\\tau_{deact}$',        'ms',       'Excitation dynamics',      '@van_zandwijk_evaluation_1997'],\n])\n\ncitation_map = {\n    \"van_zandwijk_evaluation_1997\": \"van Zandwijk et al.\",\n    \"van_soest_contribution_1993\": \"van Soest and Bobbert\",\n    \"rijkelijkhuizen_forcevelocity_2003\": \"Rijkelhuizen et al.\",\n    \"katz_relation_1939\": \"Katz (1939)\",\n    \"burkholder_sarcomere_2001\": \"Burkholder and Lieber\",\n    \"bortolotto_mhc_2000\": \"Bortolotto et al.\",\n    \"stephenson_effects_1982\": \"Stephenson and Williams\",\n    \"kistemaker_length-dependent_2005\": \"Kistemaker et al.\",\n    \"hatze_myocybernetic_1981\": \"Hatze\"\n}\n\ndef replace_citation(x):\n    if x.startswith('@'):\n        key = x[1:]\n        display = citation_map.get(key, key)\n\n        # extract the year = last underscore-separated part\n        parts = key.split('_')\n        year = parts[-1] if parts[-1].isdigit() else \"year\"\n\n        return (\n            f'&lt;span class=\"citation\" data-cites=\"{key}\"&gt;'\n            f'{display} (&lt;a href=\"#ref-{key}\" role=\"doc-biblioref\" aria-expanded=\"false\"&gt;{year}&lt;/a&gt;)'\n            f'&lt;/span&gt;'\n        )\n    return x\n\nparams = np.array([[replace_citation(x) for x in row] for row in params]) \n\norParms = []\nfor mus in ['GMs1','GMs2','GMs3']:   \n    orPar = pickle.load(open(os.path.join(dataDir,mus,'parameters',mus+'_OR.pkl'), 'rb'))\n    \n    # b_act is an array, extract the values\n    orPar['b_act1'], orPar['b_act2'], orPar['b_act3'] = orPar['b_act']\n    \n    # This is a magic number in the functin, well anyway add it here!\n    orPar['bshape'] = 22\n    \n    # Compute r_as, this is the the increase in relative CE force (Fce/Fmax) per unit of relative CE velocity (vce/lce_opt)\n    orPar['r_as'] = (orPar['slopfac']*0.005*0.0975*(1+orPar['a']/orPar['fmax'])) / (orPar['vfactmin']*orPar['b']/orPar['lce_opt'])\n        \n    parms = [orPar[k] for k in params[:,0]]\n    orParms.append(parms)\n\n#%% Create pandas dataframe\ndf = pd.DataFrame(list(zip(*orParms)), columns=['GM1', 'GM2', 'GM3'], index=params[:,0])\n\n# Some are in other units so..\nfor parm in ['b', 'lce_opt', 'lpee0', 'lsee0', 'tact', 'tdeact']:\n    df.loc[parm] = df.loc[parm]*1e3\nfor parm in ['kpee', 'ksee']:\n    df.loc[parm] = df.loc[parm]/1e3\n\n# Add partype\npar_type = ['Contraction dynamics']*8 + 2*['Excitation dynamics']\n\ndf.insert(0, \"Parameter\", params[:,1]) \ndf.insert(1, \"Unit\", params[:,2]) \ndf.insert(2, \"Partype\", params[:,3]) \ndf.insert(6, \"Reference\", params[:,4]) \n\n# %% TeX table\ndf_tex = df.drop('Partype', axis=1) # Remove Partype for LateX table\ngt_table = (GT(df_tex)\n    #.tab_stub(rowname_col=\"Parameter\", groupname_col=\"Partype\")\n    .cols_align(align='left', columns=\"Parameter\")\n    .cols_align(align='center', columns=[\"GM1\", \"GM2\", \"GM3\"]) \n    .fmt_number(columns=[\"GM1\", \"GM2\", \"GM3\"], n_sigfig=3, sep_mark='',)\n    .fmt_scientific(columns=[\"GM1\", \"GM2\", \"GM3\"], n_sigfig=3, rows=['$k_{PEE}$, $k_{SEE}$, $r_{as}$', '$\\\\gamma_0$', '$kCa$', '$q_0$'])\n    .cols_width(cases={\"GM1\": \"100px\", \"GM2\": \"100px\", \"GM3\": \"100px\"})\n)\n\n# Transform to LateX table\nlatex_str = make_latex(gt_table.as_latex())\nlatex_str = delete_rows(latex_str, row_numbers=[0])\nadd_rows = {\n    0: r\" \\bfseries Parameter & \\bfseries Unit & \\bfseries GM1 & \\bfseries GM2 & \\bfseries GM3 & \\bfseries Reference \\\\ \\hline\",\n    1: r\"\\multicolumn{6}{|l|}{\\itshape Contraction dynamics} \\\\ \\hline\",\n    14: r\"\\multicolumn{6}{|l|}{\\itshape Excitation dynamics} \\\\ \\hline\"\n}\nlatex_str = insert_rows(latex_str, add_rows)\n\ncitation_map = {\n    \"van_zandwijk_evaluation_1997\": \"van Zandwijk et al. (1996)\",\n    \"van_soest_contribution_1993\": \"van Soest and Bobbert (1993)\",\n    \"rijkelijkhuizen_forcevelocity_2003\": \"Rijkelhuizen et al. (2003)\",\n    \"katz_relation_1939\": \"Katz (1939)\",\n    \"burkholder_sarcomere_2001\": \"Burkholder and Lieber (2001)\",\n    \"bortolotto_mhc_2000\": \"Bortolotto et al. (2000)\",\n    \"stephenson_effects_1982\": \"Stephenson and Williams (1982)\",\n    \"kistemaker_length-dependent_2005\": \"Kistemaker et al. (2005)\",\n    \"hatze_myocybernetic_1981\": \"Hatze (1981)\"\n}\nlatex_str = fix_reference(latex_str, citation_map)\nlatex_str = replace_latex_table_cell(latex_str, row=7, col=1, new_text=r'N/mm\\textsuperscript{2}')\nlatex_str = replace_latex_table_cell(latex_str, row=8, col=1, new_text=r'N/mm\\textsuperscript{2}')\nlatex_str = replace_latex_table_cell(latex_str, row=12, col=2, new_text=r'$3.71 \\cdot 10^{-3}$')\nlatex_str = replace_latex_table_cell(latex_str, row=12, col=3, new_text=r'$5.45 \\cdot 10^{-3}$')\nlatex_str = replace_latex_table_cell(latex_str, row=12, col=4, new_text=r'$3.16 \\cdot 10^{-3}$')\nlatex_str = insert_multicolumn(latex_str=latex_str, row=3, col_start=2, col_span=3, text=\"0.100\", align='c|')\nlatex_str = insert_multicolumn(latex_str=latex_str, row=4, col_start=2, col_span=3, text=\"22.0\", align='c|')\nlatex_str = insert_multicolumn(latex_str=latex_str, row=5, col_start=2, col_span=3, text=\"1.50\", align='c|')\nlatex_str = insert_multicolumn(latex_str=latex_str, row=13, col_start=2, col_span=3, text=\"2.00\", align='c|')\nlatex_str = insert_multicolumn(latex_str=latex_str, row=14, col_start=2, col_span=3, text=\"0.50\", align='c|')\nlatex_str = insert_multicolumn(latex_str=latex_str, row=15, col_start=2, col_span=3, text=\"-7.37\", align='c|')\nlatex_str = insert_multicolumn(latex_str=latex_str, row=16, col_start=2, col_span=3, text=\"5.17\", align='c|')\nlatex_str = insert_multicolumn(latex_str=latex_str, row=17, col_start=2, col_span=3, text=\"0.596\", align='c|')\nlatex_str = insert_multicolumn(latex_str=latex_str, row=18, col_start=2, col_span=3, text=\"0.00\", align='c|')\nlatex_str = insert_multicolumn(latex_str=latex_str, row=19, col_start=2, col_span=3, text=r\"$8.00 \\cdot 10^{-6}$\", align='c|')\nlatex_str = insert_multicolumn(latex_str=latex_str, row=20, col_start=2, col_span=3, text=r\"$1.00 \\cdot 10^{-5}$\", align='c|')\nlatex_str = insert_multicolumn(latex_str=latex_str, row=21, col_start=2, col_span=3, text=r\"$5.00 \\cdot 10^{-3}$\", align='c|')\nlatex_str = insert_multicolumn(latex_str=latex_str, row=22, col_start=2, col_span=3, text=\"27.0\", align='c|')\nlatex_str = insert_multicolumn(latex_str=latex_str, row=23, col_start=2, col_span=3, text=\"27.0\", align='c|')\n\n# Write to a .tex file\nwith open(\"supptbl-overview.tex\", \"w\", encoding=\"utf-8\") as f:\n    f.write(latex_str)\n\n# %% GT\ndf_gt = df.copy()\n\ngt_table = (GT(df_gt)\n    .tab_stub(rowname_col=\"Parameter\", groupname_col=\"Partype\")\n    .cols_align(align='left', columns=\"Parameter\")\n    .cols_align(align='center', columns=[\"GM1\", \"GM2\", \"GM3\"]) \n    .tab_style(style = style.text(style = \"italic\"), locations = loc.row_groups())\n    .tab_style(style = style.borders(sides=\"right\", color=\"#D3D3D3\", weight = \"0px\", style = \"solid\"), locations = loc.body(columns=\"Parameter\"))\n    .tab_style(style = style.borders(sides=\"right\", color=\"#D3D3D3\", weight = \"2px\", style = \"solid\"), locations = loc.body(columns=[\"Unit\", \"GM1\", \"GM2\", \"GM3\"]))\n    .fmt_number(columns=[\"GM1\", \"GM2\", \"GM3\"], n_sigfig=3)\n    .fmt_scientific(columns=[\"GM1\", \"GM2\", \"GM3\"], n_sigfig=3, rows=['$k_{PEE}$, $k_{SEE}$, $r_{as}$', '$\\\\gamma_0$', '$kCa$', '$q_0$'])\n    #.fmt_scientific(columns=[\"GM1\", \"GM2\", \"GM3\"], n_sigfig=3)\n    .cols_width(cases={\"GM1\": \"100px\", \"GM2\": \"100px\", \"GM3\": \"100px\"})\n)\n\n#print(gt_table.as_raw_html())\ngt_table\n\n\n\n\nTable S1\n\n\n\n\n\n\n\n\n\n\n\n\nMTC parameter values obtained from literature to simulate data.\n\n\n\nUnit\nGM1\nGM2\nGM3\nReference\n\n\n\n\nContraction dynamics\n\n\n$a$\nN\n2.68\n1.80\n2.58\nvan Zandwijk et al. (1997)\n\n\n$b$\nmm\n41.6\n24.8\n41.8\nvan Zandwijk et al. (1997)\n\n\n$b_{scale}^{min}$\n-\n0.100\n0.100\n0.100\nvan Soest and Bobbert (1993)\n\n\n$b_{shape}$\n-\n22.0\n22.0\n22.0\nvan Soest and Bobbert (1993)\n\n\n$F_{asymp}$\n-\n1.50\n1.50\n1.50\nRijkelhuizen et al. (2003)\n\n\n$F_{CE}^{max}$\nN\n13.4\n13.8\n12.3\nvan Zandwijk et al. (1997)\n\n\n$k_{PEE}$\nN/mm2\n213\n165\n511\nvan Zandwijk et al. (1997)\n\n\n$k_{SEE}$\nN/mm2\n4,220\n3,640\n3,470\nvan Zandwijk et al. (1997)\n\n\n$L_{CE}^{opt}$\nmm\n13.2\n12.3\n11.2\nvan Zandwijk et al. (1997)\n\n\n$L_{PEE}^0$\nmm\n13.9\n13.2\n13.4\nvan Zandwijk et al. (1997)\n\n\n$L_{SEE}^0$\nmm\n28.3\n30.3\n26.5\nvan Zandwijk et al. (1997)\n\n\n$r_{as}$\n-\n0.00371\n0.00545\n0.00316\nArbitrary small value\n\n\n$r_{slope}$\nmm\n2.00\n2.00\n2.00\nKatz (1939) (1939)\n\n\n$w$\n-\n0.500\n0.500\n0.500\nBurkholder and Lieber (2001)\n\n\nExcitation dynamics\n\n\n$a_{act}$\n?\nâˆ’7.37\nâˆ’7.37\nâˆ’7.37\nBortolotto et al. (2000)\n\n\n$b_{act,1}$\n?\n5.17\n5.17\n5.17\nBortolotto et al. (2000)\n\n\n$b_{act,2}$\n?\n0.596\n0.596\n0.596\nStephenson and Williams (1982)\n\n\n$b_{act,3}$\n?\n0.00\n0.00\n0.00\nStephenson and Williams (1982)\n\n\n$kCa$\nmol/L\n8.00 Ã— 10âˆ’6\n8.00 Ã— 10âˆ’6\n8.00 Ã— 10âˆ’6\nKistemaker et al. (2005)\n\n\n$\\gamma_0$\n-\n1.00 Ã— 10âˆ’5\n1.00 Ã— 10âˆ’5\n1.00 Ã— 10âˆ’5\nArbitrary small value\n\n\n$q_0$\n-\n5.00 Ã— 10âˆ’3\n5.00 Ã— 10âˆ’3\n5.00 Ã— 10âˆ’3\nHatze (1981)\n\n\n$\\tau_{act}$\nms\n27.0\n27.0\n27.0\nvan Zandwijk et al. (1997)\n\n\n$\\tau_{deact}$\nms\n27.0\n27.0\n27.0\nvan Zandwijk et al. (1997)\n\n\n\n\n\n\n        \n\n\n\n\n\n\n\n\nTable S2\n\n\nCode\n# %% Imports\nimport os, pickle, sys\nimport numpy as np\nimport pandas as pd\nfrom great_tables import GT, style, loc\n\n# Paths\ncwd = os.getcwd()\nbaseDir = os.path.join(cwd,'..')\ndataDir = os.path.join(baseDir,'data')\nfuncDir = os.path.join(baseDir,'functions')\nsys.path.append(funcDir)\n\n# Custom imports\nfrom gt_tex import make_latex, insert_rows, delete_rows, replace_latex_table_cell\n\n# %% Extract parameters\nrows = [\n    ['a',           '$a$',              'N'],\n    ['b',           '$b$',              'mm'],\n    ['fmax',        '$F_{CE}^{max}$',   'N'],\n    ['kpee',        '$k_{PEE}$',        'N/mm&lt;sup&gt;2&lt;/sup&gt;'],\n    ['ksee',        '$k_{SEE}$',        'N/mm&lt;sup&gt;2&lt;/sup&gt;'],\n    ['lce_opt',     '$L_{CE}^{opt}$',   'mm'],\n    ['lpee0',       '$L_{PEE}^0$',      'mm'],\n    ['lsee0',       '$L_{SEE}^0$',      'mm'],\n    ['tact',        '$\\\\tau_{act}$',    'ms'],\n    ['tdeact',      '$\\\\tau_{deact}$',  'ms'],\n]\nparam_keys, row_labels, unit = map(list, zip(*rows))\n\ncols = [\n    ['TM_GMe1',     'Rat 1'],\n    ['TM_GMe2',     'Rat 2'],\n    ['TM_GMe3',     'Rat 3'],\n    ['IM_GMe1',     'Rat 1'],\n    ['IM_GMe2',     'Rat 2'],\n    ['IM_GMe3',     'Rat 3'],\n]\ncol_keys, col_labels = map(list, zip(*cols))\n\ntmParms,imParms = [],[]\nfor mus in ['GMe1','GMe2','GMe3']:   \n    tmPar = pickle.load(open(os.path.join(dataDir,mus,'parameters',mus+'_TM.pkl'), 'rb'))[0]\n    imPar = pickle.load(open(os.path.join(dataDir,mus,'parameters',mus+'_IM.pkl'), 'rb'))[0]\n    \n    parms = [tmPar[k] for k in param_keys]\n    tmParms.append(parms)\n    parms = [imPar[k] for k in param_keys]\n    imParms.append(parms)\n    \n#%% Create pandas dataframe\ndf = pd.DataFrame(list(zip(*tmParms,*imParms)), columns=col_keys, index=param_keys)\n\n# Some are in other units so..\nfor parm in ['b', 'lce_opt', 'lpee0', 'lsee0', 'tact', 'tdeact']:\n    df.loc[parm] = df.loc[parm]*1e3\nfor parm in ['kpee', 'ksee']:\n    df.loc[parm] = df.loc[parm]/1e3\n\n# Add unit as column\ndf.insert(0, \"Unit\", unit)\n\n#%% TeX table\ndf_gt = df.copy()\ndf_gt.index = row_labels\ndf_gt = df_gt.reset_index()\ndf_tex = df_gt\n\nlabel_dict = {'index': 'Parameter', **dict(zip(col_keys, col_labels))}\n\ngt_table = (GT(df_tex)\n    .cols_align(align='center') \n    .cols_align(align='left', columns=\"index\")\n    .tab_spanner(label='Traditional method', columns=['TM_GMe1', 'TM_GMe2', 'TM_GMe3'])\n    .tab_spanner(label='Improved method', columns=['IM_GMe1', 'IM_GMe2', 'IM_GMe3'])\n    .cols_label(**label_dict)\n    .fmt_number(columns=col_keys, n_sigfig=3, sep_mark='')\n)\n\n# Transform to LateX table\nlatex_str = make_latex(gt_table.as_latex())\nlatex_str = delete_rows(latex_str, row_numbers=[0,1])\nadd_rows = {\n    0: r\"  & & \\multicolumn{3}{c|}{\\itshape Traditional method} & \\multicolumn{3}{c|}{\\itshape Improved method} \\\\ \\hline\",\n    1: r\"  \\bfseries Parameter & \\bfseries Unit & \\bfseries Rat 1 & \\bfseries Rat 2 & \\bfseries Rat 3 & \\bfseries Rat 1 & \\bfseries Rat 2 & \\bfseries Rat 3 \\\\ \\hline\"\n}\nlatex_str = insert_rows(latex_str, add_rows)\n#latex_str = replace_latex_table_cell(latex_str, row=5, col=1, new_text=r'N/mm\\textsuperscript{2}')\n#latex_str = replace_latex_table_cell(latex_str, row=6, col=1, new_text=r'N/mm\\textsuperscript{2}')\n\n# Write to a .tex file\nwith open(\"supptbl-insitu.tex\", \"w\", encoding=\"utf-8\") as f:\n    f.write(latex_str)\n\n# %% GT\ngt_df = df.copy()\ngt_df.index = row_labels\ngt_df = gt_df.reset_index()\nlabel_dict = {'index': '', **dict(zip(col_keys, col_labels))}\n\ncolw = '12.5%'\ngt_table = (GT(gt_df)\n    .cols_align(align='center') \n    .cols_align(align='left', columns=\"index\")\n    .tab_spanner(label='Traditional method', columns=['TM_GMe1', 'TM_GMe2', 'TM_GMe3'])\n    .tab_spanner(label='Improved method', columns=['IM_GMe1', 'IM_GMe2', 'IM_GMe3'])\n    .cols_label(**label_dict)\n    .tab_style(\n        style=style.borders(sides=[\"top\", \"bottom\"], weight='2px', color=\"red\"),\n        locations=loc.body(rows=[4])\n    )\n    .fmt_number(columns=col_keys, n_sigfig=3, sep_mark='')\n    .cols_width(cases={'index': colw, 'Unit': colw, \n        'TM_GMe1': colw, 'TM_GMe2': colw, 'TM_GMe3': colw,\n        'IM_GMe1': colw, 'IM_GMe2': colw, 'IM_GMe3': colw})\n)\n\ngt_table\n\n\n\n\nTable S2\n\n\n\n\n\n\n\n\n\n\n\n\nEstimated parameter values of the experimentally measured in situ data using both the traditional as well as the improved method.\n\n\n\n\n\n\n\n\n\n\n\n\n\nUnit\nTraditional method\nImproved method\n\n\nRat 1\nRat 2\nRat 3\nRat 1\nRat 2\nRat 3\n\n\n\n\n$a$\nN\n8.90\n11.3\n10.5\n8.82\n10.0\n11.0\n\n\n$b$\nmm\n76.7\n108\n84.6\n81.9\n105\n90.6\n\n\n$F_{CE}^{max}$\nN\n15.6\n14.1\n17.1\n15.5\n14.1\n17.0\n\n\n$k_{PEE}$\nN/mm2\n9.83\n7.25\n21.9\n28.7\n24.1\n34.8\n\n\n$k_{SEE}$\nN/mm2\n608\n688\n654\n952\n1260\n1050\n\n\n$L_{CE}^{opt}$\nmm\n12.4\n12.9\n12.3\n13.7\n14.7\n13.3\n\n\n$L_{PEE}^0$\nmm\n12.4\n12.4\n13.3\n15.1\n15.6\n14.5\n\n\n$L_{SEE}^0$\nmm\n29.0\n29.7\n25.1\n28.8\n29.3\n25.2\n\n\n$\\tau_{act}$\nms\n43.0\n32.4\n23.6\n55.2\n57.7\n41.6\n\n\n$\\tau_{deact}$\nms\n23.8\n20.9\n19.7\n27.1\n25.3\n22.4\n\n\n\n\n\n\n        \n\n\n\n\n\n\n\n\n\n\n\nTable S3\n\n\nCode\n# %% Imports\nimport pickle, os, sys, glob\nimport numpy as np\nimport pandas as pd\nfrom pathlib import Path\nfrom great_tables import GT\n\n# Set directories\ncwd = Path.cwd()\nbaseDir = cwd.parent\ndataDir = baseDir / 'data'\nfuncDir = baseDir / 'analysis' / 'functions'\nsys.path.append(str(funcDir))\n\nfrom stats import rmse\nfrom helpers import get_stim\nfrom gt_tex import make_latex, insert_rows, delete_rows\n\n#%% Parameters\npar_models = ['TM', 'IM']\nexperiments = ['QR', 'SR', 'ISOM', 'SSC']\nmuscles = ['GMe1', 'GMe2', 'GMe3']\n\n#%% Create DataFrame: rows = experiments, columns = GMe1_UM, GMe1_CM, ..., Average_UM, etc.\ncolumns = [f'{model}_{exp}' for model in par_models for exp in experiments]\nrows = muscles + ['Avg Â± Std']\ndf = pd.DataFrame(index=rows, columns=columns, dtype=str)\n\n#%% Loop through experiments\nfor exp in experiments:\n    for model in par_models:\n        all_rmsd = []\n        for mus in muscles:\n            # Load parameter\n            parFile = os.path.join(dataDir, mus, 'parameters', f'{mus}_{model}.pkl')\n            muspar = pickle.load(open(parFile, 'rb'))[0]\n\n            dataDirExp = os.path.join(dataDir, mus, 'dataExp', exp)\n            rrunDirExp = os.path.join(dataDir, mus, 'simsExp', model, exp)\n\n            dataFiles = sorted(glob.glob(os.path.join(dataDirExp, '*')))\n            rrunFiles = sorted(glob.glob(os.path.join(rrunDirExp, '*')))\n\n            rms_list = []\n            for dataFile, rrunFile in zip(dataFiles, rrunFiles):\n                dataFilename = os.path.basename(dataFile)[:-4]\n                rrunFilename = os.path.basename(rrunFile)[:-4]\n                if dataFilename[:-3] != rrunFilename[:-3]:\n                    raise ValueError(f\"File mismatch: {dataFilename} vs {rrunFilename}\")\n\n                dataData = pd.read_csv(dataFile).T.to_numpy()[0:4]\n                rrunData = pd.read_csv(rrunFile).T.to_numpy()\n\n                time1, _, stim1, fsee1 = dataData\n                time2, _, _, fsee2 = rrunData\n\n                tStimOn, tStimOff = get_stim(time1, stim1)[1:]\n                iStart = int(np.argmin(abs(time1 - tStimOn[0])))\n\n                if exp == 'ISOM':\n                    iStop = int(np.argmin(abs(time1 - 0.1 - tStimOff[0])))\n                elif exp in ['QR', 'SR']:\n                    iStop = int(np.argmin(abs(time1 - tStimOff[0])))\n                else:  # SSC\n                    iStop = int(np.argmin(abs(time1 - tStimOff[-1])))\n\n                rms = rmse(fsee1[iStart:iStop], fsee2[iStart:iStop]) / muspar['fmax'] * 100\n                rms_list.append(rms)\n\n            M = np.mean(rms_list)\n            S = np.std(rms_list)\n\n            df.loc[mus, f'{model}_{exp}'] = f'{M:.1f} Â± {S:.1f}'\n            all_rmsd += rms_list  # just mean, for averaging across muscles\n\n        # Average over muscles for this (exp, model)\n        avg_M = np.mean(all_rmsd)\n        avg_S = np.std(all_rmsd)\n        df.loc['Avg Â± Std', f'{model}_{exp}'] = f'{avg_M:.1f} Â± {avg_S:.1f}'\n\n#%% Mapping of rows and columns\n# Rows: affected parameters\nrows = [\n    ['GMe1',        'Rat 1'], \n    ['GMe2',        'Rat 2'], \n    ['GMe3',        'Rat 3'], \n    ['Avg Â± Std',   'Avg Â± Std']]\nrow_keys, row_labels = map(list, zip(*rows))\n\ncols = [\n    ['TM_QR',     'QR'],\n    ['TM_SR',     'SR'],\n    ['TM_ISOM',   'ISOM'],\n    ['TM_SSC',    'SSC'],\n    ['IM_QR',     'QR'],\n    ['IM_SR',     'SR'],\n    ['IM_ISOM',   'ISOM'],\n    ['IM_SSC',    'SSC'],\n]\ncol_keys, col_labels = map(list, zip(*cols))\n\nlabel_dict = {'index': '', **dict(zip(col_keys, col_labels))}\n\n# %% TeX table\ndf_tex = df.copy()\ndf_tex.index = row_labels\ndf_tex = df_tex.reset_index()\n\ngt_table = (GT(df_tex)\n    .cols_align(align='center') \n    .cols_align(align='left', columns=\"index\")\n    .tab_spanner(label='Traditional method', columns=col_keys[:4])\n    .tab_spanner(label='Improved method', columns=col_keys[4:])\n    .cols_label(**label_dict)\n)\n\n# Transform to LateX table\nlatex_str = make_latex(gt_table.as_latex())\nlatex_str = delete_rows(latex_str, row_numbers=[0,1])\nadd_rows = {\n    0: r\" & \\multicolumn{4}{c|}{\\itshape Traditional method} & \\multicolumn{4}{c|}{\\itshape Improved method} \\\\ \\hline\",\n    1: r\" & \\bfseries QR & \\bfseries SR & \\bfseries ISOM & \\bfseries SSC & \\bfseries QR & \\bfseries SR & \\bfseries ISOM & \\bfseries SSC \\\\ \\hline\"\n}\nlatex_str = insert_rows(latex_str, add_rows)\nlatex_str += r\"\\break\\hfill\\footnotesize{Root mean squared differences are expressed as a percentage of the maximal isometric CE force ($F_{CE}^{max}$). Root mean squared differences were computed over the interval in which CE stimulation was maximal for the quick-release and step-ramp experiments and was computed over the interval from CE stimulation onset to 0.1 s after CE stimulation offset for the isometric experiments and the stretch-shortening cycles.}\"\nprint(latex_str)\n\n# Write to a .tex file\nwith open(\"supptbl-rmsd.tex\", \"w\", encoding=\"utf-8\") as f:\n    f.write(latex_str)\n\n# %% GT Table\ndf_gt = df.copy()\ndf_gt.index = row_labels\ndf_gt = df_gt.reset_index()\n\ngt_table = (GT(df_gt)\n    .cols_align(align='center') \n    .cols_align(align='left', columns=\"index\")\n    .tab_spanner(label='Traditional method', columns=col_keys[:4])\n    .tab_spanner(label='Improved method', columns=col_keys[4:])\n    .cols_label(**label_dict)\n)\n\n\n\n\n\nTable S3\n\n\n\n\n\n\n\n\n\n\n\n\nRoot mean squared differences between experimentally measured SEE force histories and those predicted by Hill-type MTC model after estimating all contraction and excitation dynamics parameter values.\n\n\n\nTraditional method\nImproved method\n\n\nQR\nSR\nISOM\nSSC\nQR\nSR\nISOM\nSSC\n\n\n\n\nRat 1\n5.6 Â± 3.4\n5.6 Â± 0.8\n6.8 Â± 3.2\n6.2 Â± 3.0\n3.3 Â± 1.5\n2.8 Â± 0.9\n5.4 Â± 3.0\n5.4 Â± 3.1\n\n\nRat 2\n4.2 Â± 1.5\n5.0 Â± 0.6\n4.3 Â± 1.6\n4.6 Â± 2.2\n2.7 Â± 1.6\n2.1 Â± 0.5\n4.2 Â± 2.6\n4.2 Â± 2.0\n\n\nRat 3\n6.4 Â± 2.3\n6.8 Â± 1.0\n6.1 Â± 2.1\n5.5 Â± 2.7\n4.2 Â± 1.8\n2.6 Â± 0.5\n4.9 Â± 2.3\n5.0 Â± 2.7\n\n\nAvg Â± Std\n5.4 Â± 2.6\n5.8 Â± 1.1\n5.7 Â± 2.7\n5.4 Â± 2.7\n3.4 Â± 1.8\n2.5 Â± 0.7\n4.8 Â± 2.7\n4.9 Â± 2.7"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Evaluating the Accuracy of Muscle Property Estimations: Insights from Hill-Type Muscle Model Simulations",
    "section": "",
    "text": "This website presents the complete, reproducible workflow of our manuscript. The entire project was built using Quarto, an open-source scientific and technical publishing system. By using Quarto, we seamlessly embedded all analysis, code, figures, tables, and results into our manuscript. This approach ensures that every result in the manuscript is directly traceable to its source code and data, with no ambiguity about how it was produced. Interested readers can reproduce our results by rendering the Quarto project in its entirety.\n\n\n\n\n\n\nImportant\n\n\n\nThe manuscript of this project has not yet been peer-reviewed or formally published. Changes might be might throughout the peer-review process.\n\n\nOn this website, youâ€™ll find:\n\nğŸ“‚ Data â€“ Full access to the raw data and simulations results\nğŸ”¬ Analysis â€“ A step-by-step walkthrough of the analysis pipeline\nğŸ“Š Figures â€“ Reproducible code for all figures\nğŸ“‹ Tables â€“ Reproducible code for all tables\nğŸ“„ Manuscript â€“ An integrated HTML version of the manuscript"
  },
  {
    "objectID": "data/make_sim_data.html",
    "href": "data/make_sim_data.html",
    "title": "Simulated data",
    "section": "",
    "text": "On this page you can find the code to make the simulated data described in the section: â€œSimulated dataâ€.",
    "crumbs": [
      "{{< iconify fa6-regular floppy-disk >}} Data",
      "Data",
      "Simulated data"
    ]
  },
  {
    "objectID": "data/make_sim_data.html#obtain-parameters",
    "href": "data/make_sim_data.html#obtain-parameters",
    "title": "Simulated data",
    "section": "Obtain parameters",
    "text": "Obtain parameters\nThe following simple script was used to create pickles with the â€˜actualâ€™ parameter values, which were obtained from literature (see manuscript).\n\n\nCode\n# %% Load packages\nimport pickle, os\nimport numpy as np\nfrom pathlib import Path\n\n# Directories\ncwd = Path.cwd()\nbaseDir = cwd.parent\ndataDir = baseDir / 'data'\n\n# %% Make dict with parameters values and save as pickle\nfor mus in ['GMs1','GMs2','GMs3']:\n    muspar = {}\n    \n    # Force-length relationship\n    muspar['w'] = 0.5;\n    muspar['n'] = 2\n    \n    # Force-velocity relationship\n    muspar['fasymp'] = 1.5\n    muspar['slopfac'] = 2\n    muspar['vfactmin'] = 0.1\n    \n    # Activation dynamics    \n    muspar['a_act'] = -7.369163055099003\n    muspar['b_act'] = np.array([5.170927028993413, 0.5955111970420514, 0])\n    muspar['q0'] = 0.005\n    muspar['gamma_0'] = 1e-5\n    muspar['kCa'] = 0.8e-5\n    muspar['tact'] = 1/37\n    muspar['tdeact'] = 1/37\n      \n    fileName = os.path.join(dataDir,'GM_muspar.pkl')\n    pickle.dump(muspar, open(fileName, 'wb'))\n    \n    # Rat specific\n    if mus == 'GMs1':\n        muspar['lce_opt'] = 1.32e-2 # [m]\n        muspar['fmax'] = 13.39 # [N]\n        muspar['ksee'] = 4.22e6\n        muspar['kpee'] = 2.13e5\n        muspar['lsee0'] = 2.83e-2 # [m]\n        muspar['lpee0'] = 1.39e-2 # [m]\n        # muspar['eseerelmax'] = (muspar['fmax']/4.22e6)**(1/2)/muspar['lsee0']\n        # muspar['epeerelmax'] = (muspar['fmax']/2.13e5)**(1/2)/muspar['lpee0']\n        muspar['a'] = 0.20*muspar['fmax']\n        muspar['b'] = 3.15*muspar['lce_opt']\n    elif mus == 'GMs2':\n        muspar['lce_opt'] = 1.23e-2 # [m]\n        muspar['fmax'] = 13.81 # [N]\n        muspar['ksee'] = 3.64e6\n        muspar['kpee'] = 1.65e5\n        muspar['lsee0'] = 3.03e-2 # [m]\n        muspar['lpee0'] = 1.32e-2 # [m]\n        # muspar['eseerelmax'] = (muspar['fmax']/3.64e6)**(1/2)/muspar['lsee0']\n        # muspar['epeerelmax'] = (muspar['fmax']/1.65e5)**(1/2)/muspar['lpee0']\n        muspar['a'] = 0.13*muspar['fmax']\n        muspar['b'] = 2.02*muspar['lce_opt']\n    elif mus == 'GMs3':\n        muspar['lce_opt'] = 1.12e-2 # [m]\n        muspar['fmax'] = 12.28 # [N]\n        muspar['ksee'] = 3.47e6\n        muspar['kpee'] = 5.11e5\n        muspar['lsee0'] = 2.65e-2 # [m]\n        muspar['lpee0'] = 1.34e-2 # [m]\n        # muspar['eseerelmax'] = (muspar['fmax']/3.47e6)**(1/2)/muspar['lsee0']\n        # muspar['epeerelmax'] = (muspar['fmax']/5.11e5)**(1/2)/muspar['lpee0']\n        muspar['a'] = 0.21*muspar['fmax']\n        muspar['b'] = 3.73*muspar['lce_opt']\n    else:\n        print('Incorrect muscle selected!')\n    \n    filepath = os.path.join(dataDir,mus,'parameters',mus+'_OR.pkl')\n    pickle.dump(muspar, open(filepath, 'wb'))",
    "crumbs": [
      "{{< iconify fa6-regular floppy-disk >}} Data",
      "Data",
      "Simulated data"
    ]
  },
  {
    "objectID": "data/make_sim_data.html#quick-release-data",
    "href": "data/make_sim_data.html#quick-release-data",
    "title": "Simulated data",
    "section": "Quick-release data",
    "text": "Quick-release data\n\n\nCode\n#%% Load modules\nimport pickle, os, sys, glob\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom pathlib import Path\n\n# Directories\ncwd = Path.cwd()\nbaseDir = cwd.parent\ndataDir = baseDir / 'data'\nfuncDir = baseDir / 'analysis' / 'functions'\nsys.path.append(str(funcDir))\n\n# Custom functions\nimport make_data, stats\n\nplt.close('all')\n\n#%% Readout muscle parameter values\nif not 'mus' in locals():\n    mus = 'GMs1'\n\nparFile = os.path.join(dataDir,mus,'parameters',mus+'_OR.pkl')\nmuspar = pickle.load(open(parFile, 'rb'))\neseeMax = (muspar['fmax']/muspar['ksee'])**(1/2) # [mm] SEE elongation @ fmax\nlmtcOpt = eseeMax + muspar['lsee0']+muspar['lce_opt']\n\n#%% Simulate QR data - 'Experimental data'\n# Setting which are similar for each QR\noptsQR = {\n    'durIso':   [0.3, 0.2], # [s] duration of 1st and 2nd isometric phase\n    'durStep':  10e-3,      # [s] duration of step\n    'dLmtc':    -0.2e-3,     # [m] MTC length change during step \n    'tStim':    [0.1, 0.4]  # [s] stim onset and offset time\n    }\ndataDirQR = os.path.join(dataDir,mus,'dataExp','QR','')\n\n# Define over which range we will simulate QR\nlmtcRange = np.linspace(stats.floor(lmtcOpt,3)+3e-3,stats.floor(lmtcOpt,3)-6e-3,10)\n\n# First delete all files in folder\nfiles = glob.glob(dataDirQR+r'\\*')    \nfor iFile,filename in enumerate(files):\n    os.remove(filename)\n\n# Make & save data\nplt.close('all')\nfig, ax = plt.subplots(3,1)\nfor iFile,lmtc0 in enumerate(lmtcRange):\n    data = make_data.qr(lmtc0,muspar,optsQR)\n    \n    # Check\n    ax[0].plot(data[:,0],data[:,2]) # sitm\n    ax[1].plot(data[:,0],data[:,1]) # lmtc\n    ax[2].plot(data[:,0],data[:,3]) # fsee\n    \n    fileName = mus+'_QR'+'{:02d}'.format(iFile+1)+'_OR.csv'\n    pd.DataFrame(data).to_csv(dataDirQR+fileName,index=False, \n                                header=['time [s]','Lmtc [m]','STIM [ ]','Fsee [N]'])\n    print('QR: '+mus+', '+'OR'+', File: '+str(iFile+1))\n\n#%% Simulate QR data - Monte Carlo simulations\nfor iPar in range(1,51):\n    dataDirQR = os.path.join(dataDir,mus,'dataMC','QR',f'{iPar:{\"02d\"}}','')\n    \n    # Define over which range we will simulate QR, this is a different range (i.e., slightly shifted). \n    # This is what one will (or should do) in experiment too!\n    np.random.seed(iPar)\n    shifts = np.random.rand(10)*1e-3\n    \n    # First delete all files in folder\n    files = glob.glob(dataDirQR+r'\\*')    \n    for iFile,filename in enumerate(files):\n        os.remove(filename)\n    \n    # Make & save data\n    plt.close('all')\n    fig, ax = plt.subplots(3,1)\n    for iFile,lmtc0 in enumerate(lmtcRange):\n        mcpar = muspar.copy()\n        # Distrub data\n        eseeMax = lmtcOpt+shifts[iFile]-muspar['lce_opt']-muspar['lsee0'] # [mm] SEE elongation @ fmax\n        mcpar['ksee'] = mcpar['fmax']/(eseeMax)**2\n        data = make_data.qr(lmtc0,mcpar,optsQR)\n        \n        # Check\n        ax[0].plot(data[:,0],data[:,2]) # sitm\n        ax[1].plot(data[:,0],data[:,1]*1e3) # lmtc\n        ax[2].plot(data[:,0],data[:,3]) # fsee\n        \n        fileName = mus+'_QR'+'{:02d}'.format(iFile+1)+'_MC{:02d}'.format(iPar)+'.csv'\n        pd.DataFrame(data).to_csv(dataDirQR+fileName,index=False, \n                                  header=['time [s]','Lmtc [m]','STIM [ ]','Fsee [N]'])\n        print('QR: '+mus+', '+'MC{:02d}'.format(iPar)+', File: '+str(iFile+1))",
    "crumbs": [
      "{{< iconify fa6-regular floppy-disk >}} Data",
      "Data",
      "Simulated data"
    ]
  },
  {
    "objectID": "data/make_sim_data.html#step-ramp-data",
    "href": "data/make_sim_data.html#step-ramp-data",
    "title": "Simulated data",
    "section": "Step-ramp data",
    "text": "Step-ramp data\n\n\nCode\n#%% Load modules\nimport pickle, os, sys, glob\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom pathlib import Path\n\n# Directories\ncwd = Path.cwd()\nbaseDir = cwd.parent\ndataDir = baseDir / 'data'\nfuncDir = baseDir / 'analysis' / 'functions'\nsys.path.append(str(funcDir))\n\n# Custom functions\nimport make_data, hillmodel, stats\n\nplt.close('all')\n\n#%% Readout muscle parameter values\nif not 'mus' in locals():\n    mus = 'GMs1'\n\nparFile = os.path.join(dataDir,mus,'Parameters',mus+'_OR.pkl')\nmuspar = pickle.load(open(parFile, 'rb'))\neseeMax = (muspar['fmax']/muspar['ksee'])**(1/2) # [mm] SEE elongation @ fmax\nlmtcOpt = eseeMax + muspar['lsee0']+muspar['lce_opt']\nlmtc0 = lmtcOpt+0.5e-3 # [m] MTC-length at t=0\n\n#%% Simulate SR data - 'Experimental data'\nfceRange = np.array([0.85, 0.72, 0.60, 0.49, 0.38, 0.28, 0.20, 0.14, 0.09])*muspar['fmax']\n\n# Setting which are similar for each SR\noptsSR = {\n    'durIso':   0.3,        # [s] duration of 1st isometric phase\n    'durStep':  10e-3,      # [s] duration of step\n    'durRamp':  0.2,        # [m] MTC length change during step\n    'tStim':    [0.1, 0.4]  # [s] stim onset and offset time\n    }\ndataDirSR = os.path.join(dataDir,mus,'dataExp','SR','')\n\n# First delete all files in folder\nfiles = glob.glob(dataDirSR+r'\\*')    \nfor iFile,filename in enumerate(files):\n    os.remove(filename)\n\n# Make & save data\nplt.close('all')\nfig, ax = plt.subplots(3,1)\nfor iFile,fce in enumerate(fceRange):\n    vRamp = hillmodel.Fce2Vce(fce,1,1,muspar)[0]\n    esee = (fceRange[iFile]/muspar['ksee'])**0.5\n    eseeMax = (muspar['fmax']/muspar['ksee'])**0.5\n    dLmtc = np.round((esee-eseeMax)+(vRamp*1e-2)*0.5,5)\n    data = make_data.sr(lmtc0,dLmtc,vRamp,muspar,optsSR)\n    \n    # Check\n    ax[0].plot(data[:,0],data[:,2]) # sitm\n    ax[1].plot(data[:,0],data[:,1]) # lmtc\n    ax[2].plot(data[:,0],data[:,3]) # fsee\n    fileName = mus+'_SR'+'{:02d}'.format(iFile+1)+'_OR.csv'\n    pd.DataFrame(data).to_csv(dataDirSR+fileName,index=False, \n                              header=['time [s]','Lmtc [m]','STIM [ ]','Fsee [N]'])\n    print('SR: '+mus+', '+'OR'+', File: '+str(iFile+1))\n\n#%% Simulate SR data - Monte Carlo simulations\nfor iPar in range(1,51):\n    dataDirSR = os.path.join(dataDir,mus,'dataMC',f'{iPar:{\"02d\"}}','SR','')\n    \n    # Define MTC shifts, we will not choose a different LMTC length at the start, \n    # because it's unrealistic that one will change this for every SR in an experiment\n    np.random.seed(iPar)\n    shifts = np.random.rand(9)*1e-3\n    \n    # First delete all files in folder\n    files = glob.glob(dataDirSR+r'\\*')    \n    for iFile,filename in enumerate(files):\n        os.remove(filename)\n    \n    # Make & save data\n    plt.close('all')\n    fig, ax = plt.subplots(3,1)\n    for iFile,fce in enumerate(fceRange):\n        mcpar = muspar.copy()\n        # Distrub data\n        eseeMax = lmtcOpt+shifts[iFile]-muspar['lce_opt']-muspar['lsee0'] # [mm] SEE elongation @ fmax\n        mcpar['ksee'] = mcpar['fmax']/(eseeMax)**2\n    \n        vRamp = hillmodel.Fce2Vce(fceRange[iFile],1,1,mcpar)[0]\n        esee = (fceRange[iFile]/mcpar['ksee'])**0.5\n        eseeMax = (mcpar['fmax']/mcpar['ksee'])**0.5\n        dLmtc = np.round((esee-eseeMax)+(vRamp*1e-2)*0.5,5)\n        data = make_data.sr(lmtc0,dLmtc,vRamp,mcpar,optsSR)\n        \n        # Check\n        ax[0].plot(data[:,0],data[:,2]) # sitm\n        ax[1].plot(data[:,0],data[:,1]*1e3) # lmtc\n        ax[2].plot(data[:,0],data[:,3]) # fsee\n        \n        fileName = mus+'_SR'+'{:02d}'.format(iFile+1)+'_MC{:02d}'.format(iPar)+'.csv'\n        pd.DataFrame(data).to_csv(dataDirSR+fileName,index=False, \n                                  header=['time [s]','Lmtc [m]','STIM [ ]','Fsee [N]'])\n        print('SR: '+mus+', '+'MC{:02d}'.format(iPar)+', File: '+str(iFile+1))",
    "crumbs": [
      "{{< iconify fa6-regular floppy-disk >}} Data",
      "Data",
      "Simulated data"
    ]
  },
  {
    "objectID": "data/make_sim_data.html#isometric-data",
    "href": "data/make_sim_data.html#isometric-data",
    "title": "Simulated data",
    "section": "Isometric data",
    "text": "Isometric data\n\n\nCode\n#%% Load modules\nimport pickle, os, sys, glob\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom pathlib import Path\n\n# Directories\ncwd = Path.cwd()\nbaseDir = cwd.parent\ndataDir = baseDir / 'data'\nfuncDir = baseDir / 'analysis' / 'functions'\nsys.path.append(str(funcDir))\n\n# Custom functions\nimport make_data, stats\n\nplt.close('all')\n\n#%% Readout muscle parameter values\nif not 'mus' in locals():\n    mus = 'GMs3'\n\nparFile = os.path.join(dataDir,mus,'Parameters',mus+'_OR.pkl')\nmuspar = pickle.load(open(parFile, 'rb'))\neseeMax = (muspar['fmax']/muspar['ksee'])**(1/2) # [mm] SEE elongation @ fmax\nlmtcOpt = eseeMax + muspar['lsee0']+muspar['lce_opt']\n\n#%% Generate ACT data\nif mus == 'GMs1':\n    lmtcRange = np.array([43,41,39,37, 43,41,39,37, 43,41,39,37])*1e-3 # [m] isometric MTC length\nelif mus == 'GMs2':\n    lmtcRange = np.array([44,42,40,38, 44,42,40,38, 44,42,40,38])*1e-3 # [m] isometric MTC length\nelif mus == 'GMs3':\n    lmtcRange = np.array([39,37,35,33, 39,37,35,33, 39,37,35,33])*1e-3 # [m] isometric MTC length\n# durStimRange = np.array([5,5,5, 10,10,10, 15,15,15])*1e-3 # [s] stimulation duration\ndurStimRange = np.array([35,35,35,35 , 65,65,65, 65, 95,95,95,95])*1e-3 # [s] stimulation duration\n\n#%% Simulate ISOM data - 'Experimental data'\ndataDirISOM = os.path.join(dataDir,mus,'dataExp','ISOM','')\n\n# First delete all files in folder\nfiles = glob.glob(dataDirISOM+r'\\*')    \nfor iFile,filename in enumerate(files):\n    os.remove(filename)\n\n# Make & save data\nplt.close('all')\nfig, ax = plt.subplots(3,4)\nfor iFile,(lmtc0,durStim) in enumerate(zip(lmtcRange,durStimRange)):\n    data = make_data.isom(lmtc0,durStim,muspar)\n    \n    # Check\n    iT = np.mod(iFile,4)\n    ax[0,iT].plot(data[:,0],data[:,2]) # sitm\n    ax[1,iT].plot(data[:,0],data[:,1]) # lmtc\n    ax[2,iT].plot(data[:,0],data[:,3]) # fsee\n    \n    fileName = mus+'_ISOM'+'{:02d}'.format(iFile+1)+'_OR.csv'\n    pd.DataFrame(data).to_csv(dataDirISOM+fileName,index=False, \n                                header=['time [s]','Lmtc [m]','STIM [ ]','Fsee [N]'])\n    print('ISOM: '+mus+', '+'OR'+', File: '+str(iFile+1))\n\n#%% Simulate ISOM data - Monte Carlo simulations\nfor iPar in range(1,51):\n    dataDirISOM = os.path.join(dataDir,mus,'dataMC',f'{iPar:{\"02d\"}}','ISOM','')\n    \n    # Define MTC shifts, we will not choose a different LMTC length at the start, \n    # because it's unrealistic that one will change this for every SR in an experiment\n    np.random.seed(iPar)\n    shifts = np.random.rand(12)*1e-3\n    \n    # First delete all files in folder\n    files = glob.glob(dataDirISOM+r'\\*')    \n    for iFile,filename in enumerate(files):\n        os.remove(filename)\n    \n    # Make & save data\n    plt.close('all')\n    fig, ax = plt.subplots(3,4)\n    for iFile,(lmtc0,durStim) in enumerate(zip(lmtcRange,durStimRange)):\n        mcpar = muspar.copy()\n        # Distrub data\n        eseeMax = lmtcOpt+shifts[iFile]-muspar['lce_opt']-muspar['lsee0'] # [mm] SEE elongation @ fmax\n        mcpar['ksee'] = mcpar['fmax']/(eseeMax)**2\n        data = make_data.isom(lmtc0,durStim,mcpar)\n        \n        # Check\n        iT = np.mod(iFile,4)\n        ax[0,iT].plot(data[:,0],data[:,2]) # sitm\n        ax[1,iT].plot(data[:,0],data[:,1]) # lmtc\n        ax[2,iT].plot(data[:,0],data[:,3]) # fsee\n        \n        fileName = mus+'_ISOM'+'{:02d}'.format(iFile+1)+'_MC{:02d}'.format(iPar)+'.csv'\n        pd.DataFrame(data).to_csv(dataDirISOM+fileName,index=False, \n                                  header=['time [s]','Lmtc [m]','STIM [ ]','Fsee [N]'])\n        print('ISOM: '+mus+', '+'MC{:02d}'.format(iPar)+', File: '+str(iFile+1))",
    "crumbs": [
      "{{< iconify fa6-regular floppy-disk >}} Data",
      "Data",
      "Simulated data"
    ]
  },
  {
    "objectID": "analysis/sens-analysis.html",
    "href": "analysis/sens-analysis.html",
    "title": "Sensitivity analysis",
    "section": "",
    "text": "The analysis of this page corresponds to the section with the same title (i.e., â€˜Sensitivity analysisâ€™). There are two sensivitiy analysis performed:",
    "crumbs": [
      "{{< iconify fa6-solid magnifying-glass-chart >}} Analysis",
      "Analysis",
      "Sensitivity analysis"
    ]
  },
  {
    "objectID": "analysis/sens-analysis.html#monte-carlo-simulations",
    "href": "analysis/sens-analysis.html#monte-carlo-simulations",
    "title": "Sensitivity analysis",
    "section": "Monte Carlo simulations",
    "text": "Monte Carlo simulations\nThree steps are taken for the Monte Carlo simulation:\n\nStep 1A: Estimate muscle property values.\nStep 1B: Simulate protocols to predict SEE force over time.\nStep 1C: Compute variables for manuscript.\n\n\nStep 1A: Estimate muscle property values\n\n\n# %% Load packages\nimport os, pickle \nfrom pathlib import Path\n\n# Set directories\ncwd = Path.cwd()\nbaseDir = cwd.parent\ndataDir = baseDir / 'data'\n\n# Load custom functions\nfrom functions.mp_estimator import loaddata, estimate\n\n# %% Muscle & folders\nfor mus in ['GMs1', 'GMs2', 'GMs3']: \n    dataDirMus = os.path.join(dataDir,mus,'dataExp','')\n    parFile = os.path.join(dataDir,mus,'parameters',mus)\n    \n    # %% Settings and load data\n    optsQR = {\n        'dataDir':          dataDirMus+'QR',\n        'iCols':            (0,1,3),\n        'idxQRmin':         'auto',\n        'idxQRpre':         'auto',\n        'idxQRpst':         'auto',\n        'nQRsamp':          'auto',\n        'dispFig':          False,\n        }\n    optsSR = {\n        'dataDir':          dataDirMus+'SR',\n        'iCols':            (0,1,3),\n        'idxSRcon':         'auto',\n        'nSRsamp':          'auto',\n        'dispFig':          False,\n        }\n    optsISOM = {\n        'dataDir':          dataDirMus+'SR',\n        'iCols':            (0,1,3,2),\n        'durStimOffset':    0.1,\n        'dispFig':          False,\n        }\n    dataQR,idxQRmin,idxQRpre,idxQRpst = loaddata.qr(optsQR)\n    dataSR,idxSRcon = loaddata.sr(optsSR)\n    dataISOM, idxSEL = loaddata.isom(optsISOM)\n    \n    # %% Traditional method\n    muspar = loaddata.get_muspar()\n    estpar,dataQRout = estimate.fl(dataQR,muspar)\n    estpar,dataSRout = estimate.fv(dataSR,muspar,estpar)\n    estpar,dataACTout = estimate.act(dataISOM,muspar,estpar,do_print=True)   \n    pickle.dump([{**muspar,**estpar}, dataQRout, dataSRout, dataACTout], open(parFile+'_TM_SR.pkl', 'wb'))\n    \n    # %% Improved method\n    muspar = loaddata.get_muspar()\n    estparr,dataQRout,dataSRout = estimate.im(dataQR,dataSR,muspar,do_print=True)\n    estparr,dataACTout = estimate.act(dataISOM,muspar,estparr,do_print=True)\n    pickle.dump([{**muspar,**estparr}, dataQRout, dataSRout, dataACTout], open(parFile+'_IM.pkl', 'wb'))\n\n\n\n\nStep 1B: Simulate protocols to predict SEE force over time\n\n# %% Load packages & set directories\nimport pickle, os, glob\nfrom pathlib import Path\nfrom functions.helpers import simulate_file\n\n# Set directories\ncwd = Path.cwd()\nbaseDir = cwd.parent\ndataDir = baseDir / 'data'\n\n# %% Simulate to predict SEE force based on experimental data\nmuscles = ['GMs1', 'GMs2', 'GMs3']\n\nfor mus in muscles:\n    for exp in ['QR','SR','ISOM']:\n        for iMC in range(1,51):\n            parFile = os.path.join(dataDir,mus,'parameters','mc',f'{mus}_MC{iMC:02d}'+'.pkl')\n            muspar = pickle.load(open(parFile, 'rb'))[0]\n            \n            dataDirExp = os.path.join(dataDir,mus,'dataMC',exp,f'{iMC:02d}','')\n            dataDirSim = os.path.join(dataDir,mus,'simsMC',exp,f'{iMC:02d}','')\n\n            # Clean old files\n            for f in glob.glob(os.path.join(dataDirSim, '*')):\n                os.remove(f)\n            \n            # Process each file\n            for filepath in glob.glob(os.path.join(dataDirExp, '*')):\n                df_sim, df_exp = simulate_file(filepath, muspar)\n                fname = os.path.basename(filepath)[:-4]\n                outName = f\"{fname}.csv\"\n                df_sim.to_csv(os.path.join(dataDirSim, outName), index=False)\n                print(f\"Saved: {outName}\")\n\n\n\nStep 1C: Compute variables for manuscript\n\n# %% Load packages\nimport os, pickle, sys\nimport pandas as pd\nfrom pathlib import Path\n\n# Set directories\ncwd = Path.cwd()\nbaseDir = cwd.parent\ndataDir = baseDir / 'data'\nfuncDir = baseDir / 'analysis' / 'functions'\nsys.path.append(str(funcDir))\n\n# Custom functions\nimport stats\n\n# %% 3.2.1: Monte Carlo simulations\nmuscles = ['GMs1', 'GMs2', 'GMs3']\n# Parameters to track\nparams = ['a', 'b', 'fmax', 'kpee', 'ksee', 'lce_opt', 'lpee0', 'lsee0', 'tact', 'tdeact']\n\n# Store Monte-Carlo results\nresults = []\nfor mus in muscles:\n    par_file = os.path.join(dataDir, mus, 'parameters', f'{mus}_OR.pkl')\n    or_par = pickle.load(open(par_file, 'rb'))\n    eseeMaxOR = (or_par['fmax']/or_par['ksee'])**0.5\n        \n    \n    for iMC in range(1, 51):\n        mc_file = os.path.join(dataDir, mus, 'parameters','mc', f'{mus}_MC{iMC:02d}.pkl')\n        mc_par = pickle.load(open(mc_file, 'rb'))[0]\n        eseeMaxMC = (mc_par['fmax']/mc_par['ksee'])**0.5\n        \n        entry = {'muscle': mus, 'MC': iMC, 'd_esee': (eseeMaxMC-eseeMaxOR)}\n        for param in params:\n            entry[param] = stats.pdiff(mc_par[param], or_par[param])\n        \n        results.append(entry)\n\n# Convert to pandas DataFrame\ndf = pd.DataFrame(results)\n\n# Compute summary statistics\ndf_mean = df.groupby('muscle').mean().T\ndf_std = df.groupby('muscle').std().T\n\n# Extract all contraction dynamics parameters except ksee\np_MC_con_avg = df_mean.loc[['a','b', 'kpee', 'fmax', 'lce_opt', 'lpee0', 'lsee0']]\np_MC_con_std = df_std.loc[['a', 'b', 'fmax', 'kpee', 'lce_opt', 'lpee0', 'lsee0']]\n\n# Percentage difference over all muscles: from real to estimated ksee\np_MC_ksee_avg = f'{df_mean.loc['ksee'].mean():0.0f}'  # [%] percentage difference\n# Absolute difference over all muscles of SEE elongation @ Fcemax\nd_MC_esee_avg = f'{df_mean.loc['d_esee'].mean()*1e3:0.1f}'  # [mm]\n# Max. avg. percentage difference over all muscles: from real to estimated value of contraction dyn. parms\np_MC_con_maxavg = f'{p_MC_con_avg.abs().max().max():0.1f}' \n# Max. std. percentage difference over all muscles: from real to estimated value of contraction dyn. parms\np_MC_con_maxstd = f'{p_MC_con_std.abs().max().max():0.0f}' \n# Max. std percentage difference over all muscles: from real to estimated value of kpee\np_MC_kpee_maxstd = f'{df_std.loc['kpee'].max():0.0f}'\n# Max. avg percentage difference over all muscles: from real to estimated value of tact\np_MC_tact_maxavg = f'{df_mean.loc['tact'].max():0.1f}'\n# Avg. std percentage difference over all muscles: from real to estimated value of tact\np_MC_tact_avgstd = f'{df_std.loc['tact'].mean():0.0f}'",
    "crumbs": [
      "{{< iconify fa6-solid magnifying-glass-chart >}} Analysis",
      "Analysis",
      "Sensitivity analysis"
    ]
  },
  {
    "objectID": "analysis/sens-analysis.html#interdependency-of-parameter-values",
    "href": "analysis/sens-analysis.html#interdependency-of-parameter-values",
    "title": "Sensitivity analysis",
    "section": "Interdependency of parameter values",
    "text": "Interdependency of parameter values\n\n# %% Load packages\nimport os, pickle\n\n# Set directories\ncwd = os.path.dirname(os.path.abspath(__file__))\nbaseDir = os.path.join(cwd,'..')\ndataDir = os.path.join(baseDir,'data')\n\n# Load custom functions\nfrom functions.mp_estimator import loaddata, estimate_id\n\n#%% Muscle & folders\nfor iMus, mus in enumerate(['GMs1','GMs2','GMs3']): \n    dataDirMus = os.path.join(dataDir,mus,'dataExp','')\n    parDir = os.path.join(dataDir,mus,'parameters','')\n    \n    #%% Settings and load data\n    optsQR = {\n        'dataDir':          dataDirMus+'QR',\n        'iCols':            (0,1,3),\n        'idxQRmin':         'auto',\n        'idxQRpre':         'auto',\n        'idxQRpst':         'auto',\n        'nQRsamp':          'auto',\n        'dispFig':          False,\n        }\n    optsSR = {\n        'dataDir':          dataDirMus+'SR',\n        'iCols':            (0,1,3),\n        'idxSRcon':         'auto',\n        'nSRsamp':          'auto',\n        'dispFig':          False,\n        }\n    optsISOM = {\n        'dataDir':          dataDirMus+'ISOM',\n        'iCols':            (0,1,3,2),\n        'durStimOffset':    0.1,\n        'dispFig':          False,\n        }\n    dataQR,idxQRmin,idxQRpre,idxQRpst = loaddata.qr(optsQR)\n    dataSR,idxSRcon = loaddata.sr(optsSR)\n    dataISOM, idxSEL = loaddata.isom(optsISOM)\n    \n    #%% Perform sensitivity analyis\n    #for sPar in ['a', 'b', 'fmax', 'ksee', 'lce_opt', 'lsee0']:\n    for sPar in ['ksee', 'lce_opt', 'lsee0']:\n        for idx,fChange in enumerate([0.95, 1.05]):\n            muspar = pickle.load(open(parDir+mus+'_IM.pkl', 'rb'))[0]\n            print(muspar[sPar])\n            muspar[sPar] = muspar[sPar]*fChange\n            print(muspar[sPar])\n            \n            estpar,dataQRout,dataSRout = estimate_id.im(dataQR,dataSR,muspar,{sPar: muspar[sPar]},do_print=True)  \n            estpar,dataACTout = estimate_id.act(dataISOM,muspar,estpar,do_print=True)\n            filepath = os.path.join(parDir,'interdep',mus+'_'+sPar+f'_{fChange*100:03.0f}.pkl')\n            pickle.dump([{**muspar,**estpar}, dataQRout, dataSRout, dataACTout], open(filepath, 'wb'))\n            print(estpar[sPar])",
    "crumbs": [
      "{{< iconify fa6-solid magnifying-glass-chart >}} Analysis",
      "Analysis",
      "Sensitivity analysis"
    ]
  },
  {
    "objectID": "analysis/model-pred.html",
    "href": "analysis/model-pred.html",
    "title": "Evaluating model predictions - in situ data",
    "section": "",
    "text": "The analysis of this page corresponds to the section with the same title (i.e., â€˜Evaluating model predictions - in situ dataâ€™).\nThere are three steps:",
    "crumbs": [
      "{{< iconify fa6-solid magnifying-glass-chart >}} Analysis",
      "Analysis",
      "Model prediction"
    ]
  },
  {
    "objectID": "analysis/model-pred.html#step-1-estimate-muscle-property-values",
    "href": "analysis/model-pred.html#step-1-estimate-muscle-property-values",
    "title": "Evaluating model predictions - in situ data",
    "section": "Step 1: Estimate muscle property values",
    "text": "Step 1: Estimate muscle property values\n\n# %% Load packages\nimport os, pickle\nfrom pathlib import Path\n\n# Set directories\ncwd = Path.cwd()\nbaseDir = cwd.parent\ndataDir = baseDir / 'data'\n\n# Load custom functions\nfrom functions.mp_estimator import loaddata, estimate\n\n#%% Muscle & folders\nfor mus in ['GMe1', 'GMe2', 'GMe3']: \n    dataDirMus = os.path.join(dataDir,mus,'dataExp','')\n    parFile = os.path.join(dataDir,mus,'parameters',mus)\n    \n    #%% Settings and load data\n    optsQR = {\n        'dataDir':          dataDirMus+'QR',\n        'iCols':            (0,1,3),\n        'idxQRmin':         'auto',\n        'idxQRpre':         'auto',\n        'idxQRpst':         'auto',\n        'nQRsamp':          'auto',\n        'dispFig':          False,\n        }\n    optsSR = {\n        'dataDir':          dataDirMus+'SR',\n        'iCols':            (0,1,3),\n        'idxSRcon':         'auto',\n        'nSRsamp':          'auto',\n        'dispFig':          False,\n        }\n    optsISOM = {\n        'dataDir':          dataDirMus+'SR',\n        'iCols':            (0,1,3,2),\n        'durStimOffset':    0.1,\n        'dispFig':          False,\n        }\n    dataQR,idxQRmin,idxQRpre,idxQRpst = loaddata.qr(optsQR)\n    dataSR,idxSRcon = loaddata.sr(optsSR)\n    dataISOM, idxSEL = loaddata.isom(optsISOM)\n    \n    #%% Traditional method\n    muspar = loaddata.get_muspar()\n    estpar,dataQRout = estimate.fl(dataQR,muspar)\n    estpar,dataSRout = estimate.fv(dataSR,muspar,estpar)\n    estpar,dataACTout = estimate.act(dataISOM,muspar,estpar,do_print=True)   \n    pickle.dump([{**muspar,**estpar}, dataQRout, dataSRout, dataACTout], open(parFile+'_TM_SR.pkl', 'wb'))\n    \n    #%% Improved method\n    muspar = loaddata.get_muspar()\n    estparr,dataQRout,dataSRout = estimate.im(dataQR,dataSR,muspar,do_print=True)\n    estparr,dataACTout = estimate.act(dataISOM,muspar,estparr,do_print=True)\n    pickle.dump([{**muspar,**estparr}, dataQRout, dataSRout, dataACTout], open(parFile+'_IM.pkl', 'wb'))",
    "crumbs": [
      "{{< iconify fa6-solid magnifying-glass-chart >}} Analysis",
      "Analysis",
      "Model prediction"
    ]
  },
  {
    "objectID": "analysis/model-pred.html#step-2-simulate-protocols-to-predict-see-over-time",
    "href": "analysis/model-pred.html#step-2-simulate-protocols-to-predict-see-over-time",
    "title": "Evaluating model predictions - in situ data",
    "section": "Step 2: Simulate protocols to predict SEE over time",
    "text": "Step 2: Simulate protocols to predict SEE over time\n\n# %% Load packages & set directories\nimport pickle, os, glob\nfrom functions.helpers import simulate_file\n\n# Set directories\ncwd = os.path.dirname(os.path.abspath(__file__))\nbaseDir = os.path.join(cwd,'..')\ndataDir = os.path.join(baseDir,'data')\n\n# %% Simulate to predict SEE force based on experimental data\nfor mus in ['GMe1', 'GMe2', 'GMe3']:\n    for vPar in ['TM', 'IM']:\n        # Load parameters\n        parFile = os.path.join(dataDir, mus, 'parameters', f'{mus}_{vPar}.pkl')\n        muspar = pickle.load(open(parFile, 'rb'))[0]\n        for exp in ['QR','SR','ISOM', 'SSC']:\n            dataDirExp = os.path.join(dataDir, mus, 'dataExp', exp)\n            dataDirSim = os.path.join(dataDir, mus, 'simsExp', vPar, exp, '')\n\n            # Clean old files\n            for f in glob.glob(os.path.join(dataDirSim, '*')):\n                os.remove(f)\n            \n            # Process each file\n            for filepath in glob.glob(os.path.join(dataDirExp, '*')):\n                df_sim, df_exp = simulate_file(filepath, muspar)\n                fname = os.path.basename(filepath)[:-6]\n                outName = f\"{fname}{vPar}.csv\"\n                df_sim.to_csv(os.path.join(dataDirSim, outName), index=False)\n                print(f\"Saved: {outName}\")",
    "crumbs": [
      "{{< iconify fa6-solid magnifying-glass-chart >}} Analysis",
      "Analysis",
      "Model prediction"
    ]
  },
  {
    "objectID": "analysis/model-pred.html#step-3-compute-variables-for-manuscript",
    "href": "analysis/model-pred.html#step-3-compute-variables-for-manuscript",
    "title": "Evaluating model predictions - in situ data",
    "section": "Step 3: Compute variables for manuscript",
    "text": "Step 3: Compute variables for manuscript\n\n# %% Load packages\nimport os, pickle, sys, glob\nimport numpy as np\nimport pandas as pd\nfrom pathlib import Path\n\n# Directories\ncwd = Path.cwd()\nbaseDir = cwd.parent\ndataDir = baseDir / 'data'\nfuncDir = baseDir / 'analysis' / 'functions'\nsys.path.append(str(funcDir))\n\n# Custom functions\nimport helpers, stats\n\n# %% Extract parameters\nmuscles = ['GMe1', 'GMe2', 'GMe3']\nparam_keys = ['a', 'b', 'kpee', 'ksee', 'fmax', 'lce_opt', 'lpee0', 'lsee0', 'tact', 'tdeact']\n\norParms, tmParms, imParms = [], [], []\nfor mus in muscles:   \n    tmPar, dataQRtm = pickle.load(open(os.path.join(dataDir,mus,'parameters',mus+'_TM.pkl'), 'rb'))[0:2]\n    imPar, dataQRim = pickle.load(open(os.path.join(dataDir,mus,'parameters',mus+'_IM.pkl'), 'rb'))[0:2]\n    \n    parms = [tmPar[k] for k in param_keys]\n    tmParms.append(parms)\n    \n    parms = [imPar[k] for k in param_keys]\n    imParms.append(parms)\n    \n# Store in pandas dataframe\ndf_tm = pd.DataFrame(list(zip(*tmParms)), columns=['GM1', 'GM2', 'GM3'], index=param_keys) # df with estimated parameter values using the traditional method\ndf_im = pd.DataFrame(list(zip(*imParms)), columns=['GM1', 'GM2', 'GM3'], index=param_keys) # df with estimated parameter values using the improved method\n\n# %% Compute percentage differences from real/actual and estimated parameter values\n# Positive: Imporoved is that % higher than Traditional\n# Negative: Imporoved is that % lower than Traditional\ndf_p = stats.pdiff(df_im, df_tm)\n\n# %% Compute RMSDs\npar_models = ['TM', 'IM']\nexperiments = ['QR', 'SR', 'ISOM', 'SSC']\nmuscles = ['GMe1', 'GMe2', 'GMe3']\n\navg_mean_all = []\ncolumns = [f'{model}_{exp}' for model in par_models for exp in experiments]\nrows = muscles + ['Avg Â± Std']\ndf = pd.DataFrame(index=rows, columns=columns, dtype=str)\nfor exp in experiments:\n    for model in par_models:\n        all_rmsd = []\n        for mus in muscles:\n            # Load parameter\n            parFile = os.path.join(dataDir, mus, 'parameters', f'{mus}_{model}.pkl')\n            muspar = pickle.load(open(parFile, 'rb'))[0]\n\n            dataDirExp = os.path.join(dataDir, mus, 'dataExp', exp)\n            rrunDirExp = os.path.join(dataDir, mus, 'simsExp', model, exp)\n\n            dataFiles = sorted(glob.glob(os.path.join(dataDirExp, '*')))\n            rrunFiles = sorted(glob.glob(os.path.join(rrunDirExp, '*')))\n\n            rms_list = []\n            for dataFile, rrunFile in zip(dataFiles, rrunFiles):\n                dataFilename = os.path.basename(dataFile)[:-4]\n                rrunFilename = os.path.basename(rrunFile)[:-4]\n                if dataFilename[:-3] != rrunFilename[:-3]:\n                    raise ValueError(f\"File mismatch: {dataFilename} vs {rrunFilename}\")\n\n                dataData = pd.read_csv(dataFile).T.to_numpy()[0:4]\n                rrunData = pd.read_csv(rrunFile).T.to_numpy()\n\n                time1, _, stim1, fsee1 = dataData\n                time2, _, _, fsee2 = rrunData\n\n                tStimOn, tStimOff = helpers.get_stim(time1, stim1)[1:]\n                iStart = int(np.argmin(abs(time1 - tStimOn[0])))\n\n                if exp == 'ISOM':\n                    iStop = int(np.argmin(abs(time1 - 0.1 - tStimOff[0])))\n                elif exp in ['QR', 'SR']:\n                    iStop = int(np.argmin(abs(time1 - tStimOff[0])))\n                else:  # SSC\n                    iStop = int(np.argmin(abs(time1 - tStimOff[-1])))\n\n                rms = stats.rmse(fsee1[iStart:iStop], fsee2[iStart:iStop]) / muspar['fmax'] * 100\n                rms_list.append(rms)\n\n            M = np.mean(rms_list)\n            S = np.std(rms_list)\n\n            df.loc[mus, f'{model}_{exp}'] = f'{M:.1f} Â± {S:.1f}'\n            all_rmsd += rms_list  # just mean, for averaging across muscles\n\n        # Average over muscles for this (exp, model)\n        avg_M = np.mean(all_rmsd)\n        avg_S = np.std(all_rmsd)\n        df.loc['Avg Â± Std', f'{model}_{exp}'] = f'{avg_M:.1f} Â± {avg_S:.1f}'\n        avg_mean_all.append(avg_M)\navg_mean_all = np.array(avg_mean_all)\n\n#%% 3.3: Evaluating model predictions\n# Avg. difference: from traditional to improved method: SEE stiffness\np_IS_ksee_avg = f'{df_p.loc['ksee'].mean():0.0f}' #  [%] avg. percentage difference\n# Avg. difference: from traditional to improved method: tact\np_IS_tact_avg = f'{df_p.loc['tact'].mean():0.0f}' #  [%] avg. percentage difference\n# Avg. difference: from traditional to improved method: tdeact\np_IS_tdeact_avg = f'{df_p.loc['tdeact'].mean():0.0f}' #  [%] avg. percentage difference\n# Avg. difference: from traditional to improved method: lce_opt\np_IS_lceopt_avg = f'{df_p.loc['lce_opt'].mean():0.0f}' #  [%] avg. percentage difference\n# Take the mean over all each sort of experiment\np_IS_rmsd = f'{stats.pdiff(avg_mean_all[1::2],avg_mean_all[0::2]).mean():2.0f}'",
    "crumbs": [
      "{{< iconify fa6-solid magnifying-glass-chart >}} Analysis",
      "Analysis",
      "Model prediction"
    ]
  },
  {
    "objectID": "analysis/param-acc.html",
    "href": "analysis/param-acc.html",
    "title": "Evaluating parameter value estimation accuracy - simulated data",
    "section": "",
    "text": "The analysis of this page corresponds to the section with the same title (i.e., â€˜Evaluating parameter value estimation accuracy - simulated dataâ€™).\nThere are three steps:",
    "crumbs": [
      "{{< iconify fa6-solid magnifying-glass-chart >}} Analysis",
      "Analysis",
      "Parameter accuracy"
    ]
  },
  {
    "objectID": "analysis/param-acc.html#step-1-estimate-muscle-property-values",
    "href": "analysis/param-acc.html#step-1-estimate-muscle-property-values",
    "title": "Evaluating parameter value estimation accuracy - simulated data",
    "section": "Step 1: Estimate muscle property values",
    "text": "Step 1: Estimate muscle property values\n\n# %% Load packages\nimport os, pickle\nfrom pathlib import Path\n\n# Set directories\ncwd = Path.cwd()\nbaseDir = cwd.parent\ndataDir = baseDir / 'data'\n\n# Load custom functions\nfrom functions.mp_estimator import loaddata, estimate\n\n#%% Muscle & folders\nfor mus in ['GMs1', 'GMs2', 'GMs3']: \n    dataDirMus = os.path.join(dataDir,mus,'dataExp','')\n    parFile = os.path.join(dataDir,mus,'parameters',mus)\n    \n    #%% Settings and load data\n    optsQR = {\n        'dataDir':          dataDirMus+'QR',\n        'iCols':            (0,1,3),\n        'idxQRmin':         'auto',\n        'idxQRpre':         'auto',\n        'idxQRpst':         'auto',\n        'nQRsamp':          'auto',\n        'dispFig':          False,\n        }\n    optsSR = {\n        'dataDir':          dataDirMus+'SR',\n        'iCols':            (0,1,3),\n        'idxSRcon':         'auto',\n        'nSRsamp':          'auto',\n        'dispFig':          False,\n        }\n    optsISOM = {\n        'dataDir':          dataDirMus+'SR',\n        'iCols':            (0,1,3,2),\n        'durStimOffset':    0.1,\n        'dispFig':          False,\n        }\n    dataQR,idxQRmin,idxQRpre,idxQRpst = loaddata.qr(optsQR)\n    dataSR,idxSRcon = loaddata.sr(optsSR)\n    dataISOM, idxSEL = loaddata.isom(optsISOM)\n    \n    #%% Traditional method\n    muspar = loaddata.get_muspar()\n    estpar,dataQRout = estimate.fl(dataQR,muspar)\n    estpar,dataSRout = estimate.fv(dataSR,muspar,estpar)\n    estpar,dataACTout = estimate.act(dataISOM,muspar,estpar,do_print=True)   \n    pickle.dump([{**muspar,**estpar}, dataQRout, dataSRout, dataACTout], open(parFile+'_TM_SR.pkl', 'wb'))\n    \n    #%% Improved method\n    muspar = loaddata.get_muspar()\n    estparr,dataQRout,dataSRout = estimate.im(dataQR,dataSR,muspar,do_print=True)\n    estparr,dataACTout = estimate.act(dataISOM,muspar,estparr,do_print=True)\n    pickle.dump([{**muspar,**estparr}, dataQRout, dataSRout, dataACTout], open(parFile+'_IM.pkl', 'wb'))",
    "crumbs": [
      "{{< iconify fa6-solid magnifying-glass-chart >}} Analysis",
      "Analysis",
      "Parameter accuracy"
    ]
  },
  {
    "objectID": "analysis/param-acc.html#step-2-simulate-protocols-to-predict-see-force-over-time",
    "href": "analysis/param-acc.html#step-2-simulate-protocols-to-predict-see-force-over-time",
    "title": "Evaluating parameter value estimation accuracy - simulated data",
    "section": "Step 2: Simulate protocols to predict SEE force over time",
    "text": "Step 2: Simulate protocols to predict SEE force over time\n\n# %% Load packages & set directories\nimport pickle, os, glob\nfrom pathlib import Path\nfrom functions.helpers import simulate_file\n\n# Set directories\ncwd = Path.cwd()\nbaseDir = cwd.parent\ndataDir = baseDir / 'data'\n\n# %% Simulate to predict SEE force based on experimental data\nmuscles = ['GMs1', 'GMs2', 'GMs3']\n\nfor mus in muscles:\n    for vPar in ['TM', 'IM']:\n        # Load parameters\n        parFile = os.path.join(dataDir, mus, 'parameters', f'{mus}_{vPar}.pkl')\n        muspar = pickle.load(open(parFile, 'rb'))[0]\n        for exp in ['QR','SR','ISOM']:\n            dataDirExp = os.path.join(dataDir, mus, 'dataExp', exp)\n            dataDirSim = os.path.join(dataDir, mus, 'simsExp', vPar, exp, '')\n\n            # Clean old files\n            # for f in glob.glob(os.path.join(dataDirSim, '*')):\n            #     os.remove(f)\n            \n            # Process each file\n            for filepath in glob.glob(os.path.join(dataDirExp, '*')):\n                df = simulate_file(filepath, muspar)\n                fname = os.path.basename(filepath)[:-6]\n                outName = f\"{fname}{vPar}.csv\"\n                # df.to_csv(os.path.join(dataDirSim, outName), index=False)\n                print(f\"Saved: {outName}\")",
    "crumbs": [
      "{{< iconify fa6-solid magnifying-glass-chart >}} Analysis",
      "Analysis",
      "Parameter accuracy"
    ]
  },
  {
    "objectID": "analysis/param-acc.html#step-3-compute-variables-for-manuscript",
    "href": "analysis/param-acc.html#step-3-compute-variables-for-manuscript",
    "title": "Evaluating parameter value estimation accuracy - simulated data",
    "section": "Step 3: Compute variables for manuscript",
    "text": "Step 3: Compute variables for manuscript\n\n# %% Load packages\nimport os, pickle, sys\nimport numpy as np\nimport pandas as pd\nfrom pathlib import Path\n\n# Directories\ncwd = Path.cwd()\nbaseDir = cwd.parent\ndataDir = baseDir / 'data'\nfuncDir = baseDir / 'analysis' / 'functions'\nsys.path.append(str(funcDir))\n\n# Custom functions\nimport hillmodel, stats\n\n# %% Extract parameters\nmuscles = ['GMs1','GMs2','GMs3']\nparam_keys = ['a', 'b', 'kpee', 'ksee', 'fmax', 'lce_opt', 'lpee0', 'lsee0', 'tact', 'tdeact']\n\norParms, tmParms, imParms = [], [], []\nfor mus in muscles:   \n    orPar = pickle.load(open(os.path.join(dataDir,mus,'parameters',mus+'_OR.pkl'), 'rb'))\n    tmPar = pickle.load(open(os.path.join(dataDir,mus,'parameters',mus+'_TM.pkl'), 'rb'))[0]\n    imPar = pickle.load(open(os.path.join(dataDir,mus,'parameters',mus+'_IM.pkl'), 'rb'))[0]\n\n    parms = [orPar[k] for k in param_keys]\n    orParms.append(parms)\n    \n    parms = [tmPar[k] for k in param_keys]\n    tmParms.append(parms)\n    \n    parms = [imPar[k] for k in param_keys]\n    imParms.append(parms)\n    \n# Store in pandas dataframe\ndf_or = pd.DataFrame(list(zip(*orParms)), columns=['GM1', 'GM2', 'GM3'], index=param_keys) # df with actual/real parameter values\ndf_tm = pd.DataFrame(list(zip(*tmParms)), columns=['GM1', 'GM2', 'GM3'], index=param_keys) # df with estimated parameter values using the traditional method\ndf_im = pd.DataFrame(list(zip(*imParms)), columns=['GM1', 'GM2', 'GM3'], index=param_keys) # df with estimated parameter values using the improved method\n\n# %% Compute percentage differences from real/actual and estimated parameter values\n# Positive: Estimated is that % higher than Real\n# Negative: Estimated is that % lower than Real\ndf_tm_p = stats.pdiff(df_tm, df_or)\ndf_im_p = stats.pdiff(df_im, df_or)\n\n# %% Variables related to overestimation of length changes due to QR\ndeltaLsee_tm   = np.full((len(muscles),10), np.nan)\ndeltaLsee_real = np.full((len(muscles),10), np.nan)\nfor iMus,mus in enumerate(muscles):   \n    orPar = pickle.load(open(os.path.join(dataDir,mus,'parameters',mus+'_OR.pkl'), 'rb'))\n    tmPar,dataQRtm = pickle.load(open(os.path.join(dataDir,mus,'parameters',mus+'_TM.pkl'), 'rb'))[0:2]\n\n    fseeQRpre = dataQRtm['fseeQRpre']\n    fseeQRpst = dataQRtm['fseeQRpst']\n    lseeQRpre = (fseeQRpre/orPar['ksee'])**0.5 + orPar['lsee0']\n    lseeQRpst = (fseeQRpst/orPar['ksee'])**0.5 + orPar['lsee0']\n    \n    # Compute change in SEE length due to QR\n    deltaLsee_tm[iMus] = dataQRtm['lseeQRpre']-dataQRtm['lseeQRpst']  # [m] estimated SEE length change due to QR\n    deltaLsee_real[iMus] = lseeQRpre-lseeQRpst  # [m] real/actual SEE length change due to QR\n\n# Compute percentage difference from real to estimated SEE length change due to QR\n# Positive: TM is that % higher than Real\n# Negative: TM is that % lower than Real\np_deltaLsee = stats.pdiff(deltaLsee_tm, deltaLsee_real)  # [%] percentage difference \np_deltaLseeAvg = np.mean(p_deltaLsee,1)  # [%] average per muscle\np_deltaLseeStd = np.std(p_deltaLsee,1)  # [%] std per muscle\n\n# Compute difference between real and estimated CE length change due to QR\ndeltaLce = deltaLsee_real-deltaLsee_tm  # [m]\ndeltaLceAvg = np.mean(deltaLce,1)  # [m] average per muscle\ndeltaLceStd = np.std(deltaLce,1)  # [m] std per muscle\n\n# %% 3.1.1: Traditional vs. Improved method\n# Extract all contraction dynamics parameters except ksee\np_TM_con = df_tm_p.loc[['a','b', 'kpee', 'fmax', 'lce_opt', 'lpee0', 'lsee0']]\n\n# Avg. difference: from real to estimated SEE length change\np_TM_deltaLsee_avgall = f'{p_deltaLseeAvg.mean():0.0f}' #  [%] avg. percentage difference\n# Avg. difference over all muscles: from real to estimated SEE stiffness\np_TM_ksee_avg = f'{df_tm_p.loc['ksee'].mean():0.0f}' #  [%] avg. percentage difference\n# Avg. difference over all muscles: from real to estimated tact\np_TM_tact_avg = f'{df_tm_p.loc['tact'].mean():0.0f}'  # [%] avg. percentage difference\n# Max. difference over all muscles: from real to estimated tact\np_TM_con_max = f'{p_TM_con.abs().max().max():0.1f}'  # [%] max. percentage difference\n# Max. difference over all muscles: from real to estimated tact\np_IM_max = f'{df_im_p.abs().max().max():0.0f}'  # [%] max. percentage difference\n\n# %% 3.1.2: Estimation of SEE stiffness. \n# Difference between SEE elongation of estimated parameter value and real/actual value\n# Positive: estimated value is higher than real/actual value\nd_esee = (df_tm.loc['fmax']/df_tm.loc['ksee'])**0.5 - (df_or.loc['fmax']/df_or.loc['ksee'])**0.5 # [m]\n\n# Correlation coefficients\nr_see = np.full(len(muscles), np.nan)\nr_pee = np.full(len(muscles), np.nan)\nr_mtc = np.full(len(muscles), np.nan)\nfor iMus,mus in enumerate(muscles):   \n    parFile = os.path.join(dataDir,mus,'parameters',mus+'_TM.pkl')\n    muspar, dataQR, dataSR, dataACTout = pickle.load(open(parFile, 'rb'))\n    \n    # SEE\n    lseeData = np.hstack((dataQR['lseeQRpre'],dataQR['lseeQRpst']))\n    fseeData = np.hstack((dataQR['fseeQRpre'],dataQR['fseeQRpst']))\n    fseeMdl = hillmodel.LEE2Force(lseeData,0,muspar)[0]\n    r_see[iMus] = np.corrcoef(fseeData, fseeMdl)[0,1]\n    \n    # PEE\n    fpeeMdl = hillmodel.LEE2Force(0,dataQR['lpeeQR'],muspar)[1]\n    r_pee[iMus] = np.corrcoef(dataQR['fpeeQR'], fpeeMdl)[0,1]\n    \n    # MTC\n    fseeMdl = hillmodel.ForceEQ(dataQR['lmtcQRpre'],1,muspar)[0]\n    r_mtc[iMus] = np.corrcoef(dataQR['fseeQRpre'], fseeMdl)[0,1]\nr_all = np.hstack((r_see,r_pee,r_mtc))\n\n# Percentage difference from real to estimated parameter\np_TM_ksee = [f'{v:0.0f}' for v in df_tm_p.loc['ksee']]  # [%] per muscle\n# Avg&Std per muscle: differences from real to estimated parameters \np_TM_deltaLsee_avgmus = [f'{v:0.0f}' for v in p_deltaLseeAvg]  # [%]\np_TM_deltaLsee_stdmus = [f'{v:0.0f}' for v in p_deltaLseeStd]  # [%]\n# Avg&Std per muscle: CE shortening during QR\np_TM_deltaLce_avgmus = [f'{v*1e6:0.0f}' for v in deltaLceAvg]  # [um] avg. per muscle\np_TM_deltaLce_stdmus = [f'{v*1e6:0.0f}' for v in deltaLceStd]  # [um] std per muscle\n# Difference from real to estimate in SEE elongation @ fmax\nd_TM_esee = [f'{v*1e3:0.2f}' for  v in d_esee] #  [mm] \n# Minimum correlation coefficient\nr_TM_min = f'{np.min(np.floor(r_all*100)/100):0.2f}'  # []\n\n# %% 3.1.2: Estimation of PEE parameter values\nnPEEdata = np.full(len(muscles), np.nan)\nfor iMus,mus in enumerate(muscles):   \n    muspar, dataQR, dataSR, dataACT = pickle.load(open(os.path.join(dataDir,mus,'parameters',mus+'_TM.pkl'), 'rb'))\n    lpeeQR = dataQR['lpeeQR']  # [m] PEE length of data\n    fpeeQR = dataQR['fpeeQR']  # [N] PEE force of data\n    fpeeModel = hillmodel.LEE2Force(0,lpeeQR,muspar)[1]  # [N] PEE force estimated\n    \n    # Compute how many data points available\n    nPEEdata[iMus] = np.sum(fpeeModel&gt;0)\n\n# Dislay percentage differences from real to estimated parameters\np_TM_kpee = [f'{v:0.1f}' for v in df_tm_p.loc['kpee']]  # [%] percentage difference\np_TM_lpee0 = [f'{v:0.1f}' for v in df_tm_p.loc['lpee0']]  # [%] percentage difference\n\n# Display amount of datapoints available\nn_PEE_data = [f'{v:0.0f}' for v in nPEEdata]  # [ ]\n\n# %% 3.1.2: Estimation of Fcemax, Lceopt, Lsee0\n# Dislay percentage differences from real to estimated parameters\np_TM_fl_max = f'{df_tm_p.loc[['fmax','lce_opt','lsee0'],:].abs().max().max():0.1f}'  # [%] maximal percentage difference\n\n# %% 3.1.2: Estimation of CE force-velocity parameter values\n# Dislay percentage differences from real to estimated parameters\np_TM_a_max = f'{df_tm_p.loc['a',:].abs().max():0.1f}'  # [%] maximal percentage difference\np_TM_b_max = f'{df_tm_p.loc['b',:].abs().max():0.1f}'  # [%] maximal percentage difference\n\n# %% 3.1.2: Estimation of excitation dynamics parameter values\np_tact_QR = np.full(len(muscles), np.nan)\np_tdeact_QR = np.full(len(muscles), np.nan)\np_tact_SR = np.full(len(muscles), np.nan)\np_tdeact_SR = np.full(len(muscles), np.nan)\nfor iMus, mus in enumerate(muscles):   \n    orPar = pickle.load(open(os.path.join(dataDir,mus,'parameters',mus+'_OR.pkl'), 'rb'))\n    qrPar = pickle.load(open(os.path.join(dataDir,mus,'parameters',mus+'_TM_QR.pkl'), 'rb'))[0]\n    srPar = pickle.load(open(os.path.join(dataDir,mus,'parameters',mus+'_TM_SR.pkl'), 'rb'))[0]\n    \n    # Compute percentage difference from real to estimated parameter\n    # Positive: estimated is that % higher than Real\n    # Negative: estimated is that % lower than Real\n    p_tact_QR[iMus] = stats.pdiff(qrPar['tact'],orPar['tact'])\n    p_tact_SR[iMus] = stats.pdiff(srPar['tact'],orPar['tact'])\n    p_tdeact_QR[iMus] = stats.pdiff(qrPar['tdeact'],orPar['tdeact'])\n    p_tdeact_SR[iMus] = stats.pdiff(srPar['tdeact'],orPar['tdeact'])\n\n# Dislay percentage differences from real to estimated parameters by using ISOM data\np_TM_tact = [f'{v:0.0f}' for v in df_tm_p.loc['tact']]  # [%] percentage difference\np_TM_tdeact = [f'{v:0.1f}' for v in df_tm_p.loc['tdeact']]  # [%] percentage difference\n\n# Display percentage difference from real to estimated parameters by using\n# either QR or SR data\np_tact_QR_avg = f'{p_tact_QR.mean():0.0f}'  #  [%] percentage difference when using QR data\np_tact_SR_avg = f'{p_tact_SR.mean():0.0f}'  #  [%] percentage difference when using SR data\np_tdeact_QR_avg = f'{p_tdeact_QR.mean():0.0f}'  #  [%] percentage difference when using QR data\np_tdeact_SR_avg = f'{p_tdeact_SR.mean():0.0f}'  #  [%] percentage difference when using SR data\n# For tdeact: differences are similar so show avg of the two\np_tdeact_QRSR = np.concatenate([p_tdeact_QR, p_tdeact_SR])\np_tdeact_QRSR_avg = f'{p_tdeact_QRSR.mean():0.0f}'  #  [%] percentage difference when using QR/SR data",
    "crumbs": [
      "{{< iconify fa6-solid magnifying-glass-chart >}} Analysis",
      "Analysis",
      "Parameter accuracy"
    ]
  },
  {
    "objectID": "data/insitu_data.html",
    "href": "data/insitu_data.html",
    "title": "Simulated data",
    "section": "",
    "text": "Details of the in situ experimentally measured data on rat gastrocnemius medialis muscle can be found on the project website of the study in which the data was collected.",
    "crumbs": [
      "{{< iconify fa6-regular floppy-disk >}} Data",
      "Data",
      "*In situ* data"
    ]
  },
  {
    "objectID": "figures/all_figures.html",
    "href": "figures/all_figures.html",
    "title": "Figures",
    "section": "",
    "text": "On this page you can find all figures and code to produce the figures of the manuscript."
  },
  {
    "objectID": "figures/all_figures.html#introduction",
    "href": "figures/all_figures.html#introduction",
    "title": "Figures",
    "section": "Introduction",
    "text": "Introduction\n\nFigure 1\n\n\nCode\n# %% Imports etc.\n# Default packages\nimport os, sys, pickle\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.close('all')\n\n# Paths\ncwd = os.getcwd()\nbaseDir = os.path.join(cwd, '..')\ndataDir = os.path.join(baseDir, 'data')\nfuncDir = os.path.join(baseDir, 'analysis', 'functions')\nsys.path.append(funcDir)\n\n# Custom imports ---\nimport cust_fig, hillmodel, make_data\n\n# %% Load muscle parameters\nmus = 'GMs1'\nparFile = os.path.join(dataDir, mus, 'parameters', f'{mus}_OR.pkl')\nmuspar = pickle.load(open(parFile, 'rb'))\nmuspar['fmax'] *= 1.1  # adjust for figure scaling\n\nmusparV2 = muspar.copy()\nmusparV2.update({\n    'lce_opt': muspar['lce_opt'] - 2.4e-3,\n    'lsee0'  : muspar['lsee0']  + 1.2e-3,\n    'ksee'   : muspar['ksee'] / 2,\n})\n\n# %% Figure setup\ncust_fig.style(plt, fontname='MinionPro', fontsize=11)\n\nfig = plt.figure(figsize=(15.92/2.54/3 +50/600, 7.34/2.54), constrained_layout=True)\ngs = fig.add_gridspec(2, 1)\naxs = np.array([[fig.add_subplot(gs[i, j]) for j in range(gs.ncols)] for i in range(gs.nrows)])\n    \n# %% Panel A: Forceâ€“Length relationship\nlmtc = np.linspace(35.5, 44.5) * 1e-3\nfsee    = hillmodel.ForceEQ(lmtc, 1, muspar)[0]\nfseeV2  = hillmodel.ForceEQ(lmtc, 1, musparV2)[0]\n\nax = axs[0,0]\nax.plot(lmtc * 1000, fsee, 'k')\nax.plot(lmtc * 1000, fseeV2, 'r')\nax.set_xlabel(r\"$L_{MTC}$ [mm]\")\nax.set_ylabel(\"$F_{SEE}$ [N]\")\nax.set_xlim(35.5, 44.5)\nax.set_ylim(0, 15)\nax.set_xticks([36, 38, 40, 42, 44], minor=False)\nax.set_xticks([37, 39, 41, 43], minor=True)\nax.set_yticks([0, 4, 8, 12], minor=False)\nax.set_yticks([2, 6, 10, 14], minor=True)\n\n# %% Panel B: Fsee(t) during SSC\ncf, fs, amp = 2, 2000, 2.5e-3\ntime = np.arange(0, 1/cf, 1/fs)\ntStim = np.array([0.0, 1/(4*cf)])\nstim = make_data.make_stim(time, *tStim)\nsolmat = {'time': time, 'lmtc': amp*np.cos(2*np.pi*time*cf)\n          + muspar['lce_opt'] + muspar['lsee0']\n          + (muspar['fmax']/muspar['ksee'])**0.5, 'tStim': tStim}\n\ndef simulate_force(params):\n    gamma0 = params['gamma_0']\n    lcerel0 = hillmodel.ForceEQ(solmat['lmtc'][0], gamma0, params)[1]\n    return hillmodel.SolveSimuMTC(gamma0, lcerel0, params, solmat)[1][9]\n\nax = axs[1,0]\nax.plot(time, simulate_force(muspar), 'k')\nax.plot(time, simulate_force(musparV2), 'r')\nax.set_xlabel(r\"Time [s]\")\nax.set_ylabel(r\"$F_{SEE}$ [N]\")\nax.set_xlim(0, 1/cf)\nax.set_ylim(0, 9.5)\nax.set_xticks([0, 0.2, 0.4])\nax.set_xticks([0.1, 0.3, 0.5], minor=True)\nax.set_yticks([0, 2, 4, 6, 8])\nax.set_yticks([1, 3, 5, 7, 9], minor=True)\n\ncust_fig.add_labels(fig, axs.flatten(), ['A', 'B'])\nfig.align_labels()\n\n# %% Save and display\nplt.show()\nfig.savefig('i_effect_ksee.pdf', bbox_inches='tight', pad_inches=0)\nfig.savefig('i_effect_ksee.svg', bbox_inches='tight', pad_inches=0)\n\n# %% Checks\nif check_size == True or check_size == 'True':\n    cust_fig.report_axes_size(fig,axs.flatten())\n    cust_fig.report_fig_size(\"i_effect_ksee.pdf\") \n    cust_fig.report_fig_size(\"i_effect_ksee.svg\") \n\n\n\n\n\n\n\n\nFigureÂ 1: Effect of a 2.5-fold difference in SEE stiffness on simulated mechanical behaviour. This example shows that some contractions may lead to similar mechanical behaviour across distinct parameter sets, others may differ substantially."
  },
  {
    "objectID": "figures/all_figures.html#methods",
    "href": "figures/all_figures.html#methods",
    "title": "Figures",
    "section": "Methods",
    "text": "Methods\n\nFigure 2\n\n\nCode\n# %% Imports etc.\nimport sys, os, pickle\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import solve_ivp\nplt.close('all')\n\n# Paths\ncwd = os.getcwd()\nbaseDir = os.path.join(cwd,'..')\ndataDir = os.path.join(baseDir,'data')\nfuncDir = os.path.join(baseDir,'analysis','functions')\nsys.path.append(funcDir)\n\n# Custom imports\nimport cust_fig, hillmodel\n\n# %% Load muscle parameters\nmus = 'GMs1'\nparFile = os.path.join(dataDir,mus,'parameters',mus+'_OR.pkl')\nmuspar = pickle.load(open(parFile, 'rb'))\n\n# %% Figure setup\ncust_fig.style(plt, fontname='MinionPro', fontsize=11, grid=True)\n\nfig = plt.figure(figsize=(15.92/2.54+50/600, (15.92/3*2-0.5)/2.54), constrained_layout=True) # 2:1 ratio (3761px x 1880px)\ngs = fig.add_gridspec(4, 2,height_ratios=[10/1.5, 10, 1/2.9, 10], hspace=0)\naxs = np.array([[fig.add_subplot(gs[i, j]) for j in range(gs.ncols)] for i in range(gs.nrows)])\naxs[0,0].remove(); axs[0,1].remove(); \naxs[0,0] = fig.add_subplot(gs[0, :])\naxs[2,0].remove(); \n\n# %% Panel 0: Schematic MTC model\ndata = pd.read_csv(\"m_mtc_data.txt\", sep=',')\nx = data.to_numpy()[:,0]\ny = data.to_numpy()[:,1]\nn = 35 # endpoint CE\n\nax = axs[0,0]\nax.set_axis_off()\nax.plot(x,y,'k',lw=1)\nax.plot(x[n],y[n],'k',marker='.')\nax.plot(np.array([0,x[0]]),np.array([0,y[0]]),'k')\nax.annotate('', xy=(0,-10), xycoords='data', xytext=(x[n], -10), arrowprops=dict(arrowstyle=\"&lt;-&gt;\", lw=0.5, shrinkA = 0, shrinkB = 0))\nax.text(x[n]/2,-16, \"$L_{CE} = L_{PEE}$\", color=\"k\",ha=\"center\", va = 'bottom') # else part of xlabel is cropped..\nax.annotate('', xy=(x[n],-10), xycoords='data', xytext=(x[-1], -10), arrowprops=dict(arrowstyle=\"&lt;-&gt;\", lw=0.5, shrinkA = 0, shrinkB = 0))\nax.text((x[-1]-x[n])/2+x[n],-16, \"$L_{SEE}$\", color=\"k\",ha=\"center\", va = 'bottom') # else part of xlabel is cropped..\nax.plot([0,0],[-16,-16], alpha=0)\nax.axis('equal')\nax.autoscale(enable=True, axis='x', tight=True)\n\n# %% Panel A: q(gamma)\nax = axs[1,0]\n\nn = 101\ngamma = np.linspace(muspar['gamma_0'],1,n)\nqlijn = -gamma*2.5+1.5;\nfor iL,lcerel in enumerate([1.45,1.15,0.85,0.55]):\n    if iL%2 == 0:\n        clr = \"gray\"\n    else:\n        clr = \"k\" # gray if we want to switch..\n    q = hillmodel.ActState(gamma,np.repeat(lcerel,n),muspar)[0]\n    l, = ax.plot(gamma,q,color=clr)\n    idx = np.argmin(np.abs(q-qlijn))\n    angle = np.rad2deg(np.arctan2(np.gradient(q,gamma)[idx], 1))\n    ax.text(gamma[idx], q[idx], '{:.2f}'.format(lcerel), ha='center', va='center', fontsize = 7, color = clr,\n                 transform_rotates_text=True, rotation=angle, bbox=dict(ec='1', fc='1', pad=0.1))\n   \nax.annotate('$L_{CE}^{rel}$', xy=(gamma[idx]+0.01, q[idx]-0.01), xycoords='data', xytext=(42, -19), \n                textcoords='offset points', arrowprops=dict(arrowstyle=\"-&gt;\",lw=0.5, connectionstyle=\"arc3,rad=-.4\"))\nax.set_xlabel(r\"$\\gamma$ [ ]\")\nax.set_ylabel(r\"$q$ [ ]\")\nax.set_xlim(0,1)\nax.set_ylim(0,1.125)\nax.set_xticks([0.0,0.25,0.5,0.75,1.0])\nax.set_xticklabels([\"0.0\",\"\",\"0.5\",\"\",\"1.0\"])\nax.set_yticks([0.0,0.25,0.5,0.75,1.0])\nax.set_yticklabels([\"0.0\",\"\",\"0.5\",\"\",\"1.0\"])\n\n# %% Panel B: fisomrel(lcerel,q) ---\nax = axs[1,1]\nlcerel = np.linspace(0,2,n)\nfisomrel = hillmodel.ForceLength(lcerel,muspar)[0]\n\nidx = np.argmin(np.abs(lcerel-1))\nfor iGam,gamma in enumerate([0.10,0.20,0.30,1.00]):\n    if iGam%2 == 0:\n        clr = \"gray\"\n    else:\n        clr = \"k\" # gray if we want to switch..\n    q = hillmodel.ActState(gamma,lcerel,muspar)[0]\n    ax.plot(lcerel,q*fisomrel,color=clr)\n    angle = np.rad2deg(np.arctan2(np.gradient(q,lcerel)[idx], 1))\n    ax.text(lcerel[idx],q[idx], '{:.2f}'.format(gamma), ha='center', va='center', fontsize = 7, color=clr,\n                  transform_rotates_text=True, rotation=angle, bbox=dict(ec='1', fc='1', pad=0.1))\n\nax.annotate(r'$\\gamma$', xy=(lcerel[idx],q[idx]+0.07), xycoords='data', xytext=(70, -20), \n                textcoords='offset points', arrowprops=dict(arrowstyle=\"-&gt;\", lw=0.5, connectionstyle=\"arc3,rad=.35\"), annotation_clip=True)\nax.set_xlabel(r\"$L_{CE}^{rel}$ [ ]\")\nax.set_xticks([muspar['w'],1,1+muspar['w']])\nax.set_xticklabels([\"1-$w$\",\"1.0\",\"1+$w$\"])\nax.set_xlim(0.3,1.7)\n\nax.set_ylabel(r\"$q \\cdot F_{CE}^{isom,rel}$ [ ]\")\nax.set_yticks([0.0,0.25,0.5,0.75,1.0])\nax.set_yticklabels([\"0.0\",\"\",\"0.5\",\"\",\"1.0\"])\nax.set_ylim(0,1.125)\n\n# %% Panel C: fcerel(vcerel)\nax = axs[3,0]\n\nlcerel = np.repeat(1,n)\nfisomrel = hillmodel.ForceLength(lcerel,muspar)\n# vcerel = np.linspace(-muspar['brel']/muspar['arel'],muspar['brel']/muspar['arel'],n)\n# fcerel = np.linspace(0,1.5,n)*idx\nfce = np.linspace(0,1.5,n)*muspar['fmax']\n\nvce = np.linspace(-muspar['b']/muspar['a'],muspar['b']/muspar['a'],n)*muspar['fmax']\nqs = [0.05,0.25,0.50,0.75,1.00]\nidx = n-20\nfor iFV,q in enumerate(qs):\n    if iFV%2 == 0:\n        clr = \"k\"\n    else:\n        clr = \"gray\" # gray if we want to switch..\n    fce,fcerel = hillmodel.Vce2Fce(vce,q,1,muspar)[0:2]\n    ax.plot(vce,fcerel,color=clr)\n    ax.text(vce[idx],fcerel[idx], '{:.2f}'.format(q), ha='center', va='center', fontsize = 7, color=clr,\n                  transform_rotates_text=True, rotation=angle, bbox=dict(ec='1', fc='1', pad=0.1))\n\nax.annotate('$q$', xy=(vce[idx],fcerel[idx]+0.1), xycoords='data', xytext=(-80, -18.5), \n                textcoords='offset points', arrowprops=dict(arrowstyle=\"-&gt;\",lw=0.5, connectionstyle=\"arc3,rad=-.3\"),annotation_clip=False)\n\nax.set_xlabel(r'$v_{CE}$ [mm/s]')\nax.set_xticks([-muspar['b']*muspar['fmax']/muspar['a'],-0.5*muspar['b']*muspar['fmax']/muspar['a'],0,0.5*muspar['b']*muspar['fmax']/muspar['a'],muspar['b']*muspar['fmax']/muspar['a']])\nax.set_xticklabels([r\"$\\frac{-b \\cdot F_{CE}^{max}}{a}$\",\"\",\"0\",\"\",r\"$\\frac{b \\cdot F_{CE}^{max}}{a}$\"])\nax.set_xticklabels([r\"$-b \\cdot F_{CE}^{max}/a$\",\"\",\"0\",\"\",r\"$b \\cdot F_{CE}^{max}/a$\"])\nax.set_xlim(-muspar['b']*muspar['fmax']/muspar['a'],muspar['b']*muspar['fmax']/muspar['a'])\n\nax.set_ylabel(r\"$F_{CE}^{rel}$ [ ]\")\nax.set_yticks([0.0,0.25,0.5,0.75,1.0,1.25,1.5])\nax.set_yticklabels([\"0.0\",\"\",\"0.5\",\"\",\"1.0\",'','1.5'])\nax.set_ylim(0,1.75)\n\n# %% Panel D: q(t)\nax = axs[3,1]\ndef Solve(t,gamma,parms,tStim):  \n    stim = ((t&gt;=tStim[0]) & (t&lt;tStim[1]))*1\n    \n    gamma_0 = parms['gamma_0'];\n    gammad = (stim&gt;=gamma)*((stim*(1-gamma_0)-gamma + gamma_0)/parms['tact']) + (stim&lt;gamma)*((stim*(1-gamma_0)-gamma + gamma_0)/parms['tdeact']);\n    return gammad, stim\n\nstate0 = [muspar['gamma_0']]\nn = 81\ntspan = [0, 0.5]\ntStim = [0.1,0.2]\n\nfun = lambda t, x: Solve(t,x,muspar,tStim)[0]\nsol = solve_ivp(fun,tspan,state0,method='RK45',max_step=1e-3,rtol=1e-4,atol=1e-8)\nstim = Solve(sol.t,sol.y,muspar,tStim)[1]\ntime = sol.t; gamma = sol.y[0];\n\nn = len(gamma)\n# q = ActState(gamma,1,muspar)[0]\n\nfor iL,lcerel in enumerate([1.4,1.0,0.6]):\n    if iL%2 == 0:\n        clr = \"k\"\n    else:\n        clr = \"gray\" # gray if we want to switch..\n    q = hillmodel.ActState(gamma,lcerel,muspar)[0]\n    ax.plot(time,q,color=clr)\n    \n    idx = np.argmin(np.abs(q[200:]-0.5))+200\n    angle = np.rad2deg(np.arctan2(np.gradient(q,time)[idx], 1))\n    ax.text(time[idx],q[idx], '{:.2f}'.format(lcerel), ha='center', va='center', fontsize = 7, color=clr,\n                  transform_rotates_text=True, rotation=angle, bbox=dict(ec='1', fc='1', pad=0.1))\n\nax.annotate('$L_{CE}^{rel}$', xy=(time[idx]-0.005, q[idx]), xycoords='data', xytext=(-42, -19), \n                textcoords='offset points', arrowprops=dict(arrowstyle=\"-&gt;\",lw=0.5, connectionstyle=\"arc3,rad=-.3\"))\n\nax.set_xlabel(r\"Time [s]\")\nax.set_ylabel(r\"$q$ [ ]\")\n\nax.set_xlim(0,0.325)\nax.set_ylim(0,1.125)\nax.set_xticks([0,0.05,0.10,0.15,0.20,0.25,0.3]);\nax.set_xticklabels([\"0\",\"\",\"0.1\",\"\",\"0.2\",'','0.3'])\nax.set_yticks([0.0,0.25,0.5,0.75,1.0])\nax.set_yticklabels([\"0.0\",\"\",\"0.5\",\"\",\"1.0\"])\n\n# %% STIM bar of Panel D\nax = axs[2,1]\nimport matplotlib.patches as patches\nfrom matplotlib.path import Path\nverts = [\n   (tStim[0], 0.99),  # left, bottom\n   (tStim[0], 1.01),  # left, top\n   (tStim[1], 1.01),  # right, top\n   (tStim[1], 0.99),  # right, bottom\n]\n\ncodes = [\n    Path.MOVETO,\n    Path.LINETO,\n    Path.LINETO,\n    Path.LINETO,\n]\n\npath = Path(verts, codes)\npatch = patches.PathPatch(path, facecolor='k', lw=0)\nax.add_patch(patch)\nax.spines['bottom'].set_visible(False)\nax.spines['left'].set_visible(False)\nax.set_xticks([]);\nax.set_yticks([]); \nax.set_xlim(0,0.325)\nax.set_ylim(0.98,1.02)\nax.autoscale(enable=True, axis='y', tight=True)\n\ncust_fig.add_labels(fig, axs.flatten(), ['','','A','B','','','C','D'])\naxs[2,1].label = 'STIM bar'\n\n# %% Save and display\nplt.show()\nfig.savefig(\"m_hill_model.svg\", bbox_inches=\"tight\", pad_inches=0)\nfig.savefig(\"m_hill_model.pdf\", bbox_inches=\"tight\", pad_inches=0)\n\n#%% Checks\nif check_size == True or check_size == 'True':\n    cust_fig.report_axes_size(fig,axs.flatten())\n    cust_fig.report_fig_size(\"m_hill_model.svg\")  \n    cust_fig.report_fig_size(\"m_hill_model.pdf\") \n\n\n\n\n\n\n\n\nFigureÂ 2: Aspects of the Hill-type MTC model used, illustrated at the top. \\(L_{CE}\\), \\(L_{PEE}\\) and \\(L_{SEE}\\) denote the CE, parallel elastic element (SEE) and serial elastic element (SEE) length. CE represents the contractile part of the muscle fibres, while PEE and SEE represent all elastic tissue in parallel or in series, respectively, with CE. In the Hill-type MTC model, CE force depends on active state (A), CE length (B) and CE velocity (C). The effect of CE stimulation on active state (\\(q\\)) is illustrated in D. A) The relationship between normalised free \\(Ca^{2+}\\) concentration between the myofilaments (\\(\\gamma\\)) and \\(q\\). \\(q\\) also depends on relative CE length (\\(L_{CE}^{rel}\\)). B) The product of \\(q\\) and the normalised active CE force-length relationship for different values of \\(\\gamma\\). C) The CE force-velocity relationship for different values of \\(q\\). D) \\(q\\) over time before, during and after CE stimulation for \\(L_{CE}^{rel}=1\\). CE stimulation is maximal during the period indicated by the black bar and â€˜offâ€™ elsewhere.\n\n\n\n\n\n\n\nFigure 3\n\n\nCode\n# %% Imports\nimport glob, os, sys\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nfrom matplotlib.path import Path\nplt.close('all')\n\n# Paths\ncwd = os.getcwd()\nbaseDir = os.path.join(cwd,'..')\ndataDir = os.path.join(baseDir,'data')\nfuncDir = os.path.join(baseDir,'analysis','functions')\nsys.path.append(funcDir)\n\n# Custom imports\nimport cust_fig, helpers, mp_estimator\n\n# %% Load muscle parameters\nmus = 'GMs1'\nparFile = os.path.join(dataDir,mus,'parameters',mus)\ndataDirMus = os.path.join(dataDir,mus,'dataExp','')\n\n# %% Figure setup\ncust_fig.style(plt, fontname='MinionPro', fontsize=11, grid=False)\n\nfig = plt.figure(figsize=((15.92/2.54)+50/600, (15.92/3-0.32)/2.54), constrained_layout=True) # 3:1 ratio\ngs = fig.add_gridspec(3,3,height_ratios=[1,1/6.0,4])\naxs = np.array([[fig.add_subplot(gs[i, j]) for j in range(gs.ncols)] for i in range(gs.nrows)])\n\ncolorSet = plt.rcParams['axes.prop_cycle'].by_key()['color']\ncolorSet[0] = '#000000'\n\n# %% QR exp\niFile = 5\nfiles = sorted(glob.glob(dataDirMus+'QR/'+mus+r'*.csv'))\nfilepath = files[iFile]\ndata = pd.read_csv(filepath).T.to_numpy()\ntime, lmtc, stim, fsee = data[0:4]\n_,tStimOn,tStimOff = helpers.get_stim(time,stim)\n\n# Get selection of data\noptsQR = {\n    'dataDir':          dataDirMus+'QR',\n    'iCols':            (0,1,3),\n    'idxQRmin':         'auto',\n    'idxQRpre':         'auto',\n    'idxQRpst':         'auto',\n    'nQRsamp':          'auto',\n    'dispFig':          False,\n    }\n_,idxQRmin,idxQRpre,idxQRpst = mp_estimator.loaddata.qr(optsQR)\n\n# Select interesting part of data\niOn = np.argmin(abs(time-tStimOn[0]+0.05))\niOff = np.argmin(abs(time-tStimOff[-1]-0.1))\niSel = slice(iOn,iOff)\ntime = time[iSel]-time[iSel][0]\nlmtc = lmtc[iSel]\nstim = stim[iSel]\nfsee = fsee[iSel]\ntStimOff = tStimOff[0]-tStimOn[0]+0.05\ntStimOn = tStimOn[0]-tStimOn[0]+0.05\nidxQRpre = int(np.mean(np.arange(idxQRpre[iFile][0]-iOn,idxQRpre[iFile][-1]-iOn)))\nidxQRpst = int(np.mean(np.arange(idxQRpst[iFile][0]-iOn,idxQRpst[iFile][-1]-iOn)))\ntQRpre = time[idxQRpre]\ntQRpst = time[idxQRpst]\nfQRpre = fsee[idxQRpre]\nfQRpst = fsee[idxQRpst]\nlQRpre = lmtc[idxQRpre]\nlQRpst = lmtc[idxQRpst]\n\n# Plot lmtc(t)\nax = axs[0,0]\nax.plot(time,lmtc,'k')\nax.set_ylim(lmtc.min()-1e-4,lmtc.max()+1e-4)\nax.set_axis_off()\n\n# Plot stim(t)\nax = axs[1,0]\nverts = [\n   (tStimOn, 0.99),  # left, bottom\n   (tStimOn, 1.01),  # left, top\n   (tStimOff, 1.01),  # right, top\n   (tStimOff, 0.99),  # right, bottom\n]\n\ncodes = [\n    Path.MOVETO,\n    Path.LINETO,\n    Path.LINETO,\n    Path.LINETO,\n]\n\npath = Path(verts, codes)\npatch = patches.PathPatch(path, facecolor='k', lw=0)\nax.add_patch(patch)\nax.set_ylim(0.98,1.02)\nax.set_axis_off()\nax.autoscale(enable=True, axis='y', tight=True)\n\n# Plot fsee(t)\nax = axs[2,0]\nax.plot(time,fsee,'k')\nax.set_xticks([])\nax.set_ylim(0,np.max(fsee))\nax.set_yticks([])\n\n# Mark time-stances of data selection\nax.plot(0.025,fsee[50],'.',color=colorSet[1],markersize=8)\nax.plot(tQRpre,fQRpre,'.',color=colorSet[0],markersize=8)\nax.plot(tQRpst,fQRpst,'.',color=colorSet[2],markersize=8)\nax.annotate(r'$F_{SEE}^{MIN,data}$', xy=(0.025+0.004,fsee[50]-0.4), xycoords='data', xytext=(0.12, -2), \n                textcoords='data', arrowprops=dict(arrowstyle=\"-&gt;\", lw=0.5, connectionstyle=\"arc3,rad=-0.4\"), color= colorSet[1])\nax.annotate(r'$F_{SEE}^{QR-,data}$', xy=(tQRpre-0.004,fQRpre-0.4), xycoords='data', xytext=(tQRpre-0.16, fQRpre-7), \n                textcoords='data', arrowprops=dict(arrowstyle=\"-&gt;\", lw=0.5, connectionstyle=\"arc3,rad=0.4\"), color=colorSet[0])\nax.annotate(r'$F_{SEE}^{QR+,data}$', xy=(tQRpst+0.004,fQRpst-0.4), xycoords='data', xytext=(tQRpst-0.02, fQRpst-7), \n                textcoords='data', arrowprops=dict(arrowstyle=\"-&gt;\", lw=0.5, connectionstyle=\"arc3,rad=0.4\"), color=colorSet[2])\n\n# Axis limits\naxs[0,0].set_xlim(0,time[-1])\naxs[1,0].set_xlim(0,time[-1])\naxs[2,0].set_xlim(0,time[-1])\n\n# %% SR exp\niFile = 3\nfiles = sorted(glob.glob(dataDirMus+'SR/'+mus+r'*.csv'))\nfilepath = files[iFile]\ndata = pd.read_csv(filepath).T.to_numpy()\ntime, lmtc, stim, fsee = data[0:4]\n_,tStimOn,tStimOff = helpers.get_stim(time,stim)\n\ndataDirMus = os.path.join(dataDir,mus,'dataExp','')\nparFile = os.path.join(dataDir,mus,'Parameters',mus)\n\n# Get selection of data\noptsSR = {\n    'dataDir':          dataDirMus+'QR',\n    'iCols':            (0,1,3),\n    'idxQRmin':         'auto',\n    'idxQRpre':         'auto',\n    'idxQRpst':         'auto',\n    'nQRsamp':          'auto',\n    'dispFig':          False,\n    }\n_,idxSRcon = mp_estimator.loaddata.sr(optsSR)\n\n# Select interesting part of data\niOn = np.argmin(abs(time-tStimOn[0]+0.05))\niOff = np.argmin(abs(time-tStimOff[-1]-0.1))\niSel = slice(iOn,iOff)\ntime = time[iSel]-time[iSel][0]\nlmtc = lmtc[iSel]\nstim = stim[iSel]\nfsee = fsee[iSel]\ntStimOff = tStimOff[0]-tStimOn[0]+0.05\ntStimOn = tStimOn[0]-tStimOn[0]+0.05\nidxSRcon = int(np.mean(np.arange(idxSRcon[iFile][0]-iOn,idxSRcon[iFile][-1]-iOn)))\ntSRcon = time[idxSRcon]\nfSRcon = fsee[idxSRcon]\nlSRcon = lmtc[idxSRcon]\n\n# Plot lmtc(t)\nax = axs[0,1]\nax.plot(time,lmtc,'k')\nax.set_axis_off()\n\n# Plot stim(t)\nax = axs[1,1]\nverts = [\n   (tStimOn, 0.99),  # left, bottom\n   (tStimOn, 1.01),  # left, top\n   (tStimOff, 1.01),  # right, top\n   (tStimOff, 0.99),  # right, bottom\n]\n\ncodes = [\n    Path.MOVETO,\n    Path.LINETO,\n    Path.LINETO,\n    Path.LINETO,\n]\n\npath = Path(verts, codes)\npatch = patches.PathPatch(path, facecolor='k', lw=0)\nax.add_patch(patch)\nax.set_ylim(0.98,1.02)\nax.set_axis_off()\nax.autoscale(enable=True, axis='y', tight=True)\n\n# Plot fsee(t)\nax = axs[2,1]\nax.plot(time,fsee,'k')\nax.set_xticks([])\nax.set_ylim(0,np.max(fsee))\nax.set_yticks([])\n\n# Mark time-stances of data selection\nax.plot(tSRcon,fSRcon,'.',color=colorSet[0],markersize=8)\nax.annotate(r'$F_{SEE}^{SR,data}$', xy=(tSRcon-0.002,fSRcon-0.25), xycoords='data', xytext=(tSRcon-0.2,fSRcon-5), \n                textcoords='data', arrowprops=dict(arrowstyle=\"-&gt;\", lw=0.5, connectionstyle=\"arc3,rad=.39\"), color=colorSet[0])\n\n# %% Isom exp\niFile = 6\nfiles = sorted(glob.glob(dataDirMus+'ISOM/'+mus+r'*.csv'))\nfilepath = files[iFile]\ndata = pd.read_csv(filepath).T.to_numpy()\ntime, lmtc, stim, fsee = data[0:4]\n_,tStimOn,tStimOff = helpers.get_stim(time,stim)\n\ndataDirMus = os.path.join(dataDir,mus,'dataExp','')\nparFile = os.path.join(dataDir,mus,'Parameters',mus)\n\n# Get selection of data\noptsISOM = {\n    'dataDir':          dataDirMus+'ISOM',\n    'iCols':            (0,1,3,2),\n    'durStimOffset':    0.1,\n    'dispFig':          False,\n    }\n_, idxSEL = mp_estimator.loaddata.isom(optsISOM)\n\n# Select interesting part of data\niOn = np.argmin(abs(time-tStimOn[0]+0.05))\niOff = np.argmin(abs(time-tStimOff[-1]-0.1))\niSel = slice(iOn,iOff)\ntime = time[iSel]-time[iSel][0]\nlmtc = lmtc[iSel]\nstim = stim[iSel]\nfsee = fsee[iSel]\ntStimOff = tStimOff[0]-tStimOn[0]+0.05\ntStimOn = tStimOn[0]-tStimOn[0]+0.05\n\n# Plot lmtc(t)\nax = axs[0,2]\nax.plot(time,lmtc,'k')\nax.set_axis_off()\n\n# Plot stim(t)\nax = axs[1,2]\nverts = [\n   (tStimOn, 0.99),  # left, bottom\n   (tStimOn, 1.01),  # left, top\n   (tStimOff, 1.01),  # right, top\n   (tStimOff, 0.99),  # right, bottom\n]\n\ncodes = [\n    Path.MOVETO,\n    Path.LINETO,\n    Path.LINETO,\n    Path.LINETO,\n]\n\npath = Path(verts, codes)\npatch = patches.PathPatch(path, facecolor='k', lw=0)\nax.add_patch(patch)\nax.set_ylim(0.98,1.02)\nax.set_axis_off()\nax.autoscale(enable=True, axis='y', tight=True)\nax.set_xticks([])\nax.set_yticks([])\n\n# Plot fsee(t)\nax = axs[2,2]\nax.plot(time,fsee,'k')\nax.set_xticks([])\nax.set_ylim(0,np.max(fsee))\n\n# %% Labels etc.\n# Xlim\naxs[0,2].set_xlim(0,time[-1])\naxs[1,2].set_xlim(0,time[-1])\naxs[2,2].set_xlim(0,time[-1])\n\n# Titles\naxs[0,0].set_title('QR')\naxs[0,1].set_title('SR')\naxs[0,2].set_title('ISOM')\n\n# Labels\naxs[2,0].set_xlabel('Time')\naxs[2,1].set_xlabel('Time')\naxs[2,2].set_xlabel('Time')\naxs[2,0].set_ylabel(r'$F_{SEE}$')\n\n# Set y-range similar\naxs[2,0].set_ylim(-4,14)\naxs[2,1].set_ylim(-4,14)\naxs[2,2].set_ylim(-4,14)\n\n# SR\naxs[0,1].set_xlim(0,0.5)\naxs[1,1].set_xlim(0,0.5)\naxs[2,1].set_xlim(0,0.5)\naxs[2,1].set_xticks([])\naxs[2,2].set_yticks([])\n\nlabels = ['A', 'B', 'C']\ncust_fig.add_labels(fig,axs[2,:],labels)\n\n# %%  Save and display\nplt.show()        \nfig.savefig('m_protocols.svg', bbox_inches=\"tight\", pad_inches=0)\nfig.savefig('m_protocols.pdf', bbox_inches=\"tight\", pad_inches=0)\n\n# %% Checks\nif check_size == True or check_size == 'True':\n    cust_fig.report_axes_size(fig,axs.flatten())\n    cust_fig.report_fig_size(\"m_protocols.svg\")\n    cust_fig.report_fig_size(\"m_protocols.pdf\")\n\n\n\n\n\n\n\n\nFigureÂ 3: Example of simulated data of quick-release (A), step-ramp (B) and isometric (C) experiments.** Top: MTC length over time. Bottom: SEE force over time. CE stimulation is maximal during the period indicated by the black bar, and â€˜offâ€™ elsewhere. For each experiment, we obtained specific datapoints of SEE force and the corresponding MTC length, which were used to estimate contraction and excitation dynamics parameter values.\n\n\n\n\n\n\n\nFigure 4\n\n\nCode\n# %% Imports etc.\nimport os, sys, pickle\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy import optimize\nplt.close('all')\n\n# Paths\ncwd = os.getcwd()\nbaseDir = os.path.join(cwd,'..')\ndataDir = os.path.join(baseDir,'data')\nfuncDir = os.path.join(baseDir,'analysis','functions')\nsys.path.append(funcDir)\n\n# Custom imports\nimport cust_fig, mp_estimator\n\n# %% Load muscle parameters\nmus = 'GMs1'\nparFile = os.path.join(dataDir,mus,'parameters',mus+'_OR.pkl')\nmuspar = pickle.load(open(parFile, 'rb'))\n\n# %% Figure setup\ncust_fig.style(plt, fontname='MinionPro', fontsize=11, grid=True)\n\nfig = plt.figure(figsize=((15.92/3*2)/2.54+50/600, (15.92/2-3.534)/2.54), constrained_layout=True) # 3:1 ratio\ngs = fig.add_gridspec(1,2)\naxs = np.array([[fig.add_subplot(gs[i, j]) for j in range(gs.ncols)] for i in range(gs.nrows)])\n\n# Panel A: Fsee(Lsee) of one exp\nax = axs[0,0]\n   \nlseeBS = np.array([30])\nlseeAS = np.array([29])\n \nfseeBSdata = np.array([7])\nfseeASdata = np.array([2])\n        \nlseeDeltaStep = lseeAS-lseeBS\nkseeIndv = ((np.sqrt(fseeASdata) - np.sqrt(fseeBSdata))/(lseeDeltaStep))**2\nksee1 = np.mean(kseeIndv)\n\nlseeoffset = (fseeBSdata/np.mean(kseeIndv))**(1/2)\nseePar0 = np.insert(lseeoffset,0,np.mean(kseeIndv))\nfun = lambda x: mp_estimator.objectives.cstfnc_see(x,lseeDeltaStep,fseeBSdata,fseeASdata,muspar)[0]\nseeParA = optimize.fmin(fun,seePar0,maxfun=1e7,ftol=1e-6, disp=False)\n\nfseeMdl = np.linspace(0,8,100)\nlsee = (fseeMdl/seeParA[0])**(1/2)\nl1,*_ = ax.plot(lsee,fseeMdl,color=[0,0,0],linestyle='-')\np1,*_ = ax.plot(seeParA[1],fseeBSdata,'k.',seeParA[1]+lseeDeltaStep,fseeASdata,'k.',markersize=8)\n\nxs = seeParA[1]+lseeDeltaStep[0]\nxs = xs/2.3\nxe = seeParA[1]\nxe = xe/2.3\nxm = (xs+xe)/2\n\nax.annotate('', xy=(xs, 0.16), xycoords='axes fraction', xytext=(xe, 0.16),\n            arrowprops=dict(arrowstyle=\"&lt;-&gt;\", lw=0.5, color='k'))\nax.annotate(r'$\\Delta L_{SEE}^{QR}$', xy=(xm, 0.15), xycoords='axes fraction', ha=\"center\", va=\"top\")\n\nax.set_xlim(0,2.3)\nax.set_xticks([0,seeParA[1],seeParA[1]+lseeDeltaStep[0]])\nax.set_xticklabels([r'0','',r'$L_{SEE}^{offset}$'])\nax.set_xticks([])\n\nax.set_ylim(0,8)\nax.set_yticks([])\nax.set_ylabel('$F_{SEE}$')\nax.set_ylabel('')\nax.set_yticks([0,fseeBSdata[0],fseeASdata[0]])\nax.set_yticklabels(['0',r'$F_{SEE}^{QR-,data}$',r'$F_{SEE}^{QR+,data}$'])\nax.set_xticks([0,seeParA[1]])\nax.set_xticklabels([r'0',r'$c_{SEE}$'])\n\n# %% Panel B: Fsee(Lsee) of two exp\nax = axs[0,1]\n\nlseeBS = np.array([30, 29.5])\nlseeAS = np.array([29, 29])\n \nfseeBSdata = np.array([7, 4])\nfseeASdata = np.array([2, 1])\n        \nlseeDeltaStep = lseeAS-lseeBS\nkseeIndv = ((np.sqrt(fseeASdata) - np.sqrt(fseeBSdata))/(lseeDeltaStep))**2\nksee1 = np.mean(kseeIndv)\n\nlseeoffset = (fseeBSdata/np.mean(kseeIndv))**(1/2)\nseePar0 = np.insert(lseeoffset,0,np.mean(kseeIndv))\nfun = lambda x: mp_estimator.objectives.cstfnc_see(x,lseeDeltaStep,fseeBSdata,fseeASdata,muspar)[0]\nseeParB = optimize.fmin(fun,seePar0,maxfun=1e7,ftol=1e-6, disp=False)\nseeParB[0] = seeParB[0]*1.3\nseeParB[1] = seeParB[1]-0.2\nseeParB[2] = seeParB[2]-0.25\nfseeBSdata = np.array([7, 4])\nfseeASdata = np.array([2, 0.5])\n\nclr = [0.5,0.5,0.5]\nclr2 = [0,0,0]\nfseeMdl = np.linspace(0,8,100)\nlsee = (fseeMdl/seeParB[0])**(1/2)\n\nx = np.array([seeParB[1],seeParB[1]])\ny = np.array([fseeBSdata[0],seeParB[1]**2*seeParB[0]])\nax.plot(x,y,color=clr2,linestyle='-')\nx = np.array([seeParB[1]+lseeDeltaStep[0],seeParB[1]+lseeDeltaStep[0]])\ny = np.array([fseeASdata[0],(seeParB[1]+lseeDeltaStep[0])**2*seeParB[0]])\nax.plot(x,y,color=clr2,linestyle='-')\n\nx = np.array([seeParB[2],seeParB[2]])\ny = np.array([fseeBSdata[1],seeParB[2]**2*seeParB[0]])\nax.plot(x,y,color=clr,linestyle='-')\nx = np.array([seeParB[2]+lseeDeltaStep[1],seeParB[2]+lseeDeltaStep[1]])\ny = np.array([fseeASdata[1],(seeParB[2]+lseeDeltaStep[1])**2*seeParB[0]])\nax.plot(x,y,color=clr,linestyle='-')\n\nax.plot(lsee,fseeMdl,color=[0,0,0],linestyle='-')\nax.plot(seeParB[1],fseeBSdata[0],'k.',seeParB[1]+lseeDeltaStep[0],fseeASdata[0],'k.',markersize=8)\nax.plot(seeParB[2],fseeBSdata[1],'.',seeParB[2]+lseeDeltaStep[1],fseeASdata[1],'.', color=clr,markersize=8)\n\nax.set_xlim(0,2.3)\nax.set_ylim(0,8)\nax.set_xticks([])\nax.set_yticks([])\n\nax.set_yticks([0,fseeBSdata[0],fseeASdata[0],fseeBSdata[1],fseeASdata[1]])\nax.set_yticklabels(['0',r'$F_{SEE}^{QR-,data}$',r'$F_{SEE}^{QR+,data}$',r'$F_{SEE}^{QR-,data}$',r'$F_{SEE}^{QR+,data}$'])\n\nax.set_xticks([0,seeParB[1],seeParB[2]])\nax.set_xticklabels([r'0',r'$c_{SEE}$',r'$c_{SEE}$'])\n\nax.get_xticklabels()[2].set_color(clr)\nax.get_yticklabels()[3].set_color(clr)\nax.get_yticklabels()[4].set_color(clr)\n\n# %% Legend etc.\naxs[0,0].legend(handles=[p1, l1],  # Only include 'Estimated' and 'Data' in this order\n    labels = ['Data', 'Estimated'],\n    loc='center left',\n    bbox_to_anchor=(0.02, 0.7),  # shift left (into space between axes) and center vertically\n    bbox_transform=axs[0,0].transAxes,\n    handlelength=1.0,\n    handletextpad=0.5,\n    labelspacing=0.2,\n\n    alignment='left'\n)\n\n# Subfig label\ncust_fig.add_labels(fig,axs.flatten(),['A', 'B'])\n\n# %% Save and display %%\nplt.show()\nfig.savefig('m_ksee.svg', bbox_inches=\"tight\", pad_inches=0)\nfig.savefig('m_ksee.pdf', bbox_inches=\"tight\", pad_inches=0)\n\n# %% Checks\nif check_size == True or check_size == 'True':\n    cust_fig.report_axes_size(fig,axs.flatten())\n    cust_fig.report_fig_size(\"m_ksee.svg\")\n    cust_fig.report_fig_size(\"m_ksee.pdf\")  \n\n\n\n\n\n\n\n\nFigureÂ 4: Graphical illustration of SEE stiffness parameter estimation. For each quick-release experiment, SEE force before (\\(F_{SEE}^{QR-,data}\\)) and after (\\(F_{SEE}^{QR+,data}\\)) the quick-release was obtained from the data, as well as the corresponding decrease in SEE length (\\(\\Delta L_{SEE}^{QR}\\)). Since SEE length prior to the quick-release is typically unknown, a temporary parameter (\\(c_{SEE}\\)) was introduced for each experiment to represent the difference between SEE length before the quick-release and SEE slack length. A) A single quick-release experiment yields two unknowns: \\(c_{SEE}\\) and a parameter that scales SEE stiffness (\\(k_{SEE}\\)). B) Running multiple quick-release experiments yields n+1 unknowns: n values of \\(c_{SEE}\\) (one for each experiment) and the parameter scaling SEE stiffness. Here, two quick-release experiments are illustrated (one indicated with black dots, the other with grey dots), while the estimated SEE force-length relationship is depicted with the black line.\n\n\n\n\n\n\n\nFigure 5\n\n\nCode\n# %% Imports etc.\nimport os, sys, pickle\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.close('all')\n\n# Paths\ncwd = os.getcwd()\nbaseDir = os.path.join(cwd,'..')\ndataDir = os.path.join(baseDir,'data')\nfuncDir = os.path.join(baseDir,'analysis','functions')\nsys.path.append(funcDir)\n\n# Custom imports\nimport cust_fig, hillmodel, mp_estimator\n\n# %% Load muscle parameters\nmus = 'GMs1'\nparFile = os.path.join(dataDir,mus,'parameters',mus+'_OR.pkl')\nmuspar = pickle.load(open(parFile, 'rb'))\n\nfmax = muspar['fmax']\nvmax = muspar['b']/muspar['a']*muspar['fmax']\n\n# %% Figure setup\ncust_fig.style(plt, fontname='MinionPro', fontsize=11, grid=True)\n\nfig = plt.figure(figsize=((15.92/3)/2.54+51/600, (15.92/3-0.07)/2.54), constrained_layout=True) # 3:2 ratio\ngs = fig.add_gridspec(1,1)\naxs = np.array([[fig.add_subplot(gs[i, j]) for j in range(gs.ncols)] for i in range(gs.nrows)])\n\n# Plot 'data'\nax = axs[0,0]\nfcerel = np.linspace(0,1,10000)\nq = np.ones_like(fcerel)\nlcerel = np.ones_like(fcerel)\nfce = fcerel*muspar['fmax']\nvce,vcerel = hillmodel.Fce2Vce(fce,q,lcerel,muspar)[0:2]\nvcenorm = vce/vmax\n\n# Plot data points\nvcenormData = -np.array([0.8, 0.38, 0.11, 0.09])\nfcerelData = np.array([0.09, 0.12, 0.37, 0.8])\nlcerelData = np.array([1,1,1,1])\nqData = hillmodel.ActState(1,lcerelData,muspar)[0]  # [ ] active state\nvceModel, fceModel = mp_estimator.helpers.findModelFV(vcenormData*vmax,fcerelData*fmax,lcerelData,qData,muspar)\nfcerelModel = fceModel/fmax\nvcenormModel = vceModel/vmax\n\nfor vd,fd,vm,fm in zip(vcenormData,fcerelData,vcenormModel,fcerelModel):   \n    ax.plot(vd,fd,'.',markersize=6,color=[0.75,0.75,0.75])\n    ax.plot([vd, vm],[fd, fm],color=[0.75,0.75,0.75],linestyle='--')\n\nvcenormData,fcerelData,lcerelData,fisomrelData,qData = [-0.43, 0.55, 1, 1, 1]\nvceModel, fceModel = mp_estimator.helpers.findModelFV(np.array([vcenormData])*vmax,np.array([fcerelData])*fmax,np.array([lcerelData]),np.array([qData]),muspar)\nfcerelModel = fceModel[0]/fmax\nvcenormModel = vceModel[0]/vmax\np1,*_ = ax.plot(vcenormData,fcerelData,'.',markersize=6,color='k')\nax.plot([vcenormData, vcenormModel],[fcerelData, fcerelModel],linestyle='--',color='k')\n\n# Right angle mark\nidx = np.argwhere(np.diff(np.sign(vcenormModel - vcenorm))).flatten()+1\ndvdf = np.gradient(fcerel,vcenorm)[idx]\nx = np.linspace(vcenorm[idx]-0.125,vcenorm[idx]+0.125,100)\ny = dvdf*x\nax.plot(x,y+fcerel[idx]-dvdf*vcenorm[idx],color=[0.5,0.5,0.5],linestyle='-')\n\na,b = np.polyfit([vcenormData, vcenormModel],[fcerelData, fcerelModel],1)\nx = vcenorm\ny = x*a+b-0.074\n\nidx = np.argwhere(np.diff(np.sign(fcerel - y))).flatten()\nx2 = np.linspace(vcenorm[idx]-0.0507,vcenorm[idx],10000)\ny2 = x2*a+b-0.074\nax.plot(x2,y2,color=[0.6,0.6,0.6],linestyle='-')\n\nx3 = x\nb3 = x2[0]*a+b-0.074 - (x2[0]*dvdf)\ny3 = dvdf*(x3)+b3\n\nidx = np.argwhere(np.diff(np.sign(x*a+b - y3))).flatten()\nx4 = np.linspace(x2[0],vcenorm[idx],10000)\ny4 = dvdf*(x4)+b3\nax.plot(x4,y4,color=[0.5,0.5,0.5],linestyle='-')\n\n# Check: L1 & L2 should be same length!\nL1 = np.sqrt((x2[0]-x2[-1])**2 + (y2[0]-y2[-1])**2)\nL2 = np.sqrt((x4[0]-x4[-1])**2 + (y4[0]-y4[-1])**2)\n\n# Plot fce(vce)\nl1,*_ = ax.plot(vcenorm,fcerel,'k')\n\n#%% Labels, legend etc.\nax.legend(handles=[p1, l1],  # Only include 'Estimated' and 'Data' in this order\n    labels = ['Data', 'Estimated'],\n    loc='upper left',\n    bbox_to_anchor=(0.02, 1.04),  # shift left (into space between axes) and center vertically\n    bbox_transform=ax.transAxes,\n    handlelength=1.0,\n    handletextpad=0.5,\n    labelspacing=0.2,\n\n    alignment='left'\n)\n\n# Labels\nax.set_xlim(-1,0)\nax.set_xticks([vcenormData])\nax.set_xticklabels([r'$v_{CE}^{data}$'])\nax.set_ylim(0,1.07)\nax.set_yticks([fcerelData])\nax.set_yticklabels([r'$F_{CE}^{data}$'])\n\n# %% Save and display\nplt.show()\nfig.savefig('m_fv.svg', bbox_inches=\"tight\", pad_inches=0)\nfig.savefig('m_fv.pdf', bbox_inches=\"tight\", pad_inches=0)\n\n# %% Checks\nif check_size:\n    cust_fig.report_axes_size(fig,axs.flatten())\n    cust_fig.report_fig_size(\"m_fv.svg\")\n    cust_fig.report_fig_size(\"m_fv.pdf\")  \n\n\n\n\n\n\n\n\nFigureÂ 5: Graphical illustration of the CE force-velocity parameter estimation using total least squares. For each step-ramp experiment, CE force and CE velocity was obtained during the interval in which SEE force changed the least. The nearest point on the CE force-velocity relationship was identified based on two criteria: it should satisfy ?@eq-fvcon, and the line from the datapoint to the CE force-velocity relationship should be perpendicular the CE force-velocity relationship. This was done for all step-ramp experiments (other datapoints are depicted in grey), while the estimated CE force-velocity relationshp is depicted with the black line."
  },
  {
    "objectID": "figures/all_figures.html#results",
    "href": "figures/all_figures.html#results",
    "title": "Figures",
    "section": "Results",
    "text": "Results\n\nFigure 6\n\n\nCode\n# %% Imports\nimport os, sys, glob\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.patches as patches\nfrom matplotlib.path import Path\nplt.close('all')\n\n# Paths\ncwd = os.getcwd()\nbaseDir = os.path.join(cwd,'..')\ndataDir = os.path.join(baseDir,'data')\nfuncDir = os.path.join(baseDir,'analysis','functions')\nsys.path.append(funcDir)\n\n# Custom imports\nimport cust_fig, helpers\n\n# %% Figure setup\ncust_fig.style(plt, fontname='MinionPro', fontsize=11, grid=True)\n\n#fig = plt.figure(figsize=(15.92/2.54+64/600, (15.92/3+0.57)/2.54), constrained_layout=True)\nfig = plt.figure(figsize=(15.92/2.54+64/600, (15.92/3+0.57)/2.54), constrained_layout=True)\ngs = fig.add_gridspec(2, 3, height_ratios=[1, 36])\naxs = np.array([[fig.add_subplot(gs[i, j]) for j in range(gs.ncols)] for i in range(gs.nrows)])\nax_inset = fig.add_axes([0.15, 0.2, 0.15, 0.2])\n\ncolorSet = plt.rcParams['axes.prop_cycle'].by_key()['color']\ncolorSet[3] = colorSet[0]\ncolorSet[0] = '#000000'\ncolors = colorSet\nlinestyles = ['-', '--', '-.', ':']\n\n# %% Datafile info\nmus = 'GMs1'\niFile = [5,3,5]\nprotocol = ['QR','SR','ISOM']\n\n# %% Plot STIM\nfor iExp,exp in enumerate(['QR','SR','ISOM']):\n    dataDirExp = os.path.join(dataDir,mus,'dataExp',exp,'')\n    files = sorted(glob.glob(dataDirExp+mus+r'*.csv'))\n    iSel = iFile[iExp]\n    filepath = files[iSel]\n    data = pd.read_csv(filepath).T.to_numpy()\n    time, lmtc, stim, fsee = data[0:4]\n    \n    _,tStimOn,tStimOff = helpers.get_stim(time,stim)\n    \n    verts = [\n       (tStimOn[0], 0.99),  # left, bottom\n       (tStimOn[0], 1.01),  # left, top\n       (tStimOff[0], 1.01),  # right, top\n       (tStimOff[0], 0.99),  # right, bottom\n    ]\n\n    codes = [\n        Path.MOVETO,\n        Path.LINETO,\n        Path.LINETO,\n        Path.LINETO,\n    ]\n\n    path = Path(verts, codes)\n    patch = patches.PathPatch(path, facecolor='k', lw=0)\n    \n    ax = axs[0, iExp]  # top row for STIM\n    ax.add_patch(patch)\n    ax.set_axis_off()\n    ax.autoscale(enable=True, axis='y', tight=True)\n\n# %% Plot SEE Force\nlineSet = []\nfor iExp,exp in enumerate(['QR','SR','ISOM']):\n    iSel = iFile[iExp] # fileNo. to be plotted.\n    for iPar,vPar in enumerate(['OR','TM','IM','MC']):\n        ax = axs[1, iExp]  # top row for STIM\n        if vPar != 'MC':\n            if vPar == 'OR':\n                dataDirExp = os.path.join(dataDir,mus,'dataExp',exp,'')\n            else:\n                dataDirExp = os.path.join(dataDir,mus,'simsExp',vPar,exp,'') \n            files = sorted(glob.glob(dataDirExp+mus+r'*.csv'))\n            filepath = files[iSel]\n            data = pd.read_csv(filepath).T.to_numpy()\n            time, lmtc, stim, fsee = data[0:4]\n            \n            l, = ax.plot(time,fsee,color=colors[iPar],linestyle=linestyles[iPar])\n            lineSet.append(l)\n            if exp == 'QR':\n                ax_inset.plot(time,fsee,color=colors[iPar],linestyle=linestyles[iPar])\n        elif vPar == 'MC':\n            if exp == 'QR':\n                n = 1000\n            elif exp == 'SR':\n                n = 1000\n            elif exp == 'ISOM':\n                n = 500\n            \n            fseeStack = np.empty((0,n))\n            for iMC in range(1,51):\n                dataDirExp = os.path.join(dataDir,mus,'simsMC',exp,f'{iMC:02d}','')\n\n                subfldr = vPar+'{:02d}'.format(iMC)\n                fileName = mus+'_'+exp+f'{iSel:02d}'+'_'+subfldr+'.csv'\n                data = pd.read_csv(dataDirExp+fileName).T.to_numpy()\n                \n                time, lmtc, stim, fsee = data[0:4]\n                fseeStack = np.vstack((fseeStack,fsee[0:n]))\n            m = np.mean(fseeStack,0)\n            s = np.std(fseeStack,0)\n            \n            ci = 1.96 * s/np.sqrt(50)\n            mi = m-ci\n            mx = m+ci\n            # axs[iAx].fill_between(time, (m-ci), (m+ci), color='b', alpha=.1)\n            l, = ax.plot(time[0:n],m,color=colors[iPar],linestyle=linestyles[iPar])\n            ax.fill_between(time[0:n], (mi), (mx), color=colors[iPar], alpha=.25)\n            lineSet.append(l)\n            \n            if exp == 'QR':\n                ax_inset.fill_between(time[0:n], (mi), (mx), color=colors[iPar], alpha=.25)\n                ax_inset.plot(time[0:n],m,color=colors[iPar],linestyle=linestyles[iPar])\n                \n# %% Labels & Titles etc.\nlineSet = lineSet[0:4]\nlegend_labels = ['Actual', 'TM', 'IM', 'MC']\nfor line, label in zip(lineSet, legend_labels):\n    line.set_label(label)\n\nfig.legend(handles=lineSet,\n           title=r\"Parameter set\",\n           title_fontproperties={'weight':'bold'},\n           loc='outside right',\n           # bbox_to_anchor=(1, .5),\n           frameon=False,\n           handlelength=1.45,\n           handletextpad=0.5,\n           labelspacing=0.2,\n           alignment='left'\n           )\n\naxs[0,0].set_title('QR')\naxs[0,1].set_title('SR')\naxs[0,2].set_title('ISOM')\n\naxs[1,0].set_xlabel('Time [s]')\naxs[1,1].set_xlabel('Time [s]')\naxs[1,2].set_xlabel('Time [s]')\naxs[1,0].set_ylabel('$F_{SEE}$'+' [N]')\n\naxs[0,0].set_xlim(0.1,0.5)\naxs[1,0].set_xlim(0.1,0.5)\naxs[1,0].set_xticks([0.1,0.3,0.5])\naxs[1,0].set_xticklabels(['0.0','0.2','0.4'])\naxs[1,0].set_xticks([0.2,0.4], minor=True)\naxs[1,0].set_ylim(0,13.5)\naxs[1,0].set_yticks([0,4,8,12])\naxs[1,0].set_yticks([2,6,10], minor=True)\n\naxs[0,1].set_xlim(0.1,0.5)\naxs[1,1].set_xlim(0.1,0.5)\naxs[1,1].set_xticks([0.1,0.3,0.5])\naxs[1,1].set_xticklabels(['0.0','0.2','0.4'])\naxs[1,1].set_xticks([0.2,0.4], minor=True)\naxs[1,1].set_ylim(0,13.5)\naxs[1,1].set_yticks([0,4,8,12])\naxs[1,1].set_yticks([2,6,10], minor=True)\n\naxs[0,2].set_xlim(0.1,0.265)\naxs[1,2].set_xlim(0.1,0.265)\n\naxs[1,2].set_xticks([0.1,0.2])\naxs[1,2].set_xticklabels(['0.0','0.1'])\naxs[1,2].set_xticks([0.15,0.25], minor=True)\naxs[1,2].set_ylim(0,13.5)\naxs[1,2].set_yticks([0,4,8,12])\naxs[1,2].set_yticks([2,6,10], minor=True)\n\nfig.canvas.draw()\nax_inset.set_xlim(0.295,0.345)\nax_inset.set_ylim(9.5,12.7)\nax_inset.set_xticklabels([])\nax_inset.set_yticklabels([])\nax_inset.grid(False)\npos = [axs[1,0].get_position().x0+0.08, axs[1,0].get_position().y0+0.05, axs[1,0].get_position().width-0.16, axs[1,0].get_position().height-0.3]\nax_inset.set_position(pos)\n\ncust_fig.add_labels(fig,axs[1,:],['A','B','C'])\n\n# %% Save and display \nplt.show()     \nfig.savefig('r_protocols.svg', bbox_inches=\"tight\", pad_inches=0)\nfig.savefig('r_protocols.pdf', bbox_inches=\"tight\", pad_inches=0)\n\n# %% Checks\nif check_size:\n    cust_fig.report_axes_size(fig,axs.flatten()) \n    cust_fig.report_fig_size(\"r_protocols.svg\") \n    cust_fig.report_fig_size(\"r_protocols.pdf\") \n\n\n\n\n\n\n\n\nFigureÂ 6: Representative example of SEE force over time during a quick-release (A), step-ramp (B) and isometric experiment (C). The inset in (A) depicts the SEE force over time around the quick-release. The SEE force over time is depicted for four sets of parameter values: 1) the actual values (i.e., literature-obtained; black solid line), those obtained with the traditional method (TM; orange dashed line), those obtained with the improved method (IM; green dashed-dotted line) and those resulting from the Monte Carlo Simulations (MC; blue dotted line, with shaded 95% confidence interval).\n\n\n\n\n\n\n\nFigure 7\n\n\nCode\n# %% Imports\nimport os, sys, pickle\nimport numpy as np\nimport matplotlib.pyplot as plt\nplt.close('all')\n\n# Paths\ncwd = os.getcwd()\nbaseDir = os.path.join(cwd,'..')\ndataDir = os.path.join(baseDir,'data')\nfuncDir = os.path.join(baseDir,'analysis','functions')\nsys.path.append(funcDir)\n\n# Custom imports\nimport cust_fig, hillmodel\n\n# %% Load muscle parameters\nmus = 'GMe1'\nparFile = os.path.join(dataDir,mus,'parameters',mus+'_IM.pkl')\nmuspar, dataQRout, dataSRout, dataACTout = pickle.load(open(parFile, 'rb'))\n\n# %% Figure setup\ncust_fig.style(plt, fontname='MinionPro', fontsize=11, grid=True)\n\nfig = plt.figure(figsize=((15.92/2)/2.54+50/600, (15.92/3+0.43)/2.54), constrained_layout=True) # 3:1 ratio\ngs = fig.add_gridspec(2,2)\naxs = np.array([[fig.add_subplot(gs[i, j]) for j in range(gs.ncols)] for i in range(gs.nrows)])\n\ncolorSet = plt.rcParams['axes.prop_cycle'].by_key()['color']\ncolorSet[3] = colorSet[0]\ncolorSet[0] = '#000000'\ncolors = colorSet\n\n# %% Panel A: Fsee(Lsee)\nax = axs[0,0]\nlseeQRpre = dataQRout['lseeQRpre']\nlseeQRpst = dataQRout['lseeQRpst']\nfseeQRpre = dataQRout['fseeQRpre']\nfseeQRpst = dataQRout['fseeQRpst']\nlpeeQR = dataQRout['lpeeQR']\nfpeeQR = dataQRout['fpeeQR']\nlmtcQRpre = dataQRout['lmtcQRpre']\n\nlsee = np.linspace(muspar['lsee0'],muspar['lsee0']+(muspar['fmax']/muspar['ksee'])**0.5,100)\nfsee = hillmodel.LEE2Force(lsee,0,muspar)[0]\nax.plot(lsee,fsee,'k',)\nax.plot(lseeQRpre,fseeQRpre,'.',color=colorSet[1])\nax.plot(lseeQRpst,fseeQRpst,'.',color=colorSet[1])\n\nax.set_xlabel('$L_{SEE}$'+' [mm]')\nax.set_ylabel('$F_{SEE}$'+' [N]')\nax.set_xlim(0.029,0.0335)\nax.set_xticks([0.029,0.030,0.031,0.032,0.033])\nax.set_xticklabels(['29','','31','','33'])\nax.set_ylim(0,17.5)\nax.set_yticks([0,3,6,9,12,15])\nax.set_yticklabels(['0','','6','','12',''])\n\n# %% Panel B: Fpee(Lpee)\nax = axs[0,1]\nlpee = np.linspace(muspar['lpee0'],muspar['lpee0']+(muspar['fmax']/muspar['kpee'])**0.5,100)\nfpee = hillmodel.LEE2Force(0,lpee,muspar)[1]\nax.plot(lpee,fpee,'k') \nax.plot(lpeeQR,fpeeQR,'.',color=colorSet[1])\n\nax.set_xlabel('$L_{PEE}$'+' [mm]')\nax.set_ylabel('$F_{PEE}$'+' [N]')\nax.set_xlim(0.0105,0.0195)\nax.set_xticks([0.011,0.013,0.015,0.017,0.019])\nax.set_xticklabels(['11','','15','','19'])\nax.set_ylim(0,0.55)\nax.set_yticks([0,0.1,0.2,0.3,0.4,0.5])\nax.set_yticklabels(['0.0','','0.2','','0.4',''])\n\n# Panel C: Fsee(Lmtc)\nax = axs[1,0]\nlmtc = np.linspace((1-muspar['w'])*muspar['lce_opt']+muspar['lsee0'],(1+muspar['w'])*muspar['lce_opt']+muspar['lsee0'],100)\nfsee = hillmodel.ForceEQ(lmtc,1,muspar)[0]\nax.plot(lmtc,fsee,'k') \nax.plot(lmtcQRpre,fseeQRpre,'.',color=colorSet[1])\n\nax.set_xlabel('$L_{MTC}$'+' [mm]')\nax.set_ylabel('$F_{SEE}$'+' [N]')\nax.set_xlim(0.0335,0.0485)\nax.set_xticks([0.035,0.038,0.041,0.044,0.047])\nax.set_xticklabels(['35','','41','','47'])\nax.set_ylim(0,17.5)\nax.set_yticks([0,3,6,9,12,15])\nax.set_yticklabels(['0','','6','','12',''])\n\n# Panel D: fce(vce)\nax = axs[1,1]\nvceSR = dataSRout['vceSR']\nfceSR = dataSRout['fceSR']\nlcerelSR = dataSRout['lcerelSR']\nfce = np.linspace(0,1,100)*muspar['fmax']\nlcerelSR_mean = np.ones_like(fce)*lcerelSR.mean()\nq = hillmodel.ActState(1,lcerelSR_mean,muspar)[0]\nvce = hillmodel.Fce2Vce(fce,q,lcerelSR_mean,muspar)[0]\nax.plot(vce,fce,'k') \nax.plot(vceSR,fceSR,'.',color=colorSet[1])\n\nax.set_xlabel('$V_{CE}$'+' [mm/s]')\nax.set_ylabel('$F_{CE}$'+' [N]')\nax.set_xlim(-0.15,0)\nax.set_xticks([-0.125,-0.10,-0.075,-0.05,-0.025,0])\nax.set_xticklabels(['','-100','','50','','0'])\nax.set_ylim(0,17.5)\nax.set_yticks([0,3,6,9,12,15])\nax.set_yticklabels(['0','','6','','12',''])\n\n# %% Labels & Titles\ncust_fig.add_labels(fig,axs.flatten(),['A','B','C','D'])\n\n# Save and display \nplt.show()\nfig.savefig('r_insitu_fit.svg', bbox_inches=\"tight\", pad_inches=0)\nfig.savefig('r_insitu_fit.pdf', bbox_inches=\"tight\", pad_inches=0)\n\n# %% Checks\nif check_size:\n    cust_fig.report_axes_size(fig,axs.flatten())\n    cust_fig.report_fig_size(\"r_insitu_fit.svg\") \n    cust_fig.report_fig_size(\"r_insitu_fit.pdf\") \n\n\n\n\n\n\n\n\nFigureÂ 7: Representative example of experimental in situ data of rat 1 for the SEE force-length relationship (A), PEE force-length relationship (B), MTC force-length relationship (C) and the CE force-velocity relationship (D).** The orange dots depicts the experimental in situ data and the solid black line depicts the model fit.\n\n\n\n\n\n\n\nFigure 8\n\n\n\n\n\n\n\n\nFigureÂ 8: Representative example of experimental in situ data and simulation results of rat 1 for SEE force over time during a quick-release experiment (A), step-ramp experiment (B), isometric experiment (C) and two stretch-shortening cycles (D & E). The simulation results were obtained by re-simulating the experimental protocol with the MTC length and CE stimulation from the experimental data as input and by using either the parameter set obtained with the traditional method (TM; orange dashed line) or the improved method (IM; green dash-dotted line). For each panel, the top plot represents MTC length over time, with the bar indicating its range in mm. CE stimulation is maximal during the periods indicated by the black bars and is â€˜offâ€™ elsewhere."
  },
  {
    "objectID": "figures/all_figures.html#supplementary-material",
    "href": "figures/all_figures.html#supplementary-material",
    "title": "Figures",
    "section": "Supplementary material",
    "text": "Supplementary material\n\nFigure S1\n\n\nCode\n# %% Imports\nimport glob, os, sys, pickle\nimport numpy as np\nimport pandas as pd\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy import integrate\nplt.close('all')\n\n# Set directories\ncwd = Path.cwd()\nbaseDir = cwd.parent\ndataDir = baseDir / 'data'\nfuncDir = baseDir / 'analysis' / 'functions'\nsys.path.append(str(funcDir))\n\n# Custom imports\nimport cust_fig, hillmodel, isotonic\n\n#%%\ncust_fig.style(plt, fontname='MinionPro', fontsize=11, grid=True)\n\nfig = plt.figure(figsize=(15.92/2.54+51/600, (15.92/2-0.54)/2.54), constrained_layout=True) # 2:3 ratio (1254px x 1880px)\ngs = fig.add_gridspec(3,2)\naxs = np.array([[fig.add_subplot(gs[i, j]) for j in range(gs.ncols)] for i in range(gs.nrows)])\n\ncolorSet = plt.rcParams['axes.prop_cycle'].by_key()['color']\ncolorSet[3] = colorSet[0]\ncolorSet[0] = '#000000'\n\n#%% Load muscle parameter values\nmus = 'GMs1'\nparFile = os.path.join(dataDir,mus,'parameters',mus+'_OR.pkl')\nmuspar = pickle.load(open(parFile, 'rb'))\n\n#%% First plot of servomotor\nexp = 'SR'\nvPar = 'OR'\ndataDirExp = os.path.join(dataDir,mus,'dataExp',exp,'')\n\nfiles = sorted(glob.glob(dataDirExp+r'*')) \nfilepath = files[3]\ndata = pd.read_csv(filepath).T.to_numpy()\ntime, lmtc, stim, fsee = data[0:4,200:]\ntime = time-time[0]\nvmtc = np.gradient(lmtc,time)            \n\naxs[0,0].plot(time,lmtc,color=colorSet[0])\naxs[1,0].plot(time,fsee,color=colorSet[0])\naxs[1,0].plot(time[428],fsee[428],'.',color=colorSet[1])\naxs[2,0].plot(time,vmtc,color=colorSet[0])\naxs[2,0].plot(time[428],vmtc[428],'.',color=colorSet[1])\n\n#%% Then of lever system\nlmtc0 = lmtc[0] # start with same length at t=0\n\ninputs = {}\ninputs['tIso'] = 0.2\ninputs['lmtc0'] = lmtc0\ninputs['fseeDrop'] = 6.4\ninputs['shorteningDistance'] = -np.nan # never stop isotnic mode..\n\n#\ntspan   = [0, 0.4]\ngamma0  = muspar['gamma_0']\nlcerel0 = hillmodel.ForceEQ(lmtc0,gamma0,muspar)[1]\nstate0  = [gamma0, lcerel0, 0]\nfun     = lambda t, x: isotonic.SimuIso(t,x,inputs,muspar)[0]\nevent   = lambda t, x: isotonic.endSimu(t,x,inputs,muspar)\nevent.terminal = False\nsol     = integrate.solve_ivp(fun,tspan,state0,method='Radau',rtol=1e-6,dense_output=True,events=event)\n\n# Post-proceess\ntime = np.arange(*[0, sol.t[-1]], 1e-3)\nstate = sol.sol(time)\nstatedot, y = isotonic.SimuIso(time,state,inputs,muspar)\n\n# Unravel\ngamma = state[0]\nlcerel = state[1]\nH = state[2]\n\ngammad = statedot[0]\nvcerel = statedot[1]\nHdot = statedot[2]\n\nlmtc = y[0]\nstim = y[1]\nfsee = y[2]\nvmtc = np.gradient(lmtc,time)\n\naxs[0,1].plot(time,fsee,color=colorSet[0])\naxs[0,1].plot(time[214],fsee[214],'.',color=colorSet[1])\naxs[1,1].plot(time,lmtc,color=colorSet[0])\naxs[2,1].plot(time,vmtc,color=colorSet[0])\naxs[2,1].plot(time[214],vmtc[214],'.',color=colorSet[1])\n\n#%% Axis etc.\nfor ax in axs.flatten():\n    ax.set_xlim(0,0.4)\n    ax.set_xticks([])\n    ax.set_yticks([])\n\nfor ax in [axs[0,0], axs[2,0]]: # lmtc\n    ax.set_ylim(37e-3,44e-3)\nfor ax in [axs[0,1], axs[1,1]]: # fsee\n    ax.set_ylim(0,14)\nfor ax in [axs[2,0], axs[2,1]]: # vmtc\n    ax.set_ylim(-0.08,1e-2) \n\naxs[0,0].set_title('' + '\\n Impose')\naxs[0,0].set_ylabel('$L_{MTC}$')\naxs[0,1].set_title('' + '\\n Impose')\naxs[0,1].set_ylabel('$F_{SEE}$')\naxs[1,0].set_title('Measure')\naxs[1,0].set_ylabel('$F_{SEE}$')\naxs[1,1].set_title('Measure')\naxs[1,1].set_ylabel('$L_{MTC}$')\naxs[2,0].set_title('Compute')\naxs[2,0].set_ylabel('$v_{MTC}$')\naxs[2,1].set_title('Compute')\naxs[2,1].set_ylabel('$v_{MTC}$')\n\naxs[2,0].set_xlabel('Time')\naxs[2,1].set_xlabel('Time')\n\n# axs[0,0].set_title('Servomotor: length-controlled' + '\\n Impose', fontweight='bold')\n# axs[0,1].set_title('Lever: force-controlled' + '\\n Impose', fontweight='bold')\nfig.text(0.27, 0.95, 'Servomotor: length-controlled', ha='center', fontweight='bold')\nfig.text(0.77, 0.95, 'Lever: force-controlled', ha='center', fontweight='bold')\n\n# %% Save\nfig.align_labels() \nplt.show()\nfig.savefig('s_servo_vs_lever.svg', bbox_inches=\"tight\", pad_inches=0)\nfig.savefig('s_servo_vs_lever.pdf', bbox_inches=\"tight\", pad_inches=0)\n\n# %% Checks\nif check_size == True or check_size == 'True':\n    cust_fig.report_axes_size(fig,axs.flatten())\n    cust_fig.report_fig_size(\"s_servo_vs_lever.svg\") \n    cust_fig.report_fig_size(\"s_servo_vs_lever.pdf\") \n\n\n\n\n\n\n\n\nFigure S1: Comparison between a length-controlled step-ramp experiment and a force-controlled quick-release experiment. In length-controlled step-ramp experiment (left), MTC length over time is imposed using a servomotor, while SEE force is measured. MTC velocity is computed at the time instance at which SEE force is near constant. In the force-controlled quick-release experiment (right), SEE force over time is imposed via a lever, while MTC length is measured. MTC velocity is computed at the time instance where MTC velocity is maximal after the change in SEE force. Both methods yield one datapoint (depicted with the orange dot) of the force-velocity relationship.\n\n\n\n\n\n\n\nFigure S2\n\n\nCode\nimport sys\nimport matplotlib.pyplot as plt\nimport schemdraw\nfrom pathlib import Path\nfrom schemdraw import flow\nplt.close('all')\n\n# Set directories\ncwd = Path.cwd()\nbaseDir = cwd.parent\ndataDir = baseDir / 'data'\nfuncDir = baseDir / 'analysis' / 'functions'\nsys.path.append(str(funcDir))\n\n# Custom import\nimport cust_fig\n\n#%%\ncust_fig.style(plt, fontname='MinionPro', fontsize=11, grid=True)\n\nwidth = 6\nheight = 1.2\n\n# IMPORTANT: no context manager\nd = schemdraw.Drawing()\nd.config(fontsize=11)\n\n# Box 1: Start block\nstart = flow.Start(w=width, h=height).label(\n    'Estimate parameter values: \\n no correction for CE shortening')\nd += start\nd += flow.Arrow().down(d.unit/5)\n\n# Box 2: P_old assignment\npold = flow.Box(w=width, h=height).label(\n    'Assign: \\n estimated parameter values to $P_{old}$.')\nd += pold\nd += flow.Arrow().down(d.unit/5)\n\n# --- Box 3: Correction block\ncorrection1 = flow.Box(w=width, h=height).label(\n    'Estimate parameter values: \\n correction for CE shortening')\nd += correction1\nd += flow.Arrow().down(d.unit/5)\n\n# Box 4: P_new assignment\npnew1 = flow.Box(w=width, h=height).label(\n    'Assign: \\n estimated parameter values to $P_{new}$.')\nd += pnew1\nd += flow.Arrow().down(d.unit/5)\n\n# Box: Decision\ndecision = flow.Decision(\n    w=width, h=width/1.5, E='YES', S='NO'\n).label(\n    'Is the difference \\n between $P_{old}$ and $P_{new}$ \\n less than 0.1% for\\n all parameter values?'\n)\nd += decision\n\n# Box 5: NO case, update Pold\nd += flow.Arrow().down(d.unit/5).at(decision.S)\npold_update = flow.Box(w=width, h=height).label(\n    \"Assign: \\n $0.7 \\\\cdot P_{old} + 0.3 \\\\cdot P_{new}$ to $P_{old}$.\")\nd += pold_update\nd += flow.Arrow().down(d.unit/5)\n\n# Box 6: NO case, estimate again\ncorrection2 = flow.Box(w=width, h=height).label(\n    'Estimate parameter values: \\n correction for CE shortening')\nd += correction2\nd += flow.Arrow().down(d.unit/5)\n\n# Box 7: NO case, update Pnew\npnew2 = flow.Box(w=width, h=height).label(\n    'Assign: \\n estimated parameter values to $P_{new}$.')\nd += pnew2\n\n# Loop arrows from Pnew to decision\nd += flow.Line().down(d.unit/5)\nd += flow.Line().left().tox(width/2 + d.unit/2.5)\nd += flow.Line().up().toy(decision.E)\nd += flow.Arrow().right().tox(decision.W)\n\n# Box ..: YES case path\nd += flow.Arrow().right(d.unit/2.5).at(decision.E)\npfinal = flow.Box(w=width, h=height).label(\n    'Final estimated parameter \\n values are $P_{new}$.')\nd += pfinal.at(decision.E, dx=1.2)\n\n# %% Draw & save\nd.draw()\nd.save('s_flowchart.svg')\nd.save('s_flowchart.pdf')\n\n# %% Checks\nif check_size == True or check_size == 'True':\n    cust_fig.report_fig_size(\"s_flowchart.svg\") \n    cust_fig.report_fig_size(\"s_flowchart.pdf\")\n\nd\n\n\n\n\n\n\n\n\nFigure S2: Flowchart of the improved method. Using the improved method, parameter values were estimated until the change in all parameter values was less than 0.1%.\n\n\n\n\n\n\n\nFigure S3\n\n\nCode\n# %% Imports\nimport os, pickle, sys\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nplt.close('all')\n\n# Set directories\ncwd = Path.cwd()\nbaseDir = cwd.parent\ndataDir = baseDir / 'data'\nfuncDir = baseDir / 'analysis' / 'functions'\nsys.path.append(str(funcDir))\n\n# Custom import\nimport cust_fig, stats\n\nplt.close('all')\n\n#%% Make figure\ncust_fig.style(plt, fontname='MinionPro', fontsize=11, grid=True)\n\nfig = plt.figure(figsize=(15.92/2.54/2+51/600, (15.92/2-0.47)/2.54), constrained_layout=True) # 2:3 ratio (1254px x 1880px)\ngs = fig.add_gridspec(1,1)\naxs = np.array([fig.add_subplot(gs[i]) for i in range(0,gs.ncols*gs.nrows)])\n\n#%% Extract parameters\nmus = 'GMs1'\nparDir = os.path.join(baseDir,'data','suppmat','')\norPar = pickle.load(open(os.path.join(dataDir,mus,'parameters',mus+'_OR.pkl'), 'rb'))\n\np_diff = []\nfor qr in ['QR01','QR04','QR07','QR10','QR15','QR20']:\n    tmPar = pickle.load(open(parDir+mus+'_'+qr+'.pkl', 'rb'))[0]\n    p_diff.append(stats.pdiff(tmPar['ksee'],orPar['ksee']))\n    \n#%% Plot\ntStep = [int(x[2:]) for x in ['QR01','QR04','QR07','QR10','QR15','QR20']]\naxs[0].plot(tStep,p_diff,'k.-')\naxs[0].set_xlabel('Duration of quick-release [ms]')\naxs[0].set_ylabel('SEE stiffness \\n' +'underestimation [%]')\n\n# %% Save\nfig.align_labels() \nplt.show()\nfig.savefig('s_servo_vs_lever.svg', bbox_inches=\"tight\", pad_inches=0)\nfig.savefig('s_servo_vs_lever.pdf', bbox_inches=\"tight\", pad_inches=0)\n\n# %% Checks\nif check_size == True or check_size == 'True':\n    cust_fig.report_axes_size(fig,axs)\n    cust_fig.report_fig_size(\"s_ksee_qr_duration.svg\") \n    cust_fig.report_fig_size(\"s_ksee_qr_duration.pdf\") \n\n\n\n\n\n\n\n\nFigure S3: Relationship between quick-release duration and SEE stiffness understimation. When the duration of the quick-release increases, the underestimation of SEE stiffness increases."
  },
  {
    "objectID": "manuscript/preprint.html",
    "href": "manuscript/preprint.html",
    "title": "Accuracy of experimentally estimated muscle properties: Evaluation and improvement using a newly developed toolbox",
    "section": "",
    "text": "In the early 20th century, A.V. Hill laid the foundation of muscle mechanics by recognising that muscles contain not only muscle fibres (the contractile element; CE) but also connective tissue, both parallel to the muscle fibre (the parallel elastic element; PEE) and in series with the muscle fibre (the tendon or serial elastic element; SEE). Together these three elements form the muscle-tendon-complex (MTC). The contraction dynamics describe how CE force emerges from the interplay between the force-length properties of CE, PEE and SEE, and the force-velocity properties of CE. In addition, CE force depends on the active state (the relative amount of \\(Ca^{2+}\\) bound to troponin C, Ebashi and Endo 1968). Active state, in turn, depends on activation via the excitation dynamics. Consequently, the mechanical behaviour of MTC arises from the intricate interplay between the contraction and the excitation dynamics.\nIn his famous (1938) paper A.V. Hill performed so-called â€˜isotonic quick-release experimentsâ€™ using the now-renowned Levin-Wyman lever (Levin and Wyman 1927) to estimate the CE force-velocity relationship. In these experiments, MTC was attached to a lever and maximally stimulated. When SEE force plateaued (i.e., MTC was isometrically delivering force), a magnet was released from the lever causing a sudden drop in the force acting on the MTC. As SEE force remained constant right after this drop in SEE force, SEE length remained constant and therefore all MTC length changes were attributed to CE length changes. The CE velocity corresponding to the constant SEE force after the drop was then calculated as the maximum rate of change of MTC length over time. Consequently, each isotonic quick-release experiment contributed a single data point of the CE force-velocity relationship. Nowadays, servomotors are typically used in experiments on isolated MTCs to control MTC length (changes). In contrast to the force-controlled experiments with the Levin-Wyman lever, servomotor control the MTC length over time (see Figure S1). In order to estimate the CE force-velocity relationship using a servomotor, Cecchi, Colomo, and Lombardi (1978) introduced â€˜step-ramp experimentsâ€™. In these experiments, MTC is kept isometrically under maximal stimulation until SEE force plateaus. Then, a rapid shortening of MTC length is imposed (the â€˜stepâ€™), immediately followed by a constant-velocity shortening of the MTC (the â€˜rampâ€™). This experimental protocol results in a brief plateau in SEE force just after the ramp. During this brief period, SEE length remains constant and therefore CE velocity equals MTC velocity. Thus, step-ramp experiments with servomotors serve as a valid alternative for isotonic quick-release experiments to estimate the CE force-velocity relationship.\nIn addition to estimating the CE force-velocity relationship using isotonic quick-release experiments, the research group of A.V. Hill also used these experiments to approximate SEE stiffness. The underlying idea was that the drop in MTC force was so fast that, due to contraction dynamics, CE had no time to shorten and all MTC shortening could thus be directly attributed to SEE shortening. Consequently, this experiment allowed to directly relate SEE length changes to changes in SEE force and therefore to estimate SEE stiffness. As mentioned above, in isotonic quick-release experiments, a sudden drop in force acting on the MTC causes a rapid change in MTC length. While in these lever-based experiments MTC force is controlled, in experiments using a servomotor MTC length is controlled. To estimate SEE stiffness with a servomotor setup, the opposite approach is taken: a rapid change in MTC length is imposed by the motor, resulting in a rapid change in SEE force. Somewhat confusingly, these servomotor-based experiments are also referred to as â€˜quick-release experimentsâ€™, even though their approach differs fundamentally from that of an isotonic quick-release experiment. In the remainder of this paper, the term quick-release experiments will exclusively refer to servomotor-based length-controlled quick-release experiments. In quick-release experiments using a servomotor, the drop in MTC length takes several milliseconds (e.g., approximately 10 ms with the commonly used Aurora Scientificâ€™s 300C series motor). As CE shortens within this short time period, the assumption that MTC length changes are exclusively due to SEE length changes may not be entirely valid. This raises the question to what extent SEE stiffness can be accurately estimated based on quick-release experiments using servomotors.\nA.V. Hill already acknowledged in (1950) that CE shortens during the brief period in which SEE force decreases â€“ even for his isotonic quick-release experiments using the Levin-Wyman lever â€“ and introduced a method to correct for this CE shortening. In this method, the CE shortening that occurred due to the quick-release was estimated based on the CE force-velocity relationship of the MTC investigated. Thus, additional experimental work â€“ such as performing step-ramp experiments and estimating the CE force-velocity relationship â€“ are required to correct for CE shortening during the quick-release. Zandwijk et al. (1997) and Lemaire et al. (2016) developed similar methods to correct for CE shortening. As expected, Zandwijk et al. (1997) showed that this method results in higher estimates of SEE stiffness than with the method without correcting for CE shortening. Nevertheless, the accuracy of SEE stiffness estimates remains uncertain, as the actual SEE stiffness is unknown in experiments, making it infeasible to compare the estimated value against the actual one. Consequently, it remains unclear whether the additional complexity and experimental work required for the improved method are truly justified in comparison with the simpler traditional method, especially when the only interest is SEE stiffness.\nIn experimental studies in which MTC properties are estimated, SEE stiffness is typically estimated first in order to discriminate between SEE stiffness and the other properties, such as those of the CE force-length relationship. In experiments, CE length is unknown and therefore the properties of the CE force-length relationship cannot be directly estimated based on experimental data. Typically, the CE force-length properties are estimated based on the measured MTC force-length relationship (e.g., BlÃ¼mel et al. 2012; Lemaire et al. 2016). However, different combinations of CE and SEE properties can yield almost identical MTC force-length relationships. Consequently, inaccuracies in SEE stiffness estimates can propagate to errors in the estimation of the CE force-length properties. While predictions under isometric conditions may remain reasonably accurate, these errors can lead to substantially different mechanical behaviour during dynamic contractions such as stretch-shortening cycles (see FigureÂ 1). As such, incorrect estimation of SEE stiffness might (partially) explain difference between predictions derived by a Hill-type MTC model and experimental results. In sum, the question arises to which extent the estimates of other MTC properties are affected by inaccurate SEE stiffness estimates and whether more accurate SEE stiffness estimates improves predictions derived by a Hill-type MTC model.\n\n\n\n\n\n\n\n\n\nFigureÂ 1: Effect of a 2.5-fold difference in SEE stiffness on simulated mechanical behaviour. This example shows that some contractions may lead to similar mechanical behaviour across distinct parameter sets, others may differ substantially.\n\n\n\n\n\nSource: Figures\nThe potential effect of error propagation also extends to the estimation of the excitation dynamics properties. In the absence of histochemical data, excitation dynamics properties are commonly estimated by fitting predicted SEE force of the Hill-type MTC model to experimental data (e.g., BlÃ¼mel et al. 2012; Lemaire et al. 2016). As SEE force over time obviously depend on the contraction dynamics properties (e.g., the force-length relationships and the force-velocity relationship), the estimation of the excitation dynamics properties is not independent of the estimation of the contraction dynamics properties. Consequently, inaccuracies in SEE stiffness estimates can propagate to inaccuracies in estimated excitation dynamics properties. This interdependence raises an additional question of what experimental data should be used in order to minimise this potential error propagation.\nThe primary objective of this study was to systematically evaluate the accuracy of estimating contraction and excitation dynamics properties on the basis of data collected in commonly used experiments. Specifically, we aimed to compare the results of a method that does not correct for CE shortening in quick-release experiments (the â€˜traditional methodâ€™) with a method that does correct for CE shortening (the â€˜improved methodâ€™). As explained earlier, the limitation of relying exclusively on an experimental approach is that the actual properties are unknown, which renders a reliable assessment of the accuracy of the estimated properties not feasible. To circumvent this problem, we conducted a modelling study using a Hill-type MTC model. First, we obtained three different sets of parameter values of a Hill-type MTC model from existing literature. Using these parameter values, we simulated data of quick-release, step-ramp and isometric protocols mimicking experiments on isolated MTCs using servomotors. We then investigated how accurately we could retrieve the modelâ€™s parameter values (with respect to their â€˜actualâ€™ value). In addition, we employed a comprehensive sensitivity analysis to assess the sensitivity of parameter values against perturbations in experimental data and to examine the interdependency of the estimated properties. The secondary objective of this study was to evaluate whether predictions from a Hill-type MTC model using parameter values estimated with the improved method better matched experimental data than predictions using parameter values estimated with the traditional method. To this end, we used in situ data from experiments on three rat m. gastrocnemius medialis. We estimated the contraction and excitation dynamics properties using both the traditional and the improved method, and compared the resulting model predictions â€” based on each parameter set â€” to experimental force data. Overall, this study provides insights into the accuracy of existing commonly used methods for contraction and excitation dynamics property estimation and their influence on predictions of mechanical behaviour derived by a Hill-type MTC model. The approach that we designed in this study for estimating contraction and excitation dynamics properties based on data of quick-release, step-ramp and isometric experiments using servomotors, is made available as an open-source toolbox (https://github.com/edwinreuvers/mp-estimator)."
  },
  {
    "objectID": "manuscript/preprint.html#introduction",
    "href": "manuscript/preprint.html#introduction",
    "title": "Accuracy of experimentally estimated muscle properties: Evaluation and improvement using a newly developed toolbox",
    "section": "",
    "text": "In the early 20th century, A.V. Hill laid the foundation of muscle mechanics by recognising that muscles contain not only muscle fibres (the contractile element; CE) but also connective tissue, both parallel to the muscle fibre (the parallel elastic element; PEE) and in series with the muscle fibre (the tendon or serial elastic element; SEE). Together these three elements form the muscle-tendon-complex (MTC). The contraction dynamics describe how CE force emerges from the interplay between the force-length properties of CE, PEE and SEE, and the force-velocity properties of CE. In addition, CE force depends on the active state (the relative amount of \\(Ca^{2+}\\) bound to troponin C, Ebashi and Endo 1968). Active state, in turn, depends on activation via the excitation dynamics. Consequently, the mechanical behaviour of MTC arises from the intricate interplay between the contraction and the excitation dynamics.\nIn his famous (1938) paper A.V. Hill performed so-called â€˜isotonic quick-release experimentsâ€™ using the now-renowned Levin-Wyman lever (Levin and Wyman 1927) to estimate the CE force-velocity relationship. In these experiments, MTC was attached to a lever and maximally stimulated. When SEE force plateaued (i.e., MTC was isometrically delivering force), a magnet was released from the lever causing a sudden drop in the force acting on the MTC. As SEE force remained constant right after this drop in SEE force, SEE length remained constant and therefore all MTC length changes were attributed to CE length changes. The CE velocity corresponding to the constant SEE force after the drop was then calculated as the maximum rate of change of MTC length over time. Consequently, each isotonic quick-release experiment contributed a single data point of the CE force-velocity relationship. Nowadays, servomotors are typically used in experiments on isolated MTCs to control MTC length (changes). In contrast to the force-controlled experiments with the Levin-Wyman lever, servomotor control the MTC length over time (see Figure S1). In order to estimate the CE force-velocity relationship using a servomotor, Cecchi, Colomo, and Lombardi (1978) introduced â€˜step-ramp experimentsâ€™. In these experiments, MTC is kept isometrically under maximal stimulation until SEE force plateaus. Then, a rapid shortening of MTC length is imposed (the â€˜stepâ€™), immediately followed by a constant-velocity shortening of the MTC (the â€˜rampâ€™). This experimental protocol results in a brief plateau in SEE force just after the ramp. During this brief period, SEE length remains constant and therefore CE velocity equals MTC velocity. Thus, step-ramp experiments with servomotors serve as a valid alternative for isotonic quick-release experiments to estimate the CE force-velocity relationship.\nIn addition to estimating the CE force-velocity relationship using isotonic quick-release experiments, the research group of A.V. Hill also used these experiments to approximate SEE stiffness. The underlying idea was that the drop in MTC force was so fast that, due to contraction dynamics, CE had no time to shorten and all MTC shortening could thus be directly attributed to SEE shortening. Consequently, this experiment allowed to directly relate SEE length changes to changes in SEE force and therefore to estimate SEE stiffness. As mentioned above, in isotonic quick-release experiments, a sudden drop in force acting on the MTC causes a rapid change in MTC length. While in these lever-based experiments MTC force is controlled, in experiments using a servomotor MTC length is controlled. To estimate SEE stiffness with a servomotor setup, the opposite approach is taken: a rapid change in MTC length is imposed by the motor, resulting in a rapid change in SEE force. Somewhat confusingly, these servomotor-based experiments are also referred to as â€˜quick-release experimentsâ€™, even though their approach differs fundamentally from that of an isotonic quick-release experiment. In the remainder of this paper, the term quick-release experiments will exclusively refer to servomotor-based length-controlled quick-release experiments. In quick-release experiments using a servomotor, the drop in MTC length takes several milliseconds (e.g., approximately 10 ms with the commonly used Aurora Scientificâ€™s 300C series motor). As CE shortens within this short time period, the assumption that MTC length changes are exclusively due to SEE length changes may not be entirely valid. This raises the question to what extent SEE stiffness can be accurately estimated based on quick-release experiments using servomotors.\nA.V. Hill already acknowledged in (1950) that CE shortens during the brief period in which SEE force decreases â€“ even for his isotonic quick-release experiments using the Levin-Wyman lever â€“ and introduced a method to correct for this CE shortening. In this method, the CE shortening that occurred due to the quick-release was estimated based on the CE force-velocity relationship of the MTC investigated. Thus, additional experimental work â€“ such as performing step-ramp experiments and estimating the CE force-velocity relationship â€“ are required to correct for CE shortening during the quick-release. Zandwijk et al. (1997) and Lemaire et al. (2016) developed similar methods to correct for CE shortening. As expected, Zandwijk et al. (1997) showed that this method results in higher estimates of SEE stiffness than with the method without correcting for CE shortening. Nevertheless, the accuracy of SEE stiffness estimates remains uncertain, as the actual SEE stiffness is unknown in experiments, making it infeasible to compare the estimated value against the actual one. Consequently, it remains unclear whether the additional complexity and experimental work required for the improved method are truly justified in comparison with the simpler traditional method, especially when the only interest is SEE stiffness.\nIn experimental studies in which MTC properties are estimated, SEE stiffness is typically estimated first in order to discriminate between SEE stiffness and the other properties, such as those of the CE force-length relationship. In experiments, CE length is unknown and therefore the properties of the CE force-length relationship cannot be directly estimated based on experimental data. Typically, the CE force-length properties are estimated based on the measured MTC force-length relationship (e.g., BlÃ¼mel et al. 2012; Lemaire et al. 2016). However, different combinations of CE and SEE properties can yield almost identical MTC force-length relationships. Consequently, inaccuracies in SEE stiffness estimates can propagate to errors in the estimation of the CE force-length properties. While predictions under isometric conditions may remain reasonably accurate, these errors can lead to substantially different mechanical behaviour during dynamic contractions such as stretch-shortening cycles (see FigureÂ 1). As such, incorrect estimation of SEE stiffness might (partially) explain difference between predictions derived by a Hill-type MTC model and experimental results. In sum, the question arises to which extent the estimates of other MTC properties are affected by inaccurate SEE stiffness estimates and whether more accurate SEE stiffness estimates improves predictions derived by a Hill-type MTC model.\n\n\n\n\n\n\n\n\n\nFigureÂ 1: Effect of a 2.5-fold difference in SEE stiffness on simulated mechanical behaviour. This example shows that some contractions may lead to similar mechanical behaviour across distinct parameter sets, others may differ substantially.\n\n\n\n\n\nSource: Figures\nThe potential effect of error propagation also extends to the estimation of the excitation dynamics properties. In the absence of histochemical data, excitation dynamics properties are commonly estimated by fitting predicted SEE force of the Hill-type MTC model to experimental data (e.g., BlÃ¼mel et al. 2012; Lemaire et al. 2016). As SEE force over time obviously depend on the contraction dynamics properties (e.g., the force-length relationships and the force-velocity relationship), the estimation of the excitation dynamics properties is not independent of the estimation of the contraction dynamics properties. Consequently, inaccuracies in SEE stiffness estimates can propagate to inaccuracies in estimated excitation dynamics properties. This interdependence raises an additional question of what experimental data should be used in order to minimise this potential error propagation.\nThe primary objective of this study was to systematically evaluate the accuracy of estimating contraction and excitation dynamics properties on the basis of data collected in commonly used experiments. Specifically, we aimed to compare the results of a method that does not correct for CE shortening in quick-release experiments (the â€˜traditional methodâ€™) with a method that does correct for CE shortening (the â€˜improved methodâ€™). As explained earlier, the limitation of relying exclusively on an experimental approach is that the actual properties are unknown, which renders a reliable assessment of the accuracy of the estimated properties not feasible. To circumvent this problem, we conducted a modelling study using a Hill-type MTC model. First, we obtained three different sets of parameter values of a Hill-type MTC model from existing literature. Using these parameter values, we simulated data of quick-release, step-ramp and isometric protocols mimicking experiments on isolated MTCs using servomotors. We then investigated how accurately we could retrieve the modelâ€™s parameter values (with respect to their â€˜actualâ€™ value). In addition, we employed a comprehensive sensitivity analysis to assess the sensitivity of parameter values against perturbations in experimental data and to examine the interdependency of the estimated properties. The secondary objective of this study was to evaluate whether predictions from a Hill-type MTC model using parameter values estimated with the improved method better matched experimental data than predictions using parameter values estimated with the traditional method. To this end, we used in situ data from experiments on three rat m. gastrocnemius medialis. We estimated the contraction and excitation dynamics properties using both the traditional and the improved method, and compared the resulting model predictions â€” based on each parameter set â€” to experimental force data. Overall, this study provides insights into the accuracy of existing commonly used methods for contraction and excitation dynamics property estimation and their influence on predictions of mechanical behaviour derived by a Hill-type MTC model. The approach that we designed in this study for estimating contraction and excitation dynamics properties based on data of quick-release, step-ramp and isometric experiments using servomotors, is made available as an open-source toolbox (https://github.com/edwinreuvers/mp-estimator)."
  },
  {
    "objectID": "manuscript/preprint.html#methods",
    "href": "manuscript/preprint.html#methods",
    "title": "Accuracy of experimentally estimated muscle properties: Evaluation and improvement using a newly developed toolbox",
    "section": "2 Methods",
    "text": "2 Methods\nThe primary objective of this study was to assess the accuracy of estimating contraction and excitation dynamics properties. For this purpose, we employed a Hill-type MTC model to simulate MTC mechanical behaviour, as detailed in SectionÂ 2.1. Using parameter values obtained from existing literature, we simulated data of quick-release, step-ramp, and isometric experiments, mimicking experiments on isolated MTCs with servomotors, as described in SectionÂ 2.2.1. We then estimated the contraction and excitation dynamics parameter values using two methods: one with (the â€˜traditional methodâ€™) and one without (the â€˜improved methodâ€™) a correction for CE shortening due to the quick-release (see SectionÂ 2.3). Additionally, we conducted comprehensive sensitivity analyses to assess the accuracy of the improved method, as outlined in SectionÂ 2.4. The secondary objective was to evaluate predictions derived by a Hill-type MTC model using two sets of parameter values: one estimated by the traditional method, the other by the improved method. For this purpose, we used in situ data (see SectionÂ 2.2.2) from three rat m. gastrocnemius medialis. Predictions were assessed against quick-release, step-ramp, and isometric experiments, as well as independently measured stretch-shortening cycles. This allowed us to investigate whether the improved method enhanced the predictions derived by a Hill-type MTC model.\n\n2.1 Muscle model\n\n2.1.1 Contraction dynamics\nWe employed a Hill-type MTC model consisting of a contractile element (CE) and a parallel elastic element (PEE), which were both in series with a serial elastic element (SEE), as depicted in FigureÂ 2. CE represented the contractile element of the muscle fibres, while PEE and SEE represented the tissues arranged in parallel and in series with the muscle fibres, respectively. Given the negligible small mass of MTC compared to the forces typically delivered by CE, PEE, and SEE, we simplified the model by neglecting the second-order dynamics of the system:\n\\[\n\\begin{aligned}\n  L_{MTC}             &= L_{CE} + L_{SEE} +  \\\\\n  F_{SEE}               &= F_{CE} + F_{PEE}\n\\end{aligned}\n\\tag{1}\\]\n\\(L_{MTC}\\), \\(L_{CE}\\), \\(L_{SEE}\\) and \\(L_{PEE}\\) denote MTC, CE, PEE and SEE length respectively, while \\(F_{SEE}\\), \\(F_{CE}\\), and \\(F_{PEE}\\) denote the CE, PEE and SEE force. PEE and SEE were assumed be purely elastic and were modelled as quadratic springs (Zajac 1989,):\n\\[\nF_{EE}=\n  \\begin{cases}\n    k_{SEE} \\cdot (l_{EE}-L_{EE}^{0})^2, & \\text{if}\\ l_{EE} \\ge L_{EE}^{0} \\\\\n    0, & \\text{otherwise}\n  \\end{cases}\n\\tag{2}\\]\n\\(L_{EE}\\) denotes the length of either PEE or SEE and \\(L_{EE}^{0}\\) the slack length of either PEE or SEE. \\(k_{EE}\\) denotes a parameter that scales the stiffness of either PEE or SEE.\nIsometric CE force depends on CE length (Blix 1892, 1893; A. V. Hill 1925). We simplified the classic sarcomere force-length relationship (Gordon, Huxley, and Julian 1966; Walker and Schrodt 1974,) to a second order polynomial, which describes the force-length relationship reasonably well (Bobbert, Ettema, and Huijing 1990; Woittiez et al. 1984):\n\\[\nF_{CE}^{isom,rel} =\n  \\begin{cases}\n    \\frac{-1}{w^{2}} \\cdot (L_{CE}^{rel}-1)^2+1, & \\text{if} \\ F_{CE}^{isom,rel} &gt; 0.1 \\\\\n    s_{exp} \\cdot e^{k_{exp} \\cdot L_{CE}^{rel}}, & \\text{otherwise}\n  \\end{cases}\n\\tag{3}\\] \\(F_{CE}^{isom,rel}\\) denotes the CE isometric force normalised by \\(F_{CE}^{max}\\), \\(w\\) determines the width of the CE force-length relationship (for \\(F_{CE}^{isom,rel} &gt; 0.1\\)) and \\(L_{CE}^{rel}\\) denotes CE length normalised by CE optimum length (\\(L_{CE}^{opt}\\), the CE length at \\(F_{CE}^{isom,rel}=1\\)). Exponential tails were added to the isometric CE force-length relationship such that it had a continuous first derivative with respect to \\(L_{CE}^{rel}\\) (see FigureÂ 2). The parameter values of \\(s_{exp}\\) and \\(k_{exp}\\) were determined separately for the ascending and descending limb of the CE force-length relationship.\nThe concentric CE force-velocity was modelled according to Archibald Vivian Hill (1938). The original description was adjusted as suggested by Soest and Bobbert (1993) to account for situations where the active state (\\(q\\), the relative amount of \\(Ca^{2+}\\) bound to troponin C, Ebashi and Endo 1968) is not maximal:\n\\[\nF_{CE} = \\frac{q \\cdot (F_{CE}^{isom,rel} \\cdot F_{CE}^{max} \\cdot b + a \\cdot v_{CE})}{b-v_{CE}}\n\\tag{4}\\]\n\\(F_{CE}\\) denotes the CE force and \\(v_{CE}\\) denotes the CE velocity. \\(a\\) is a parameter that defines the curvature of the concentric CE force-velocity relationship and defines together with \\(b\\) and \\(F_{CE}^{max}\\) the maximum shortening velocity (\\(v_{CE}^{max}\\), \\(v_{CE}^{max} = -b/a \\cdot F_{CE}^{max}\\)). The maximum shortening velocity is scaled by \\(F_{CE}^{isom,rel}\\) due to the formulation of the CE force-velocity relationship (see EquationÂ 4). However, the maximum shortening velocity has been reported to be more or less constant above optimum CE length (Gordon, Huxley, and Julian 1966; Stern 1974). Based on this observation, the parameter \\(a\\) was scaled by \\(F_{CE}^{isom,rel}\\) above optimum CE length (\\(L_{CE}^{rel} &gt; 1\\)) to make the maximum shortening velocity independent of CE length above optimum CE length. The parameter \\(b\\) was scaled with \\(b_{scale}\\) for low levels of active state in order to make the maximal contraction velocity dependent on the active state (Petrofsky and Phillips 1981). The original description of this scaling by Soest and Bobbert (1993) was somewhat reformulated, such that \\(b_{scale}\\) was continuously differentiable with respect to \\(q\\):\n\\[\n\\begin{aligned}\nb_{scale} &= \\frac{1}{1 + e^{-b_{shape} \\cdot (q-q_{sc})}} \\\\[0.5em]\n\\text{with} \\quad q_{sc} &= \\frac{log(\\frac{1}{b_{scale}^{min}-1}+q_0 \\cdot b_{shape})}{b_{shape}}\n\\end{aligned}\n\\tag{5}\\]\n\\(q_0\\) denotes the minimum value of \\(q\\), \\(b_{scale}^{min}\\) denotes the minimal scale factor of \\(b\\) (i.e., the minimal value of \\(b_{scale}\\)) and \\(b_{shape}\\) defines the steepness of the relation between \\(b_{scale}\\) and \\(q\\). The value of \\(b_{shape}\\) was obtained by minimising the least square error between the formulation of Soest and Bobbert (1993) and the reformulated version of the relation between \\(b_{scale}\\) and \\(q\\).\nThe eccentric part of the CE force-velocity relationship was modelled as a slanted hyperbola function (Van Soest, GfÃ¶hler, and Casius 2005) of the following form: \\[\nF_{CE}^{rel} = \\frac{c_4 - (c_3 + v_{CE}^{rel} \\cdot (c_1 + c_2 \\cdot v_{CE}^{rel})}{c_3 \\cdot v_{CE}^{rel}}\n\\tag{6}\\]\n\\(c_1\\), \\(c_2\\), \\(c_3\\) and \\(c_4\\) denote parameters that define the shape of the slanted hyperbola and depend on \\(F_{CE}^{isom,rel}\\) and \\(q\\). These parameters were chosen such that (1) the concentric and eccentric curves were continuous in the point \\(v_{CE}^{rel}=0\\); (2) the ratio between the eccentric and concentric derivatives of \\(\\frac{dF_{CE}^{rel}}{dv_{CE}^{rel}}\\) in the point \\(v_{CE}^{rel}=0\\) was defined by \\(r_{slope}\\); (3) the oblique asymptote of the eccentric curve was defined by \\(F_{asymp}\\) and (4) the slope of the slanted asymptote was defined by \\(r_{as}\\).\n\n\n2.1.2 Excitation dynamics\nThe excitation dynamics were modelled in two steps. The first step, to which we refer as the calcium dynamics, related the rate of change in normalised free \\(Ca^{2+}\\) concentration between the myofilaments (\\(\\gamma\\)) to normalised \\(CE\\) stimulation (\\(STIM\\)) and the normalised free \\(Ca^{2+}\\) concentration between the myofilaments itself (Hatze 1981, pp 31-42):\n\\[\n\\dot{\\gamma}=\n  \\begin{cases}\n    \\frac{STIM \\cdot (1 - \\gamma_0) - \\gamma + \\gamma_0}{\\tau_{act}}, & \\text{if} \\ STIM \\ge \\gamma \\\\\n    \\frac{STIM \\cdot (1 - \\gamma_0) - \\gamma + \\gamma_0}{\\tau_{deact}}, & \\text{otherwise}\n  \\end{cases}\n\\tag{7}\\]\n\\(\\gamma_0\\) denotes the minimum value of \\(\\gamma\\) and had a arbitrary small value such that EquationÂ 8 was always solvable. \\(\\tau_{act}\\) and \\(\\tau_{deact}\\) are both time constants of the first-order differential equations describing the calcium dynamics. The second step involved the relation between active state (\\(q\\)) and \\(\\gamma\\), to which we refer as the \\(q-[Ca^{2+}]\\) relation. It is well-known that muscle fibres become increasingly sensitive to \\([Ca^{2+}]\\) as their length increases (Kistemaker, Van Soest, and Bobbert 2005; Rack and Westbury 1969; Stephenson and Williams 1982). Consequently, \\(q\\) was also made dependent on \\(L_{CE}^{rel}\\). The \\(q-[Ca^{2+}]\\) relation was modelled according to Hatze (1981, pp 31-42), but was mathematically reformulated to ensure that the parameter values were physiologically meaningful and to facilitate its application for Optimal Control (e.g., Kistemaker et al. 2023):\n\\[\n  \\begin{aligned}\n    q &= q_0 + \\frac{1-q_0}{1+(kCa \\cdot \\gamma)^{A_{act}} \\cdot e^{a_{act} \\cdot B_{act}}}\n    \\\\[0.5em]\n      \\text{with} \\quad A_{act} &= \\log_{10}(e^{-a_{act}}) \\\\\n      \\text{and} \\quad B_{act} &= b_{act,1} + b_{act,2} \\cdot L_{CE}^{rel} + b_{act,3} \\cdot {L_{CE}^{rel}}^2\n  \\end{aligned}\n\\tag{8}\\]\n\\(kCa\\) relates \\(\\gamma\\) to the actual \\(Ca^{2+}\\) concentration between the myofilaments and \\(B_{act}\\) denotes the \\(pCa^{2+}\\) level at which \\(q=0.5\\). \\(B_{act}\\) depended on \\(L_{CE}^{rel}\\) (EquationÂ 8), while parameter \\(a_{act}\\) determined the steepness of the relation between \\(\\gamma\\) and \\(q\\).\n\n\n\n\n\n\n\n\n\nFigureÂ 2: Aspects of the Hill-type MTC model used, illustrated at the top. \\(L_{CE}\\), \\(L_{PEE}\\) and \\(L_{SEE}\\) denote the CE, parallel elastic element (SEE) and serial elastic element (SEE) length. CE represents the contractile part of the muscle fibres, while PEE and SEE represent all elastic tissue in parallel or in series, respectively, with CE. In the Hill-type MTC model, CE force depends on active state (A), CE length (B) and CE velocity (C). The effect of CE stimulation on active state (\\(q\\)) is illustrated in D. A) The relationship between normalised free \\(Ca^{2+}\\) concentration between the myofilaments (\\(\\gamma\\)) and \\(q\\). \\(q\\) also depends on relative CE length (\\(L_{CE}^{rel}\\)). B) The product of \\(q\\) and the normalised active CE force-length relationship for different values of \\(\\gamma\\). C) The CE force-velocity relationship for different values of \\(q\\). D) \\(q\\) over time before, during and after CE stimulation for \\(L_{CE}^{rel}=1\\). CE stimulation is maximal during the period indicated by the black bar and â€˜offâ€™ elsewhere.\n\n\n\n\n\n\n\n\n\n2.2 Simulated and in situ data\n\n2.2.1 Simulated data\nTo simulate quick-release, step-ramp, and isometric experiments, we used three parameter sets of a Hill-type MTC model from existing literature for three rat m. gastrocnemius medialis (GM1, GM2, and GM3; see Table S1).\nQuick-release experiments Each quick-release experiment consisted of an isometric phase until SEE force plateaued, followed by a rapid (step) change (10 ms) in MTC length and then followed by another isometric phase (see FigureÂ 3A). CE stimulation was maximal (i.e., \\(STIM = 1\\)) during the first isometric phase and continued at this maximal level until it was switched off shortly after the step change in MTC length occurred. The step change in MTC length was 0.2 mm and was chosen such that the resulting change in SEE force was about 5-10% of \\(F_{CE}^{max}\\). To prevent irreversible damage to muscle fibres, the maximal MTC length used in experiments is typically not far above the MTC length that yields maximal isometric SEE force (\\(L_{MTC}^{opt}\\)). Accordingly, we simulated quick-release experiments at various initial MTC lengths, ranging from a very short MTC length (i.e., a length yielding very low isometric SEE force) and at every 1 mm increment up to a MTC length that was maximal 3 mm above \\(L_{MTC}^{opt}\\).\nStep-ramp experiments Each step-ramp experiment consisted of an isometric phase slightly above (\\(\\pm\\) 0.5 mm) \\(L_{MTC}^{opt}\\), followed by a rapid (step) change (10 ms) in MTC length and then a constant MTC velocity ramp (see FigureÂ 3B). CE stimulation was maximal (i.e., \\(STIM = 1\\)) during the first isometric phase and continued at this maximal level until it was switched off 0.1 s after the step change in MTC length occurred. The change in MTC length of this step and the constant MTC velocity of the ramp were chosen such that this resulted in a more or less a constant SEE force (and therefore constant CE force) at the beginning of the ramp. We simulated 9 step-ramp experiments with different combinations of step sizes and constant MTC velocity ramps, to cover a substantial part of the concentric CE force-velocity relationship.\nIsometric experiments Isometric experiments were simulated for a combination of different MTC lengths (about 0, -2, -4 and -6 mm below \\(L_{MTC}^{opt}\\)) and stimulation durations (35, 65 and 95 ms). CE stimulation was maximal (i.e., \\(STIM = 1\\)) during the indicated stimulation duration and fully off elsewhere (see FigureÂ 3C). The combination of four different MTC lengths and three different stimulation durations resulted in twelve different isometric experiments.\n\n\n\n\n\n\n\n\n\nFigureÂ 3: Example of simulated data of quick-release (A), step-ramp (B) and isometric (C) experiments.** Top: MTC length over time. Bottom: SEE force over time. CE stimulation is maximal during the period indicated by the black bar, and â€˜offâ€™ elsewhere. For each experiment, we obtained specific datapoints of SEE force and the corresponding MTC length, which were used to estimate contraction and excitation dynamics parameter values.\n\n\n\n\n\n\n\n\n2.2.2 In situ data\nWe also used data from an in situ experiment on isolated rat m. gastrocnemius medialis, conducted on three male Wistar rats. The experiment included quick-release, step-ramp and isometric experiments, which were similar to those described in SectionÂ 2.2.1. For each rat, we performed between 11 and 13 quick-release experiments, 10 and 12 step-ramp experiments and 12 isometric experiments. Below, we provide a brief description of the experimental procedure, which is fully detailed in (Reuvers et al. 2025).\nIn the experiment, approved by the Committee on the Ethics of Animal Experimentation at the Vrije Universiteit (Permit Number: FBW- AVD11200202114471), rats were first anesthetised with urethane. The hindlimb was then shaved, and the overlying skin and m. biceps femoris were removed. The medial and lateral part of m. gastrocnemius were carefully separated from their surrounding tissue and exposed as much as possible. The rats were placed in the experimental setup with the hindlimb, femur and foot fully fixed. The distal end of the calcaneal tendon was attached to a servomotor (Aurora 309C, Aurora Scientific, Aurora, Canada) using Kevlar thread and aligned to ensure that m. gastrocnemius medialis pulled in its natural direction. All nerves not innervating m. gastrocnemius medialis were severed. M. gastrocnemius medialis was stimulated via a cuff-electrode placed on the sciatic nerve, with the proximal nerves crushed to prevent spinal reflexes. This experimental setup allowed for precise control of m. gastrocnemius medialis length changes and stimulation as well as accurate measurement of m. gastrocnemius medialis force.\n\n\n\n2.3 Parameter value estimation procedure\nThe general procedure to estimate the parameter values involved minimising the sum of squared differences between the data and the values based on the estimated parameter values. To distinguish between these, we used subscripts: for example, the value of the SEE force before the quick-release of the data is indicated by \\(F_{SEE}^{QR-,data}\\) while the value based on the estimated parameter values is indicated by \\(F_{SEE}^{QR-,est}\\).\nThe data of the quick-release experiments were used to estimate the parameter values of the CE, PEE and SEE force-length relationships. The data of the step-ramp experiments were used to estimate the parameter values of the CE force-velocity relationship. The data of the isometric experiments were used to estimate the parameter values of the excitation dynamics. Below we provide an overview on the methods used to estimate the parameter values. We also offer an open-source toolbox that automates the estimation of contraction and excitation dynamics parameter values.\n\n2.3.1 CE, SEE and PEE force-length parameter value estimation\nAs explained in the introduction, different combinations of contraction dynamics parameters can yield almost identical mechanical behaviour under isometric conditions (see also FigureÂ 1). For this reason, it is important to estimate SEE stiffness first, in order to discriminate between SEE stiffness on the one hand, and \\(L_{CE}^{opt}\\) and \\(L_{SEE}^0\\) on the other. In our approach, the parameter that scales SEE stiffness (\\(k_{SEE}\\)) is therefore estimated first. This is followed by the estimation of the PEE parameters, as \\(k_{SEE}\\) is also required for their estimation. Finally, the parameters \\(F_{CE}^{max}\\), \\(L_{CE}^{opt}\\), and \\(L_{SEE}^0\\) are estimated.\nEstimation of SEE stiffness. The first step was to estimate SEE stiffness. The model SEE force depends on the parameter values of \\(k_{SEE}\\) and \\(L_{SEE}^0\\), and obviously on SEE length. The problem, however, is that SEE length is unknown in experiments. This makes it challenging to estimate the parameter values concerning the SEE force-length relationship. Fortunately, quick-release experiments provide a way out. During quick-release experiments with a servomotor, the motor quickly shortens MTC length such that there is a rapid decline in SEE force (the â€˜quick-releaseâ€™). Due to the shortness of this timeframe, CE shortening is minimal such that almost all MTC shortening is taken up by SEE. Often, in experimental studies, it is assumed that all MTC shortening can be attributed to SEE shortening. In reality, this assumption leads to an overestimation of SEE shortening, as CE also shortens during this short timeframe. We introduced a method to correct for this overestimation of SEE shortening (see SectionÂ 2.3.4) and estimated the parameter values considering both methods: without and with correcting for CE shortening during the quick-release.\nObtaining the SEE length change due to the quick-release (\\(\\Delta L_{SEE}^{QR}\\)) is a crucial step. This is because SEE length after the quick-release (\\(L_{SEE}^{QR+}\\)) can then be expressed as SEE length before the quick-release (\\(L_{SEE}^{QR-}\\)) plus the change in SEE length due to the quick-release: \\(L_{SEE}^{QR+} = L_{SEE}^{QR-} + \\Delta L_{SEE}^{QR}\\). This allowed us to rewrite EquationÂ 2 to estimate SEE force immediately before (\\(F_{SEE}^{QR-,est}\\)) and after (\\(F_{SEE}^{QR+,est}\\)) the quick-release. This yielded:\n\\[\n  \\begin{split}\n    F_{SEE}^{QR-,est}     &= k_{SEE} \\cdot (L_{SEE}^{QR-} - L_{SEE}^0)^2 \\\\\n    F_{SEE}^{QR+,est}     &= k_{SEE} \\cdot (L_{SEE}^{QR-} + \\Delta L_{SEE}^{QR} - L_{SEE}^0)^2\n  \\end{split}  \n\\tag{9}\\]\nNow, there are two unknown parameters (i.e., \\(k_{SEE}\\) and \\(L_{SEE}^0\\)), while also SEE length before the quick-release is also unknown for each quick-release experiment. Consequently, there are more unknowns than equations. To address this issue, we replaced \\(L_{SEE}^{QR-} - L_{SEE}^0\\) with a temporary parameter \\(c_{SEE}\\). This yielded:\n\\[\n  \\begin{split}\n    F_{SEE}^{QR-,est}     &= k_{SEE} \\cdot (c_{SEE})^2 \\\\\n    F_{SEE}^{QR+,est}     &= k_{SEE} \\cdot (c_{SEE} + \\Delta L_{SEE}^{QR})^2\n  \\end{split}  \n\\tag{10}\\]\nAs \\(k_{SEE}\\) scales SEE stiffness, its value is constant across all quick-release experiments. In contrast, \\(c_{SEE}\\) depends on the parameter \\(L_{SEE}^0\\) and SEE length before the quick-release, which differs among each quick-release experiment. Consequently, \\(c_{SEE}\\) should be determined for each quick-release experiment individually. Visually, \\(c_{SEE}\\) determines the shift along the x-axis on the SEE force-length relationship, while \\(k_{SEE}\\) scales SEE stiffness and consequently SEE force (see FigureÂ 4A). The value of \\(k_{SEE}\\) (and \\(c_{SEE}\\) for each quick-release experiment) were found by minimising the sum of squared differences between the data and estimated SEE force before (\\(F_{SEE}^{QR-}\\)) and after (\\(F_{SEE}^{QR+}\\)) the quick-release.\n\n\n\n\n\n\n\n\n\nFigureÂ 4: Graphical illustration of SEE stiffness parameter estimation. For each quick-release experiment, SEE force before (\\(F_{SEE}^{QR-,data}\\)) and after (\\(F_{SEE}^{QR+,data}\\)) the quick-release was obtained from the data, as well as the corresponding decrease in SEE length (\\(\\Delta L_{SEE}^{QR}\\)). Since SEE length prior to the quick-release is typically unknown, a temporary parameter (\\(c_{SEE}\\)) was introduced for each experiment to represent the difference between SEE length before the quick-release and SEE slack length. A) A single quick-release experiment yields two unknowns: \\(c_{SEE}\\) and a parameter that scales SEE stiffness (\\(k_{SEE}\\)). B) Running multiple quick-release experiments yields n+1 unknowns: n values of \\(c_{SEE}\\) (one for each experiment) and the parameter scaling SEE stiffness. Here, two quick-release experiments are illustrated (one indicated with black dots, the other with grey dots), while the estimated SEE force-length relationship is depicted with the black line.\n\n\n\n\n\n\nEstimation of PEE parameter values. The second step was to estimate PEE stiffness. The model PEE force depends on the parameter values of \\(k_{PEE}\\) and \\(L_{PEE}^0\\), and obviously on PEE length. In experiments, SEE force is measured, while PEE force is required to estimate PEE stiffness. As such, experimental data should be used in which CE force is negligible such that PEE force is approximately equal to SEE force. At the beginning of the quick-release experiments, the active state is so low that CE force is negligible. We selected an interval of 10 ms in which the SEE force was minimal (\\(F_{SEE}^{min}\\), orange dot in FigureÂ 3A).\nIn experiments, PEE length is unknown. This problem can be addressed as follows. First, PEE length equals MTC length minus SEE length: \\(L_{PEE} = L_{MTC} - L_{SEE}\\) (EquationÂ 1). Second, SEE length is the sum of SEE slack length and SEE elongation (\\(E_{SEE}\\): \\(L_{SEE} = L_{SEE}^0 + E_{SEE}\\)). This allowed us to rewrite EquationÂ 2 to estimate PEE force (\\(F_{PEE}^{est}\\)), yielding:\n\\[\nF_{PEE}^{est} = k_{PEE} \\cdot (L_{MTC} -  - L_{SEE}^0 - E_{SEE} - L_{PEE}^0)^2\n\\tag{11}\\]\nNow, there are two unknown parameter values (i.e., \\(k_{PEE}\\) and \\(L_{PEE}^0\\)), while also SEE elongation is unknown for every quick-release experiment. Consequently, there are more unknowns than equations. To address this, we replaced \\(L_{PEE}^0 + L_{SEE}^0\\) with a temporary parameter \\(c_{PEE}\\). Subsequently, SEE elongation was computed as \\(\\sqrt{\\frac{F_{SEE}^{MIN,data}}{k_{SEE}}}\\), given the estimated SEE stiffness scaling factor in the previous step. This yielded:\n\\[\nF_{PEE}^{est} = k_{PEE} \\cdot (L_{MTC} - \\sqrt{\\frac{F_{SEE}^{MIN,data}}{k_{SEE}}} - c_{PEE})^2\n\\tag{12}\\]\nAs \\(k_{PEE}\\) only scales PEE stiffness, its value is constant across all quick-release experiments. Similarly, \\(c_{PEE}\\) is the sum of \\(L_{SEE}^0\\) and \\(L_{PEE}^0\\) and should therefore be constant for each quick-release experiment. The values of \\(k_{PEE}\\) and \\(c_{PEE}\\) were then computed by minimising the sum of squared differences between \\(F_{PEE}^{est}\\) and \\(F_{SEE}^{min,data}\\).\nEstimation of \\(F_{CE}^{max}\\), \\(L_{CE}^{opt}\\) and \\(L_{SEE}^0\\). The third step was to estimate \\(F_{CE}^{max}\\), \\(L_{CE}^{opt}\\) and \\(L_{SEE}^0\\). Before the quick-release, MTC is isometrically delivering force. We used the SEE force at this instant (\\(F_{SEE}^{QR-,data}\\), black dot in FigureÂ 3A) and the corresponding MTC length to obtain the MTC force-length relationship from the data. We then estimated maximal isometric CE force (\\(F_{CE}^{max}\\)), CE optimum length (\\(L_{CE}^{opt}\\)) and SEE slack length (\\(L_{SEE}^0\\)) by minimising the sum of squared differences between the data and estimated MTC force-length relationship. Lastly, \\(L_{PEE}^0\\) was computed by subtracting \\(L_{SEE}^0\\) from \\(c_{PEE}\\).\n\n\n2.3.2 CE force-velocity parameter value estimation\nThe values of the CE forceâ€“velocity relationship parameters \\(a\\) and \\(b\\) were estimated from data obtained during the plateau phase of SEE force in step-ramp experiments. This approach was chosen because SEE length is constant when SEE force is constant. Consequently, CE velocity equals MTC velocity under these conditions. Following this argument, we first identified a 10â€¯ms interval in which SEE force changed the least. Second, we derived CE length and CE force as functions of time using EquationÂ 1 and EquationÂ 2. Third, we calculated the CE velocity as the time-derivative of CE length. Finally, we averaged CE force and CE velocity over the 10â€¯ms interval. This procedure yielded the data of the CE force-velocity relationship.\nNow, the model CE force-velocity relationship can be fit to that of the data to obtain value of \\(a\\) and \\(b\\). However, employing a method that simply minimises the sum of ordinary least squares differences would not be appropriate because in experiments there is uncertainty in both measured CE force and CE velocity. Instead, we used a total least squares method that minimised the distance between the modelled CE force (\\(F_{CE}^{est}\\)) and CE velocity (\\(v_{CE}^{est}\\)) (now called: model values) and those of the data (see also FigureÂ 5). To do this, we had to find the nearest model values to the CE force of the data (\\(F_{CE}^{data}\\)) and CE velocity of the data (\\(v_{CE}^{data}\\)) (now called: datapoints). We used the following observations: 1) the model value has to satisfy EquationÂ 4 and 2) the derivative of \\(\\frac{dF_{CE}}{dv_{CE}}\\) of the model value should be perpendicular to the line from the datapoint to the model value (see FigureÂ 5). Hence, the model value could be found by solving EquationÂ 4 and EquationÂ 13:\n\\[\n  \\frac{dv_{CE}^{est}}{dF_{CE}^{est}} \\cdot (v_{CE}^{est} - v_{CE}^{data}) = F_{CE}^{data} - F_{CE}^{est}\n\\tag{13}\\]\nThe following cost-function was then minimised to find the parameter values of \\(a\\) and \\(b\\):\n\\[\n  J = \\sum_{i=1}^{n} {\\biggl(\\frac{F_{CE}^{data} - F_{CE}^{est}}{c_1}\\biggr)}^2 + {\\biggl(\\frac{v_{CE}^{data} - v_{CE}^{est}}{c_2}\\biggr)}^2\n\\]\n\\(c_1\\) and \\(c_2\\) denote scaling factors such that both terms of the cost-function are more or less equally weighted, which was done by setting \\(c_1\\) equal to the maximal range in CE force of the data and setting \\(c_2\\) equal to the maximal range of CE velocity of the data.\n\n\n\n\n\n\n\n\n\nFigureÂ 5: Graphical illustration of the CE force-velocity parameter estimation using total least squares. For each step-ramp experiment, CE force and CE velocity was obtained during the interval in which SEE force changed the least. The nearest point on the CE force-velocity relationship was identified based on two criteria: it should satisfy EquationÂ 4, and the line from the datapoint to the CE force-velocity relationship should be perpendicular the CE force-velocity relationship. This was done for all step-ramp experiments (other datapoints are depicted in grey), while the estimated CE force-velocity relationshp is depicted with the black line.\n\n\n\n\n\n\n\n\n2.3.3 Excitation dynamics parameter value estimation\nWe estimated the parameters values of \\(\\tau_{act}\\) and \\(\\tau_{deact}\\) based on isometric experiments. The choice to estimate only these parameters of the excitation dynamics was made because it is generally challenging to discriminate between parameter values of both the calcium dynamics (EquationÂ 7) and the \\(q-[Ca^{2+}]\\) relation (EquationÂ 8) based on mechanical measurements outlined above. The parameter values of the \\(q-[Ca^{2+}]\\) relation were set to those used in simulating the isometric experiments. Consequently, these parameters matched their actual values for the simulated data, but obviously were suboptimal for the in situ data. To estimate the parameter values of \\(\\tau_{act}\\) and \\(\\tau_{deact}\\), we minimised the sum of squared differences between the SEE force of the data and the estimated SEE force based on the parameter values. For this, an interval of the data was used starting from maximal CE stimulation to 0.1 s after CE stimulation ceased off.\n\n\n2.3.4 Parameter estimation: traditional method & improved method\nTo estimate the SEE stiffness it is generally assumed that the quick-release is so fast that all MTC shortening is taken up by SEE. As A.V. Hill already acknowledged in (1950), this is not the case in reality as CE also shortens. Although this CE shortening might be small, SEE is in general stiff and therefore small errors in SEE length may result in large errors in predicted SEE forces and thus in estimated SEE stiffness. We used two different methods to estimate the parameter values: 1) the traditional method and the improved method. In the traditional method, we followed the procedure outlined in section SectionÂ 2.3.1 and SectionÂ 2.3.2. In the improved method, we also followed the procedure outlined in SectionÂ 2.3.1 and SectionÂ 2.3.2 after which we incorporated an additional procedure to correct for CE shortening due to the quick-release. This additional procedure was as follows: 1) We calculated CE length just before the (step) change in MTC length occurred using EquationÂ 1, 2, 3 and 8, assuming that CE velocity was 0 and that \\(\\gamma\\) equalled 1. 2) We performed a (short) simulation from the time just before the (step) change in MTC length to just after the (step) change in MTC length. 3) We computed the change in CE length over this time interval as the average CE length slightly before and slightly after the (step) change in MTC length. 4) We subtracted the change in CE length from the change in MTC length to obtain the change in SEE length. In addition to correcting for CE length change during the quick-release, we incorporated a step to obtain better estimates of the actual PEE force at the time instance of minimum SEE force (\\(F_{SEE}^{min,data}\\); see FigureÂ 3). We computed CE force at this time instance using EquationÂ 3 and 8, assuming that \\(\\gamma\\) equalled its minimum value. This CE force was then subtracted from \\(F_{SEE}^{min,data}\\).\nThe improved method leads to a different (i.e., higher) SEE stiffness, which affect the estimation of the parameter values of the CE, PEE and SEE force-length relationships (see SectionÂ 2.3.1). These estimated parameter values were then used to again estimate the parameter values of the CE force-velocity relationship (see section SectionÂ 2.3.2). As the parameter values of the CE force-velocity relationship slightly changed, the estimate of CE length change due to the quick-release also changed and therefore estimated SEE stiffness changed. We found that this process always converged to a stable solution and therefore we used an iterative process until the change in all parameter values was less than 0.1% (see Figure S2).\n\n\n\n2.4 Sensitivity analysis\n\n2.4.1 Monte Carlo simulations\nIn experiments on isolated MTC, the MTC force-length relationship can shift due to irreversible damage of SEE (Aubert, Roquet, and Van der Elst 1951). We observed this phenomenon in an experiment involving isolated rat m. gastrocnemius medialis, where the MTC force-length relationship shifted by about 1 mm (~8% \\(L_{CE}^{opt}\\)) over a period of approximately 8 hours (Reuvers et al., unpublished observation). To assess the influence of these shifts on the parameter value estimation, we performed Monte Carlo simulations. We assumed that the observed shifts of the MTC force-length relationship were caused solely by a decrease in SEE stiffness. Accordingly, we decreased SEE stiffness to cause random shifts of the MTC force-length relationship between 0 and 1 mm. This way, we simulated data as if they were collected at random intervals throughout an 8-hour period. Importantly, changes in SEE stiffness affect the step size and constant MTC velocity ramp required for a more or less a constant SEE force at the beginning of the ramp in step-ramp experiments. Therefore, we adjusted the step size and constant MTC velocity ramp for each simulated step-ramp trial individually. Parameter values of each MTC were then estimated using the â€˜perturbedâ€™ data using the improved method (see SectionÂ 2.3.4). This process was repeated 50 times for each MTC, allowing us to evaluate both the mean and the spread of the estimated parameter values.\n\n\n2.4.2 Interdependency of parameter values\nThe parameter estimation procedure detailed above follows a fixed order in which certain parameters are estimated before others. For instance, \\(k_{SEE}\\) is estimated first and therefore affects the estimation of \\(L_{SEE}^0\\) and \\(L_{CE}^{opt}\\). This sequence creates an interdependency among the parameter values, which has been identified as a potential cause for substantial variation in parameter values among individuals, even within the same muscle type (Lemaire et al. 2016). To investigate this interdependency, we systematically changed parameter values of our model. Specifically, we increased and decreased each parameter value by 5% relative to the values obtained with the improved method. After this, we re-estimated all other parameter values. This approach allowed us to assess the influence of changes in one parameter on the estimation of others."
  },
  {
    "objectID": "manuscript/preprint.html#results",
    "href": "manuscript/preprint.html#results",
    "title": "Accuracy of experimentally estimated muscle properties: Evaluation and improvement using a newly developed toolbox",
    "section": "3 Results",
    "text": "3 Results\n\n3.1 Evaluating parameter value estimation accuracy - simulated data\n\n\nCode\n# %% Load packages\nimport os, pickle, sys\nimport numpy as np\nimport pandas as pd\nfrom pathlib import Path\n\n# Set directories\ncwd = Path.cwd()\nbaseDir = cwd.parent\ndataDir = baseDir / 'data'\nfuncDir = baseDir / 'analysis' / 'functions'\nsys.path.append(str(funcDir))\n\n# Custom functions\nimport hillmodel, stats\n\n# %% Extract parameters\nmuscles = ['GMs1','GMs2','GMs3']\nparam_keys = ['a', 'b', 'kpee', 'ksee', 'fmax', 'lce_opt', 'lpee0', 'lsee0', 'tact', 'tdeact']\n\norParms, tmParms, imParms = [], [], []\nfor mus in muscles:   \n    orPar = pickle.load(open(os.path.join(dataDir,mus,'parameters',mus+'_OR.pkl'), 'rb'))\n    tmPar = pickle.load(open(os.path.join(dataDir,mus,'parameters',mus+'_TM.pkl'), 'rb'))[0]\n    imPar = pickle.load(open(os.path.join(dataDir,mus,'parameters',mus+'_IM.pkl'), 'rb'))[0]\n\n    parms = [orPar[k] for k in param_keys]\n    orParms.append(parms)\n    \n    parms = [tmPar[k] for k in param_keys]\n    tmParms.append(parms)\n    \n    parms = [imPar[k] for k in param_keys]\n    imParms.append(parms)\n    \n# Store in pandas dataframe\ndf_or = pd.DataFrame(list(zip(*orParms)), columns=['GM1', 'GM2', 'GM3'], index=param_keys) # df with actual/real parameter values\ndf_tm = pd.DataFrame(list(zip(*tmParms)), columns=['GM1', 'GM2', 'GM3'], index=param_keys) # df with estimated parameter values using the traditional method\ndf_im = pd.DataFrame(list(zip(*imParms)), columns=['GM1', 'GM2', 'GM3'], index=param_keys) # df with estimated parameter values using the improved method\n\n# %% Compute percentage differences from real/actual and estimated parameter values\n# Positive: Estimated is that % higher than Real\n# Negative: Estimated is that % lower than Real\ndf_tm_p = stats.pdiff(df_tm, df_or)\ndf_im_p = stats.pdiff(df_im, df_or)\n\n# %% Variables related to overestimation of length changes due to QR\ndeltaLsee_tm   = np.full((len(muscles),10), np.nan)\ndeltaLsee_real = np.full((len(muscles),10), np.nan)\nfor iMus,mus in enumerate(muscles):   \n    orPar = pickle.load(open(os.path.join(dataDir,mus,'parameters',mus+'_OR.pkl'), 'rb'))\n    tmPar,dataQRtm = pickle.load(open(os.path.join(dataDir,mus,'parameters',mus+'_TM.pkl'), 'rb'))[0:2]\n\n    fseeQRpre = dataQRtm['fseeQRpre']\n    fseeQRpst = dataQRtm['fseeQRpst']\n    lseeQRpre = (fseeQRpre/orPar['ksee'])**0.5 + orPar['lsee0']\n    lseeQRpst = (fseeQRpst/orPar['ksee'])**0.5 + orPar['lsee0']\n    \n    # Compute change in SEE length due to QR\n    deltaLsee_tm[iMus] = dataQRtm['lseeQRpre']-dataQRtm['lseeQRpst']  # [m] estimated SEE length change due to QR\n    deltaLsee_real[iMus] = lseeQRpre-lseeQRpst  # [m] real/actual SEE length change due to QR\n\n# Compute percentage difference from real to estimated SEE length change due to QR\n# Positive: TM is that % higher than Real\n# Negative: TM is that % lower than Real\np_deltaLsee = stats.pdiff(deltaLsee_tm, deltaLsee_real)  # [%] percentage difference \np_deltaLseeAvg = np.mean(p_deltaLsee,1)  # [%] average per muscle\np_deltaLseeStd = np.std(p_deltaLsee,1)  # [%] std per muscle\n\n# Compute difference between real and estimated CE length change due to QR\ndeltaLce = deltaLsee_real-deltaLsee_tm  # [m]\ndeltaLceAvg = np.mean(deltaLce,1)  # [m] average per muscle\ndeltaLceStd = np.std(deltaLce,1)  # [m] std per muscle\n\n# %% 3.1.1: Traditional vs. Improved method\n# Extract all contraction dynamics parameters except ksee\np_TM_con = df_tm_p.loc[['a','b', 'kpee', 'fmax', 'lce_opt', 'lpee0', 'lsee0']]\n\n# Avg. difference: from real to estimated SEE length change\np_TM_deltaLsee_avgall = f'{p_deltaLseeAvg.mean():0.0f}' #  [%] avg. percentage difference\n# Avg. difference over all muscles: from real to estimated SEE stiffness\np_TM_ksee_avg = f'{df_tm_p.loc['ksee'].mean():0.0f}' #  [%] avg. percentage difference\n# Avg. difference over all muscles: from real to estimated tact\np_TM_tact_avg = f'{df_tm_p.loc['tact'].mean():0.0f}%'  # [%] avg. percentage difference\n# Max. difference over all muscles: from real to estimated tact\np_TM_con_max = f'{p_TM_con.abs().max().max():0.1f}'  # [%] max. percentage difference\n# Max. difference over all muscles: from real to estimated tact\np_IM_max = f'{df_im_p.abs().max().max():0.0f}'  # [%] max. percentage difference\n\n# %% 3.1.2: Estimation of SEE stiffness. \n# Difference between SEE elongation of estimated parameter value and real/actual value\n# Positive: estimated value is higher than real/actual value\nd_esee = (df_tm.loc['fmax']/df_tm.loc['ksee'])**0.5 - (df_or.loc['fmax']/df_or.loc['ksee'])**0.5 # [m]\n\n# Correlation coefficients\nr_see = np.full(len(muscles), np.nan)\nr_pee = np.full(len(muscles), np.nan)\nr_mtc = np.full(len(muscles), np.nan)\nfor iMus,mus in enumerate(muscles):   \n    parFile = os.path.join(dataDir,mus,'parameters',mus+'_TM.pkl')\n    muspar, dataQR, dataSR, dataACTout = pickle.load(open(parFile, 'rb'))\n    \n    # SEE\n    lseeData = np.hstack((dataQR['lseeQRpre'],dataQR['lseeQRpst']))\n    fseeData = np.hstack((dataQR['fseeQRpre'],dataQR['fseeQRpst']))\n    fseeMdl = hillmodel.LEE2Force(lseeData,0,muspar)[0]\n    r_see[iMus] = np.corrcoef(fseeData, fseeMdl)[0,1]\n    \n    # PEE\n    fpeeMdl = hillmodel.LEE2Force(0,dataQR['lpeeQR'],muspar)[1]\n    r_pee[iMus] = np.corrcoef(dataQR['fpeeQR'], fpeeMdl)[0,1]\n    \n    # MTC\n    fseeMdl = hillmodel.ForceEQ(dataQR['lmtcQRpre'],1,muspar)[0]\n    r_mtc[iMus] = np.corrcoef(dataQR['fseeQRpre'], fseeMdl)[0,1]\nr_all = np.hstack((r_see,r_pee,r_mtc))\n\n# Percentage difference from real to estimated parameter\np_TM_ksee = [f'{v:0.0f}' for v in df_tm_p.loc['ksee']]  # [%] per muscle\n# Avg&Std per muscle: differences from real to estimated parameters \np_TM_deltaLsee_avgmus = [f'{v:0.0f}' for v in p_deltaLseeAvg]  # [%]\np_TM_deltaLsee_stdmus = [f'{v:0.0f}' for v in p_deltaLseeStd]  # [%]\n# Avg&Std per muscle: CE shortening during QR\np_TM_deltaLce_avgmus = [f'{v*1e6:0.0f}' for v in deltaLceAvg]  # [um] avg. per muscle\np_TM_deltaLce_stdmus = [f'{v*1e6:0.0f}' for v in deltaLceStd]  # [um] std per muscle\n# Difference from real to estimate in SEE elongation @ fmax\nd_TM_esee = [f'{v*1e3:0.2f}' for  v in d_esee] #  [mm] \n# Minimum correlation coefficient\nr_TM_min = f'{np.min(np.floor(r_all*100)/100):0.2f}'  # []\n\n# %% 3.1.2: Estimation of PEE parameter values\nnPEEdata = np.full(len(muscles), np.nan)\nfor iMus,mus in enumerate(muscles):   \n    muspar, dataQR, dataSR, dataACT = pickle.load(open(os.path.join(dataDir,mus,'parameters',mus+'_TM.pkl'), 'rb'))\n    lpeeQR = dataQR['lpeeQR']  # [m] PEE length of data\n    fpeeQR = dataQR['fpeeQR']  # [N] PEE force of data\n    fpeeModel = hillmodel.LEE2Force(0,lpeeQR,muspar)[1]  # [N] PEE force estimated\n    \n    # Compute how many data points available\n    nPEEdata[iMus] = np.sum(fpeeModel&gt;0)\n\n# Dislay percentage differences from real to estimated parameters\np_TM_kpee = [f'{v:0.1f}' for v in df_tm_p.loc['kpee']]  # [%] percentage difference\np_TM_lpee0 = [f'{v:0.1f}' for v in df_tm_p.loc['lpee0']]  # [%] percentage difference\n\n# Display amount of datapoints available\nn_PEE_data = [f'{v:0.0f}' for v in nPEEdata]  # [ ]\n\n# %% 3.1.2: Estimation of Fcemax, Lceopt, Lsee0\n# Dislay percentage differences from real to estimated parameters\np_TM_fl_max = f'{df_tm_p.loc[['fmax','lce_opt','lsee0'],:].abs().max().max():0.1f}'  # [%] maximal percentage difference\n\n# %% 3.1.2: Estimation of CE force-velocity parameter values\n# Dislay percentage differences from real to estimated parameters\np_TM_a_max = f'{df_tm_p.loc['a',:].abs().max():0.1f}'  # [%] maximal percentage difference\np_TM_b_max = f'{df_tm_p.loc['b',:].abs().max():0.1f}'  # [%] maximal percentage difference\n\n# %% 3.1.2: Estimation of excitation dynamics parameter values\np_tact_QR = np.full(len(muscles), np.nan)\np_tdeact_QR = np.full(len(muscles), np.nan)\np_tact_SR = np.full(len(muscles), np.nan)\np_tdeact_SR = np.full(len(muscles), np.nan)\nfor iMus, mus in enumerate(muscles):   \n    orPar = pickle.load(open(os.path.join(dataDir,mus,'parameters',mus+'_OR.pkl'), 'rb'))\n    qrPar = pickle.load(open(os.path.join(dataDir,mus,'parameters',mus+'_TM_QR.pkl'), 'rb'))[0]\n    srPar = pickle.load(open(os.path.join(dataDir,mus,'parameters',mus+'_TM_SR.pkl'), 'rb'))[0]\n    \n    # Compute percentage difference from real to estimated parameter\n    # Positive: estimated is that % higher than Real\n    # Negative: estimated is that % lower than Real\n    p_tact_QR[iMus] = stats.pdiff(qrPar['tact'],orPar['tact'])\n    p_tact_SR[iMus] = stats.pdiff(srPar['tact'],orPar['tact'])\n    p_tdeact_QR[iMus] = stats.pdiff(qrPar['tdeact'],orPar['tdeact'])\n    p_tdeact_SR[iMus] = stats.pdiff(srPar['tdeact'],orPar['tdeact'])\n\n# Dislay percentage differences from real to estimated parameters by using ISOM data\np_TM_tact = [f'{v:0.0f}' for v in df_tm_p.loc['tact']]  # [%] percentage difference\np_TM_tdeact = [f'{v:0.1f}' for v in df_tm_p.loc['tdeact']]  # [%] percentage difference\n\n# Display percentage difference from real to estimated parameters by using\n# either QR or SR data\np_tact_QR_avg = f'{p_tact_QR.mean():0.0f}'  #  [%] percentage difference when using QR data\np_tact_SR_avg = f'{p_tact_SR.mean():0.0f}'  #  [%] percentage difference when using SR data\np_tdeact_QR_avg = f'{p_tdeact_QR.mean():0.0f}'  #  [%] percentage difference when using QR data\np_tdeact_SR_avg = f'{p_tdeact_SR.mean():0.0f}'  #  [%] percentage difference when using SR data\n# For tdeact: differences are similar so show avg of the two\np_tdeact_QRSR = np.concatenate([p_tdeact_QR, p_tdeact_SR])\np_tdeact_QRSR_avg = f'{p_tdeact_QRSR.mean():0.0f}'  #  [%] percentage difference when using QR/SR data\n\n\n\n3.1.1 Traditional method versus Improved method\nThe traditional method did not correct for CE shortening during quick-release experiments. Consequently, SEE shortening due to the quick-release was overestimated by 24% on average. This overestimation of SEE shortening caused a decrease in \\(k_{SEE}\\) (and thus SEE stiffness) of 34% on average. The estimation of the activation time constant was most affected by the underestimated SEE stiffness, resulting in an underestimation of 19%% on average. All other estimated parameter values were within 8.7% of their actual values (TableÂ 1). These findings show the influence of CE shortening â€” even within a very brief 10â€¯ms interval â€” on the parameter value estimation of both the contraction dynamics and excitation dynamics.\nIn contrast, the improved method corrected for CE shortening during the quick-release experiments. The correction substantially reduced the overestimation of SEE shortening, yielding an accurate estimate of \\(k_{SEE}\\). As a result, all estimated parameter values deviated by no more than 3% from their actual values (TableÂ 1). These results demonstrate that accounting for CE shortening - even over a brief 10â€¯ms interval - substantially improves the accuracy of the parameter value estimation.\nFor interested readers, we discuss below the specific factors contributing to the differences between the actual contraction and excitation dynamics parameter values and those estimated based on the traditional method.\n\n\n\n\n\n\n\n\n\nFigureÂ 6: Representative example of SEE force over time during a quick-release (A), step-ramp (B) and isometric experiment (C). The inset in (A) depicts the SEE force over time around the quick-release. The SEE force over time is depicted for four sets of parameter values: 1) the actual values (i.e., literature-obtained; black solid line), those obtained with the traditional method (TM; orange dashed line), those obtained with the improved method (IM; green dashed-dotted line) and those resulting from the Monte Carlo Simulations (MC; blue dotted line, with shaded 95% confidence interval).\n\n\n\n\n\n\n\n\n\n\n\nTableÂ 1: Percentage differences between estimated and actual MTC parameter values.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTraditional method\nImproved method\nMonte Carlo\n\n\nGM1\nGM2\nGM3\nGM1\nGM2\nGM3\nGM1\nGM2\nGM3\n\n\n\n\n$a$\n1\n4\n2\n1\n3\n1\n1 Â± 2\n6 Â± 2\n1 Â± 2\n\n\n$b$\n-0\n2\n-1\n1\n2\n1\n1 Â± 2\n5 Â± 2\n1 Â± 2\n\n\n$F_{CE}^{max}$\n0\n-1\n0\n-0\n-1\n-0\n-0 Â± 1\n-2 Â± 1\n-0 Â± 1\n\n\n$k_{PEE}$\n3\n-9\n9\n-0\n0\n-0\n3 Â± 17\n3 Â± 16\n6 Â± 31\n\n\n$k_{SEE}$\n-39\n-27\n-37\n0\n-1\n0\n-37 Â± 6\n-36 Â± 6\n-36 Â± 6\n\n\n$L_{CE}^{opt}$\n-1\n-2\n-3\n-0\n0\n-0\n0 Â± 3\n0 Â± 2\n0 Â± 3\n\n\n$L_{PEE}^0$\n0\n-1\n-0\n-0\n0\n-0\n0 Â± 3\n1 Â± 2\n0 Â± 2\n\n\n$L_{SEE}^0$\n-1\n-0\n-0\n0\n-0\n0\n-0 Â± 1\n-0 Â± 1\n-0 Â± 1\n\n\n$\\tau_{act}$\n-21\n-16\n-21\n-0\n-1\n-0\n1 Â± 3\n-0 Â± 4\n1 Â± 4\n\n\n$\\tau_{deact}$\n-5\n-4\n-5\n0\n0\n0\n0 Â± 1\n0 Â± 1\n0 Â± 1\n\n\n\n\n\n\n        \n\n\n\n\n\n\n\nSource: Tables\n\n\n3.1.2 Understanding errors in parameter value estimation\nEstimation of SEE stiffness. The SEE stiffness parameter (\\(k_{SEE}\\)) was underestimated by 39%, 27% and 37% for GM1, GM2 and GM3, respectively (see TableÂ 1). This overestimation directly resulted from the overestimation of SEE shortening due to the quick-release, which was overestimated by 28Â±2%, 17Â±2% and 26Â±2% for GM1, GM2 and GM3, respectively, averaged across all quick-release experiments. In absolute terms, CE shortened only 43Â±3, 29Â±2 and 41Â±2 Âµm over the 11â€¯ms interval between the time points at which SEE force and SEE length were sampled (i.e., immediately before and after the quick-release). The amount of CE shortening was smallest in GM2 because GM2 was a slower muscle than GM1 and GM3. Consequently, the overestimation of SEE shortening was also smallest in GM2, which in turn led to the smallest underestimation of \\(k_{SEE}\\). All in all, this shows that even very small amounts of CE shortening has substantial influence on the estimation of SEE stiffness.\nSince SEE was very stiff, the overestimation in SEE elongation at maximal isometric CE force was only 0.50, 0.32 and 0.49 mm for GM1, GM2 and GM3, respectively. This is an important finding because the SEE stiffness is the first parameter in the estimation process and therefore affects all subsequent estimated parameter values. Therefore, since the overestimation of SEE elongation (in mm) at maximal isometric CE force was only small, the impact on the estimation of the other contraction dynamics parameter values was also small.\nLastly, it should be noted that the correlation coefficient between the data SEE forceâ€‘length relationship and the one based from the estimated parameters is not an adequate measure of how accurately SEE stiffness is captured. Obviously, a correlation coefficient is not sensitive to the overestimation of SEE shortening due to the quick-release. Consequently, high correlation coefficients (\\(R^2 &gt;\\) 0.99) can still be observed even when SEE stiffness is substantially underestimated. To further investigate this issue, we simulated the quick-release experiments after obtaining all contraction and excitation dynamics parameter values. The simulations clearly showed a slower rise in SEE force after the quick-release in comparison with the experimental data (FigureÂ 6A), indicating that SEE stiffness was underestimated. These results suggest that the rise in SEE force is a better measure of SEE stiffness estimation accuracy.\n\n\n\n3.2 Sensitivity analysis\n\n\nCode\n# %% Load packages\nimport os, pickle, sys\nimport pandas as pd\nfrom pathlib import Path\n\n# Set directories\ncwd = Path.cwd()\nbaseDir = cwd.parent\ndataDir = baseDir / 'data'\nfuncDir = baseDir / 'analysis' / 'functions'\nsys.path.append(str(funcDir))\n\n# Custom functions\nimport stats\n\n# %% 3.2.1: Monte Carlo simulations\nmuscles = ['GMs1', 'GMs2', 'GMs3']\n# Parameters to track\nparams = ['a', 'b', 'fmax', 'kpee', 'ksee', 'lce_opt', 'lpee0', 'lsee0', 'tact', 'tdeact']\n\n# Store Monte-Carlo results\nresults = []\nfor mus in muscles:\n    par_file = os.path.join(dataDir, mus, 'parameters', f'{mus}_OR.pkl')\n    or_par = pickle.load(open(par_file, 'rb'))\n    eseeMaxOR = (or_par['fmax']/or_par['ksee'])**0.5\n        \n    \n    for iMC in range(1, 51):\n        mc_file = os.path.join(dataDir, mus, 'parameters','mc', f'{mus}_MC{iMC:02d}.pkl')\n        mc_par = pickle.load(open(mc_file, 'rb'))[0]\n        eseeMaxMC = (mc_par['fmax']/mc_par['ksee'])**0.5\n        \n        entry = {'muscle': mus, 'MC': iMC, 'd_esee': (eseeMaxMC-eseeMaxOR)}\n        for param in params:\n            entry[param] = stats.pdiff(mc_par[param], or_par[param])\n        \n        results.append(entry)\n\n# Convert to pandas DataFrame\ndf = pd.DataFrame(results)\n\n# Compute summary statistics\ndf_mean = df.groupby('muscle').mean().T\ndf_std = df.groupby('muscle').std().T\n\n# Extract all contraction dynamics parameters except ksee\np_MC_con_avg = df_mean.loc[['a','b', 'kpee', 'fmax', 'lce_opt', 'lpee0', 'lsee0']]\np_MC_con_std = df_std.loc[['a', 'b', 'fmax', 'kpee', 'lce_opt', 'lpee0', 'lsee0']]\n\n# Percentage difference over all muscles: from real to estimated ksee\np_MC_ksee_avg = f'{df_mean.loc['ksee'].mean():0.0f}'  # [%] percentage difference\n# Absolute difference over all muscles of SEE elongation @ Fcemax\nd_MC_esee_avg = f'{df_mean.loc['d_esee'].mean()*1e3:0.1f}'  # [mm]\n# Max. avg. percentage difference over all muscles: from real to estimated value of contraction dyn. parms\np_MC_con_maxavg = f'{p_MC_con_avg.abs().max().max():0.1f}' \n# Max. std. percentage difference over all muscles: from real to estimated value of contraction dyn. parms\np_MC_con_maxstd = f'{p_MC_con_std.abs().max().max():0.0f}' \n# Max. std percentage difference over all muscles: from real to estimated value of kpee\np_MC_kpee_maxstd = f'{df_std.loc['kpee'].max():0.0f}'\n# Max. avg percentage difference over all muscles: from real to estimated value of tact\np_MC_tact_maxavg = f'{df_mean.loc['tact'].max():0.1f}'\n# Avg. std percentage difference over all muscles: from real to estimated value of tact\np_MC_tact_avgstd = f'{df_std.loc['tact'].mean():0.0f}'\n\n\n\n3.2.1 Monte Carlo simulations\nMonte Carlo simulations were used to examine how shifts in the MTC forceâ€“length relationship caused by a decrease in SEE stiffness (e.g., due to irreversible SEE damage in experiments) affect the accuracy of the estimated contraction and excitation dynamics parameter values. The induced shifts of the MTC force-length relationship were between 0â€“1 mm, and therefore it was no surprise that SEE stiffness decreased by 36% on average â€” which corresponds to a .5 mm shift.\nAll other estimated contraction dynamics parameter values were within 6.3% on average of their actual value (TableÂ 1). The variance in the estimated contraction dynamics parameter values was below 31% for all parameters except for the PEE stiffness scaling parameter. The PEE stiffness scaling parameter showed substantially higher variance (with a standard deviation up to 31%), because it was based on four or fewer quick-release trials, making it more sensitive to perturbations in the data. Regarding the excitation dynamics, the influence on the average time constants was minimal (within 0.7%), but affected the variance in the estimated values of the activation time constant (with a standard deviation of 4% on average). These findings indicate that an average decrease in SEE stiffness of 36% has a much smaller effect on the estimated parameter values of the contraction and excitation dynamics, even at the level of an individual muscle.\n\n\n3.2.2 Interdependency of parameter values\nWe investigated the interdependency of the estimated parameter values by adjusting each parameter value by 5% and re-estimating all other parameter values. \\(F_{CE}^{max}\\) and \\(L_{SEE}^0\\) were the parameters that had most effect on the estimates of the others.\nFirst, \\(F_{CE}^{max}\\) affected the estimation of parameter \\(a\\) and \\(b\\) of the CE force-velocity relationship. Underestimating \\(F_{CE}^{max}\\) leads to an underestimation of CE force at 0 velocity. Due to the formulation of the CE force-velocity relationship, the curve, by definition, crosses the point at \\(v_{CE}=0\\) and \\(F_{CE}=F_{CE}^{max}\\). Consequently, the best fit to the data with an underestimated \\(F_{CE}^{max}\\) is a much flatter CE force-velocity relationship, which is realised by an increase in \\(a\\) and a decrease in \\(b\\). This flatter CE force-velocity relationship affects the estimation of all other contraction dynamics parameter values because the CE force-velocity relationship is used to estimate the CE shortening due to the quick-release (see SectionÂ 2.3.4). As a result, \\(k_{SEE}\\) and \\(L_{SEE}^0\\) decreased due to underestimating \\(F_{CE}^{max}\\), whereas \\(L_{CE}^{opt}\\) increased. In summary, \\(F_{CE}^{max}\\) substantially influenced the estimation of all contraction dynamics parameter values mainly by its effect on the CE force-velocity relationship.\nSecond, \\(L_{SEE}^0\\) affected the estimation of \\(L_{CE}^{opt}\\) and \\(F_{CE}^{max}\\). As explained earlier, when \\(L_{SEE}^0\\) is overestimated, \\(L_{CE}^{opt}\\) is underestimated, such that \\(L_{MTC}^{opt}\\) remains more or less unaffected. Underestimating \\(L_{CE}^{opt}\\) causes a narrower MTC force-length relationship, leading to an overestimation of \\(F_{CE}^{max}\\) to preserve a good fit between the data and the model. As previously discussed, overestimating \\(F_{CE}^{max}\\), in turn, resulted in an underestimation of parameters \\(a\\) and \\(b\\). Thus, \\(L_{SEE}^0\\) substantially influenced the estimation of all contraction dynamics parameter values mainly by its effect on the MTC force-length relationship.\nTaken together, the interdependence of \\(F_{CE}^{max}\\) and \\(L_{SEE}^0\\) with other parameter values underscores the need for precise estimation of these key parameters. In this regard, it is reassuring that these two parameters were found to be robust for perturbations in the experimental data.\n\n\n\n\n\nTableÂ 2: Interdependency of the estimated MTC parameter values. Each entry shows the percentage change in the row parameter resulting from a 5% change in the column parameter. All values are expressed as percentage changes.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n$a$\n$b$\n$F_{CE}^{max}$\n$k_{SEE}$\n$L_{CE}^{opt}$\n$L_{SEE}^0$\n\n\n\n\n$a$\n-\n10.1 Â± 1.3\n-14.0 Â± 1.0\n-0.6 Â± 0.2\n3.4 Â± 1.0\n-10.3 Â± 2.0\n\n\n$b$\n2.3 Â± 1.2\n-\n-14.3 Â± 3.1\n1.1 Â± 0.3\n3.9 Â± 1.1\n-10.8 Â± 1.6\n\n\n$F_{CE}^{max}$\n-0.6 Â± 0.1\n-0.6 Â± 0.1\n-\n-0.6 Â± 0.2\n-1.2 Â± 0.5\n3.5 Â± 0.5\n\n\n$k_{PEE}$\n-6.8 Â± 2.9\n-6.8 Â± 2.9\n-6.9 Â± 3.5\n-6.8 Â± 3.2\n-6.8 Â± 2.9\n-6.8 Â± 3.3\n\n\n$k_{SEE}$\n52.4 Â± 12.6\n52.4 Â± 12.8\n54.3 Â± 17.0\n-\n52.4 Â± 12.8\n52.5 Â± 14.3\n\n\n$L_{CE}^{opt}$\n1.9 Â± 0.6\n1.9 Â± 0.6\n-5.4 Â± 2.2\n1.9 Â± 0.6\n-\n-14.2 Â± 3.0\n\n\n$L_{PEE}^0$\n-0.6 Â± 0.7\n-0.6 Â± 0.7\n-0.6 Â± 0.7\n-0.6 Â± 0.7\n-0.6 Â± 0.7\n-10.6 Â± 1.2\n\n\n$L_{SEE}^0$\n0.5 Â± 0.2\n0.5 Â± 0.2\n1.8 Â± 0.6\n0.5 Â± 0.2\n-1.7 Â± 0.6\n-\n\n\n$\\tau_{act}$\n23.4 Â± 4.2\n23.4 Â± 4.6\n24.2 Â± 5.9\n23.3 Â± 5.0\n23.7 Â± 4.3\n20.9 Â± 6.3\n\n\n$\\tau_{deact}$\n4.8 Â± 0.7\n4.9 Â± 0.8\n5.0 Â± 3.1\n4.8 Â± 0.9\n4.9 Â± 1.4\n5.1 Â± 3.0\n\n\n\n\n\n\n        \n\n\n\n\n\n\n\n\n\n\n\n3.3 Evaluating model predictions - in situ data\n\n\nCode\n# %% Load packages\nimport os, pickle, sys, glob\nimport numpy as np\nimport pandas as pd\nfrom pathlib import Path\n\n# Directories\ncwd = Path.cwd()\nbaseDir = cwd.parent\ndataDir = baseDir / 'data'\nfuncDir = baseDir / 'analysis' / 'functions'\nsys.path.append(str(funcDir))\n\n# Custom functions\nimport helpers, stats\n\n# %% Extract parameters\nmuscles = ['GMe1', 'GMe2', 'GMe3']\nparam_keys = ['a', 'b', 'kpee', 'ksee', 'fmax', 'lce_opt', 'lpee0', 'lsee0', 'tact', 'tdeact']\n\norParms, tmParms, imParms = [], [], []\nfor mus in muscles:   \n    tmPar, dataQRtm = pickle.load(open(os.path.join(dataDir,mus,'parameters',mus+'_TM.pkl'), 'rb'))[0:2]\n    imPar, dataQRim = pickle.load(open(os.path.join(dataDir,mus,'parameters',mus+'_IM.pkl'), 'rb'))[0:2]\n    \n    parms = [tmPar[k] for k in param_keys]\n    tmParms.append(parms)\n    \n    parms = [imPar[k] for k in param_keys]\n    imParms.append(parms)\n    \n# Store in pandas dataframe\ndf_tm = pd.DataFrame(list(zip(*tmParms)), columns=['GM1', 'GM2', 'GM3'], index=param_keys) # df with estimated parameter values using the traditional method\ndf_im = pd.DataFrame(list(zip(*imParms)), columns=['GM1', 'GM2', 'GM3'], index=param_keys) # df with estimated parameter values using the improved method\n\n# %% Compute percentage differences from real/actual and estimated parameter values\n# Positive: Imporoved is that % higher than Traditional\n# Negative: Imporoved is that % lower than Traditional\ndf_p = stats.pdiff(df_im, df_tm)\n\n# %% Compute RMSDs\npar_models = ['TM', 'IM']\nexperiments = ['QR', 'SR', 'ISOM', 'SSC']\nmuscles = ['GMe1', 'GMe2', 'GMe3']\n\navg_mean_all = []\ncolumns = [f'{model}_{exp}' for model in par_models for exp in experiments]\nrows = muscles + ['Avg Â± Std']\ndf = pd.DataFrame(index=rows, columns=columns, dtype=str)\nfor exp in experiments:\n    for model in par_models:\n        all_rmsd = []\n        for mus in muscles:\n            # Load parameter\n            parFile = os.path.join(dataDir, mus, 'parameters', f'{mus}_{model}.pkl')\n            muspar = pickle.load(open(parFile, 'rb'))[0]\n\n            dataDirExp = os.path.join(dataDir, mus, 'dataExp', exp)\n            rrunDirExp = os.path.join(dataDir, mus, 'simsExp', model, exp)\n\n            dataFiles = sorted(glob.glob(os.path.join(dataDirExp, '*')))\n            rrunFiles = sorted(glob.glob(os.path.join(rrunDirExp, '*')))\n\n            rms_list = []\n            for dataFile, rrunFile in zip(dataFiles, rrunFiles):\n                dataFilename = os.path.basename(dataFile)[:-4]\n                rrunFilename = os.path.basename(rrunFile)[:-4]\n                if dataFilename[:-3] != rrunFilename[:-3]:\n                    raise ValueError(f\"File mismatch: {dataFilename} vs {rrunFilename}\")\n\n                dataData = pd.read_csv(dataFile).T.to_numpy()[0:4]\n                rrunData = pd.read_csv(rrunFile).T.to_numpy()\n\n                time1, _, stim1, fsee1 = dataData\n                time2, _, _, fsee2 = rrunData\n\n                tStimOn, tStimOff = helpers.get_stim(time1, stim1)[1:]\n                iStart = int(np.argmin(abs(time1 - tStimOn[0])))\n\n                if exp == 'ISOM':\n                    iStop = int(np.argmin(abs(time1 - 0.1 - tStimOff[0])))\n                elif exp in ['QR', 'SR']:\n                    iStop = int(np.argmin(abs(time1 - tStimOff[0])))\n                else:  # SSC\n                    iStop = int(np.argmin(abs(time1 - tStimOff[-1])))\n\n                rms = stats.rmse(fsee1[iStart:iStop], fsee2[iStart:iStop]) / muspar['fmax'] * 100\n                rms_list.append(rms)\n\n            M = np.mean(rms_list)\n            S = np.std(rms_list)\n\n            df.loc[mus, f'{model}_{exp}'] = f'{M:.1f} Â± {S:.1f}'\n            all_rmsd += rms_list  # just mean, for averaging across muscles\n\n        # Average over muscles for this (exp, model)\n        avg_M = np.mean(all_rmsd)\n        avg_S = np.std(all_rmsd)\n        df.loc['Avg Â± Std', f'{model}_{exp}'] = f'{avg_M:.1f} Â± {avg_S:.1f}'\n        avg_mean_all.append(avg_M)\navg_mean_all = np.array(avg_mean_all)\n\n#%% 3.3: Evaluating model predictions\n# Avg. difference: from traditional to improved method: SEE stiffness\np_IS_ksee_avg = f'{df_p.loc['ksee'].mean():0.0f}' #  [%] avg. percentage difference\n# Avg. difference: from traditional to improved method: tact\np_IS_tact_avg = f'{df_p.loc['tact'].mean():0.0f}' #  [%] avg. percentage difference\n# Avg. difference: from traditional to improved method: tdeact\np_IS_tdeact_avg = f'{df_p.loc['tdeact'].mean():0.0f}' #  [%] avg. percentage difference\n# Avg. difference: from traditional to improved method: lce_opt\np_IS_lceopt_avg = f'{df_p.loc['lce_opt'].mean():0.0f}' #  [%] avg. percentage difference\n# Take the mean over all each sort of experiment\np_IS_rmsd = f'{stats.pdiff(avg_mean_all[1::2],avg_mean_all[0::2]).mean():2.0f}'\n\n\nWe estimated contraction and excitation dynamics parameter values from in situ data of rat m. gastrocnemius medialis (Table S2). The improved method yielded a 67% higher SEE stiffness compared to the traditional method. As explained earlier, higher SEE stiffness also affects the estimation of all other parameter values. The most noticeable changes were longer time constants for both the activation (\\(\\tau_{act}\\)) and deactivation (\\(\\tau_{deact}\\)) dynamics, with increases of 61% and 16% on average, respectively. Another noticeable change was in CE optimum length, which was about 11% higher using the improved method compared to the traditional method.\nTo assess model predictions, we re-ran quick-release, step-ramp and isometric experiments, as well as stretch-shortening cycles with experimentally measured MTC length and CE stimulation over time as inputs to the model. We compared the model predictions using parameter sets obtained from both methods. For all experiments and rats, the average difference between experimental data and model predictions was -30% smaller on average using parameters from the improved method (FigureÂ 8; Table S3). Overall, the improved method substantially enhanced the predictions derived by the Hill-type MTC model compared to the traditional method.\n\n\n\n\n\n\n\n\n\nFigureÂ 7: Representative example of experimental in situ data of rat 1 for the SEE force-length relationship (A), PEE force-length relationship (B), MTC force-length relationship (C) and the CE force-velocity relationship (D).** The orange dots depicts the experimental in situ data and the solid black line depicts the model fit.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigureÂ 8: Representative example of experimental in situ data and simulation results of rat 1 for SEE force over time during a quick-release experiment (A), step-ramp experiment (B), isometric experiment (C) and two stretch-shortening cycles (D & E). The simulation results were obtained by re-simulating the experimental protocol with the MTC length and CE stimulation from the experimental data as input and by using either the parameter set obtained with the traditional method (TM; orange dashed line) or the improved method (IM; green dash-dotted line). For each panel, the top plot represents MTC length over time, with the bar indicating its range in mm. CE stimulation is maximal during the periods indicated by the black bars and is â€˜offâ€™ elsewhere."
  },
  {
    "objectID": "manuscript/preprint.html#discussion",
    "href": "manuscript/preprint.html#discussion",
    "title": "Accuracy of experimentally estimated muscle properties: Evaluation and improvement using a newly developed toolbox",
    "section": "4 Discussion",
    "text": "4 Discussion\nThe aim of this study was to evaluate the accuracy of estimating contraction and excitation dynamics parameter values on the basis of data collected in commonly used experimental protocols. In real experiments, the actual parameter values are unknown, making it impossible to directly assess estimation accuracy. In this study, we took a different approach: using a Hill-type MTC model with parameter values obtained from literature we generated synthetic â€˜dataâ€™ by simulating quick-release, step-ramp, and isometric experiments. We then estimated all important contraction and excitation dynamics parameter values by using the synthetic data. Since the actual parameter values were known in this case, we could assess how accurately they were retrieved. Two different estimation methods were compared. The first was the traditional method, commonly used in the literature, which does not account for muscle fibre shortening during quick-release experiments. The second was an improved method that includes a correction for muscle fibre shortening during the quick release. Both methods developed in this studyâ€”designed to estimate contraction and excitation dynamics parameters from quick-release, step-ramp, and isometric experiments using servomotorsâ€”are made available as an open-source toolbox. In the remainder of this paper, we will discuss 1) the difference between the two methods; 2) the robustness of the improved method and 3) the implications for muscle modelling.\nIn quick-release experiments using servomotors, muscle fibres shorten, even within the short duration of the release. Obviously, the extent of muscle fibre shortening depends on the duration of the quick-release. Consequently, the longer the quick-release, the more important it becomes to account for muscle fibre shortening when estimating SEE stiffness (see Figure S3). For a typical quick-release duration of 10 ms, we found that muscle fibre shortening was nearly 25% of MTC shortening (and thus 33% of SEE shortening), resulting in an underestimation of SEE stiffness by approximately 35%. This finding is important, especially in studies aiming to estimate SEE energy storage from SEE force or length, since energy storage estimates scale linearly with SEE stiffness. Although SEE was substantially underestimated with the traditional method, this had minimal effect on the estimated parameter values of the PEE and CE force-length relationships and the CE force-velocity relationship, but impacted the estimated excitation dynamics parameter values. The improved method, in turn, yielded SEE stiffness values close to the actual ones and substantially enhanced the estimates of the other parameter values.\nOur sensitivity analysis revealed substantial interdependencies between certain parameters. Particularly, we observed high sensitivity of estimated parameter values to variations in the maximal isometric CE force (\\(F_{CE}^{max}\\)) and the SEE slack length (\\(L_{SEE}^0\\)) parameter values. Despite this sensitivity, it is important to note that these parameters were accurately estimated even from perturbed experimental data. This was true in general: contraction and excitation dynamics parameter values were quite robust against shifts in the MTC force-length relationship of the simulated data according to the Monte Carlo simulations. These findings indicate the robustness of the improved method.\nWe applied both the traditional and the improved method to in situ data from quick-release, step-ramp, and isometric experiments on rat m. gastrocnemius medialis. The improved method yielded substantially higher estimates of SEE stiffness compared to the traditional method (67% on average). Using parameter sets from both methods, we simulated the quick-release, step-ramp, and isometric experiments, as well as independent stretch-shortening cycles, all with experimentally obtained MTC length and CE stimulation over time as input to the model. With parameter estimates obtained with the traditional method, the root mean squared difference between predicted and experimentally measured force was about 5.6% of maximal CE force, averaged across all rats and experiments; with parameter estimates obtained with the improved method this was only 3.9%. The small difference between predicted and experimentally observed force over time with parameters from the improved method suggests that muscle force can be accurately predicted with a Hill-type MTC model across a wide variety of contractions. This is a remarkable finding for two reasons. First, the Hill-type MTC model is obviously a simplification of real muscle, abstracting the muscle belly, aponeurosis, and tendon into the CE, SEE, and PEE components, and thus does not account for certain complexities (e.g., non-constant pennation angle, muscle inhomogeneities, etc.). Second, the Hill-type MTC model used in this study consists of 26 parameters, of which only 10 values were estimated. This means that all other parameters were left suboptimal. Despite these simplifications, the model was able to accurately predict muscle behaviour, demonstrating that a relatively simple model with a limited number of estimated parameter values can still capture important aspects of muscle dynamics.\nIn conclusion, our results demonstrate that the improved parameter estimation method provides accurate and robust estimates of contraction and excitation dynamics properties, offering a reliable approach for muscle property estimation in both biomechanical and muscle physiology research. The approach that we designed in this study is made available as an open-source toolbox (https://github.com/edwinreuvers/mp-estimator)."
  },
  {
    "objectID": "manuscript/preprint.html#acknowledgments",
    "href": "manuscript/preprint.html#acknowledgments",
    "title": "Accuracy of experimentally estimated muscle properties: Evaluation and improvement using a newly developed toolbox",
    "section": "Acknowledgments",
    "text": "Acknowledgments\nThe authors thank Maarten F. Bobbert for helpful comments on a draft of the paper. The authors also thank Koen K. Lemaire for insightful discussions."
  },
  {
    "objectID": "manuscript/preprint.html#funding",
    "href": "manuscript/preprint.html#funding",
    "title": "Accuracy of experimentally estimated muscle properties: Evaluation and improvement using a newly developed toolbox",
    "section": "Funding",
    "text": "Funding\nThis work was funded by The Dutch Research Council (NWO)Â [21728 to D.A.K.]."
  },
  {
    "objectID": "manuscript/preprint.html#data-and-resource-availability",
    "href": "manuscript/preprint.html#data-and-resource-availability",
    "title": "Accuracy of experimentally estimated muscle properties: Evaluation and improvement using a newly developed toolbox",
    "section": "Data and resource availability",
    "text": "Data and resource availability\nAll data, code, and materials used in this study are openly available:\n\nGitHub repository: All raw data, processed data, and analysis code are hosted on GitHub at https://github.com/edwinreuvers/acc-mp-estimation.\nReproducible analysis website: Full analysis pipeline â€” including data, analysis code, and figure/table generation â€” is available at https://edwinreuvers.github.io/publications/acc-mp-estimation."
  },
  {
    "objectID": "manuscript/preprint.html#glossary",
    "href": "manuscript/preprint.html#glossary",
    "title": "Accuracy of experimentally estimated muscle properties: Evaluation and improvement using a newly developed toolbox",
    "section": "Glossary",
    "text": "Glossary\n\n\n\n\n\n\n\nSymbol\nDescription\n\n\n\n\n\\(a\\)\nHill constant\n\n\n\\(b\\)\nHill constant\n\n\n\\(b_{min}^{scale}\\)\nMinimal scale factor of \\(b\\) (i.e., the minimal value of \\(b_{scale}\\))\n\n\n\\(b_{shape}\\)\nDetermines the steepness of the relation between \\(b_{scale}\\) and \\(q\\)\n\n\n\\(F_{asymp}\\)\nOblique asymptote of the eccentric part of the CE force-velocity relationship\n\n\n\\(F_{CE}^{max}\\)\nMaximum isometric CE force\n\n\n\\(k_{PEE}\\)\nScales the PEE stiffness\n\n\n\\(k_{SEE}\\)\nScales the SEE stiffness\n\n\n\\(L_{CE}^{opt}\\)\nCE length at which CE can produce maximal isometric force\n\n\n\\(L_{PEE}^0\\)\nPEE slack length\n\n\n\\(L_{SEE}^0\\)\nSEE slack length\n\n\n\\(r_{as}\\)\nSlope of the slanted asymptote of the eccentric part of the CE force-velocity relationship\n\n\n\\(r_{slope}\\)\nRatio between the eccentric and concentric derivatives of \\(\\frac{dF_{CE}^{rel}}{dv_{CE}^{rel}}\\) @ \\(v_{CE}=0\\)\n\n\n\\(w\\)\nDetermines the width of the CE force-length relationship\n\n\n\\(a_{act}\\)\nDetermines the steepness of the relation between \\(\\gamma\\) and \\(q\\)\n\n\n\\(b_{act,1}\\)\nDetermines together with \\(b_{act,1}\\) and \\(b_{act,3}\\) the \\(pCa^{2+}\\) level at which \\(q=0.5\\)\n\n\n\\(b_{act,2}\\)\nDetermines together with \\(b_{act,2}\\) and \\(b_{act,3}\\) the \\(pCa^{2+}\\) level at which \\(q=0.5\\)\n\n\n\\(b_{act,3}\\)\nDetermines together with \\(b_{act,1}\\) and \\(b_{act,2}\\) the \\(pCa^{2+}\\) level at which \\(q=0.5\\)\n\n\n\\(k_{Ca}\\)\nRelates \\(\\gamma\\) to the actual \\(Ca^{2+}\\) concentration\n\n\n\\(\\gamma_0\\)\nMinimal value of \\(\\gamma\\)\n\n\n\\(q_0\\)\nMinimal value \\(q\\)\n\n\n\\(\\tau_{act}\\)\nActivation time constant of the calcium dynamics\n\n\n\\(\\tau_{deact}\\)\nDeactivation time constant of the calcium dynamics"
  },
  {
    "objectID": "manuscript/preprint.html#references",
    "href": "manuscript/preprint.html#references",
    "title": "Accuracy of experimentally estimated muscle properties: Evaluation and improvement using a newly developed toolbox",
    "section": "References",
    "text": "References\n\n\nAubert, X., M. L. Roquet, and J. Van der Elst. 1951. â€œThe Tension-Length Diagram of the Frogâ€™s Sartorius Muscle.â€ Archives Internationales de Physiologie 59 (2): 239â€“41. https://doi.org/10.3109/13813455109145002.\n\n\nBlix, Magnus. 1892. â€œDie LÃ¤nge Und Die Spannung Des Muskels.â€ Skandinavisches Archiv FÃ¼r Physiologie 3 (1): 295â€“318. https://doi.org/10.1111/j.1748-1716.1892.tb00660.x.\n\n\nâ€”â€”â€”. 1893. â€œDie LÃ¤nge Und Die Spannung Des Muskels.â€ Skandinavisches Archiv FÃ¼r Physiologie 4 (1): 399â€“409. https://doi.org/10.1111/j.1748-1716.1893.tb00749.x.\n\n\nBlÃ¼mel, Marcus, Scott L. Hooper, Christoph Guschlbauerc, William E. White, and Ansgar BÃ¼schges. 2012. â€œDetermining All Parameters Necessary to Build Hill-Type Muscle Models from Experiments on Single Muscles.â€ Biological Cybernetics 106 (10): 543â€“58. https://doi.org/10.1007/s00422-012-0531-5.\n\n\nBobbert, Maarten F., Gertjan C. Ettema, and Peter A. Huijing. 1990. â€œThe Force-Length Relationship of a Muscle-Tendon Complex: Experimental Results and Model Calculations.â€ European Journal of Applied Physiology and Occupational Physiology 61 (3): 323â€“29. https://doi.org/10.1007/BF00357621.\n\n\nBortolotto, Susan K., Maria Cellini, D. George Stephenson, and Gabriela M. M. Stephenson. 2000. â€œMHC Isoform Composition and Ca2+- or Sr2+-Activation Properties of Rat Skeletal Muscle Fibers.â€ American Journal of Physiology-Cell Physiology 279 (5): C1564â€“77. https://doi.org/10.1152/ajpcell.2000.279.5.C1564.\n\n\nBurkholder, Thomas J., and Richard L. Lieber. 2001. â€œSarcomere Length Operating Range of Vertebrate Muscles During Movement.â€ Journal of Experimental Biology 204 (9): 1529â€“36. https://doi.org/10.1242/jeb.204.9.1529.\n\n\nCecchi, G, F Colomo, and V Lombardi. 1978. â€œForce-Velocity Relation in Normal and Nitrate-Treated Frog Single Muscle Fibres During Rise of Tension in an Isometric Tetanus.â€ The Journal of Physiology 285 (1): 257â€“73. https://doi.org/10.1113/jphysiol.1978.sp012570.\n\n\nEbashi, S., and M. Endo. 1968. â€œCalcium and Muscle Contraction.â€ Progress in Biophysics and Molecular Biology 18 (January): 123â€“83. https://doi.org/10.1016/0079-6107(68)90023-0.\n\n\nGordon, A. M., A. F. Huxley, and F. J. Julian. 1966. â€œThe Variation in Isometric Tension with Sarcomere Length in Vertebrate Muscle Fibres.â€ The Journal of Physiology 184 (1): 170â€“92. https://doi.org/10.1113/jphysiol.1966.sp007909.\n\n\nHatze, Herbert. 1981. Myocybernetic Control Models of Skeletal Muscle. Pretoria: University of South Africa.\n\n\nHill, A. V. 1925. â€œLength of Muscle, and the Heat and Tension Developed in an Isometric Contraction.â€ The Journal of Physiology 60 (4): 237â€“63. https://doi.org/10.1113/jphysiol.1925.sp002242.\n\n\nHill, Archibald Vivian. 1938. â€œThe Heat of Shortening and the Dynamic Constants of Muscle.â€ Proceedings of the Royal Society of London. B. Biological Sciences 126 (843): 136â€“95. https://doi.org/10.1098/rspb.1938.0050.\n\n\nâ€”â€”â€”. 1950. â€œThe Series Elastic Componet of Muscle.â€ Proceedings of the Royal Society of London. B. Biological Sciences 137 (887): 273â€“80. https://doi.org/10.1098/rspb.1950.0035.\n\n\nKatz, Bernhard. 1939. â€œThe Relation Between Force and Speed in Muscular Contraction.â€ The Journal of Physiology 96 (1): 45â€“64. https://doi.org/10.1113/jphysiol.1939.sp003756.\n\n\nKistemaker, Dinant A., Robert M. Terwiel, Edwin D. H. M. Reuvers, and Maarten F. Bobbert. 2023. â€œLimiting Radial Pedal Forces Greatly Reduces Maximal Power Output and Efficiency in Sprint Cycling; an Optimal Control Study.â€ Journal of Applied Physiology 134 (4): 980â€“91. https://doi.org/10.1152/japplphysiol.00733.2021.\n\n\nKistemaker, Dinant A., Arthur (Knoek) J. Van Soest, and Maarten F. Bobbert. 2005. â€œLength-Dependent [Ca2+] Sensitivity Adds Stiffness to Muscle.â€ Journal of Biomechanics 38 (9): 1816â€“21. https://doi.org/10.1016/j.jbiomech.2004.08.025.\n\n\nLemaire, Koen K., Guus C. Baan, Richard T. Jaspers, and A. J. â€˜Knoekâ€™van Soest. 2016. â€œComparison of the Validity of Hill and Huxley Muscleâ€“Tendon Complex Models Using Experimental Data Obtained from Rat m. SoleusÂ in Situ.â€ Journal of Experimental Biology 219 (14): 2228â€“28. https://doi.org/10.1242/jeb.144394.\n\n\nLevin, A., and J. Wyman. 1927. â€œThe Viscous Elastic Properties of Muscle.â€ Proceedings of the Royal Society of London. Series B, Containing Papers of a Biological Character 101 (709): 218â€“43. https://doi.org/10.1098/rspb.1927.0014.\n\n\nPetrofsky, Jerrold Scott, and Chandler Allen Phillips. 1981. â€œThe Influence of Temperature, Initial Length and Electrical Activity on the Force-Velocity Relationship of the Medial Gastrocnemius Muscle of the Cat.â€ Journal of Biomechanics 14 (5): 297â€“306. https://doi.org/10.1016/0021-9290(81)90039-7.\n\n\nRack, P. M. H., and D. R. Westbury. 1969. â€œThe Effects of Length and Stimulus Rate on Tension in the Isometric Cat Soleus Muscle.â€ The Journal of Physiology 204 (2): 443â€“60. https://doi.org/10.1113/jphysiol.1969.sp008923.\n\n\nReuvers, Edwin D. H. M, Huub Maas, Wendy Noort, Maarten F. Bobbert, and Dinant A. Kistemaker. 2025. â€œMaximising Average Mechanical Power Output During Stretch-Shortening Cycles of Rat Medial Gastrocnemius Muscle.â€ biorXiv. https://doi.org/10.1101/2025.09.25.678481.\n\n\nRijkelijkhuizen, J. M., C. J. de Ruiter, P. A. Huijing, and A. de Haan. 2003. â€œForce/Velocity Curves of Fast Oxidative and Fast Glycolytic Parts of Rat Medial Gastrocnemius Muscle Vary for Concentric but Not Eccentric Activity.â€ PflÃ¼gers Archiv 446 (4): 497â€“503. https://doi.org/10.1007/s00424-003-1052-9.\n\n\nSoest, Arthur J. van, and Maarten F. Bobbert. 1993. â€œThe Contribution of Muscle Properties in the Control of Explosive Movements.â€ Biological Cybernetics 69 (3): 195â€“204. https://doi.org/10.1007/BF00198959.\n\n\nStephenson, D. G., and D. A. Williams. 1982. â€œEffects of Sarcomere Length on the Forceâ€”pCa Relation in Fast- and Slow-Twitch Skinned Muscle Fibres from the Rat.â€ The Journal of Physiology 333 (1): 637â€“53. https://doi.org/10.1113/jphysiol.1982.sp014473.\n\n\nStern, Jack T. 1974. â€œComputer Modelling of Gross Muscle Dynamics.â€ Journal of Biomechanics 7 (5): 411â€“28. https://doi.org/10.1016/0021-9290(74)90004-9.\n\n\nVan Soest, A. J., Margit GfÃ¶hler, and L. J. Richard Casius. 2005. â€œConsequences of Ankle Joint Fixation on FES Cycling Power Output: A Simulation Study.â€ Medicine & Science in Sports & Exercise 37 (5). https://journals.lww.com/acsm-msse/fulltext/2005/05000/consequences_of_ankle_joint_fixation_on_fes.14.aspx.\n\n\nWalker, Sheppard M., and G. Randolph Schrodt. 1974. â€œI Segment Lengths and Thin Filament Periods in Skeletal Muscle Fibers of the Rhesus Monkey and the Human.â€ The Anatomical Record 178 (1): 63â€“81. https://doi.org/10.1002/ar.1091780107.\n\n\nWoittiez, R. D., P. A. Huijing, H. B. K. Boom, and R. H. Rozendal. 1984. â€œA Three-Dimensional Muscle Model: A Quantified Relation Between Form and Function of Skeletal Muscles.â€ Journal of Morphology 182 (1): 95â€“113. https://doi.org/10.1002/jmor.1051820107.\n\n\nZajac, F. E. 1989. â€œMuscle and Tendon: Properties, Models, Scaling, and Application to Biomechanics and Motor Control.â€ Critical Reviews in Biomedical Engineering 17 (4): 359â€“411.\n\n\nZandwijk, Jan Peter van, Guus C. Baan, Maarten F. Bobbert, and Peter A. Huijing. 1997. â€œEvaluation of a Self-Consistent Method for Calculating Muscle Parameters from a Set of Isokinetic Releases.â€ Biological Cybernetics 77 (4): 277â€“81. https://doi.org/10.1007/s004220050388."
  },
  {
    "objectID": "manuscript/preprint.html#supplementary-material",
    "href": "manuscript/preprint.html#supplementary-material",
    "title": "Accuracy of experimentally estimated muscle properties: Evaluation and improvement using a newly developed toolbox",
    "section": "Supplementary material",
    "text": "Supplementary material\n\n4.1 Supplemental figures\n\n\n\n\n\n\n\n\n\nFigure S1: Comparison between a length-controlled step-ramp experiment and a force-controlled quick-release experiment. In length-controlled step-ramp experiment (left), MTC length over time is imposed using a servomotor, while SEE force is measured. MTC velocity is computed at the time instance at which SEE force is near constant. In the force-controlled quick-release experiment (right), SEE force over time is imposed via a lever, while MTC length is measured. MTC velocity is computed at the time instance where MTC velocity is maximal after the change in SEE force. Both methods yield one datapoint (depicted with the orange dot) of the force-velocity relationship.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure S2: Flowchart of the improved method. Using the improved method, parameter values were estimated until the change in all parameter values was less than 0.1%.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure S3: Relationship between quick-release duration and SEE stiffness understimation. When the duration of the quick-release increases, the underestimation of SEE stiffness increases.\n\n\n\n\n\n\n\n\n\n4.2 Supplemental tables\n\n\n\n\n\nTable S1\n\n\n\n\n\n\n\n\n\n\n\n\nMTC parameter values obtained from literature to simulate data.\n\n\n\nUnit\nGM1\nGM2\nGM3\nReference\n\n\n\n\nContraction dynamics\n\n\n$a$\nN\n2.68\n1.80\n2.58\nvan Zandwijk et al. (1997)\n\n\n$b$\nmm\n41.6\n24.8\n41.8\nvan Zandwijk et al. (1997)\n\n\n$b_{scale}^{min}$\n-\n0.100\n0.100\n0.100\nvan Soest and Bobbert (1993)\n\n\n$b_{shape}$\n-\n22.0\n22.0\n22.0\nvan Soest and Bobbert (1993)\n\n\n$F_{asymp}$\n-\n1.50\n1.50\n1.50\nRijkelhuizen et al. (2003)\n\n\n$F_{CE}^{max}$\nN\n13.4\n13.8\n12.3\nvan Zandwijk et al. (1997)\n\n\n$k_{PEE}$\nN/mm2\n213\n165\n511\nvan Zandwijk et al. (1997)\n\n\n$k_{SEE}$\nN/mm2\n4,220\n3,640\n3,470\nvan Zandwijk et al. (1997)\n\n\n$L_{CE}^{opt}$\nmm\n13.2\n12.3\n11.2\nvan Zandwijk et al. (1997)\n\n\n$L_{PEE}^0$\nmm\n13.9\n13.2\n13.4\nvan Zandwijk et al. (1997)\n\n\n$L_{SEE}^0$\nmm\n28.3\n30.3\n26.5\nvan Zandwijk et al. (1997)\n\n\n$r_{as}$\n-\n0.00371\n0.00545\n0.00316\nArbitrary small value\n\n\n$r_{slope}$\nmm\n2.00\n2.00\n2.00\nKatz (1939) (1939)\n\n\n$w$\n-\n0.500\n0.500\n0.500\nBurkholder and Lieber (2001)\n\n\nExcitation dynamics\n\n\n$a_{act}$\n?\nâˆ’7.37\nâˆ’7.37\nâˆ’7.37\nBortolotto et al. (2000)\n\n\n$b_{act,1}$\n?\n5.17\n5.17\n5.17\nBortolotto et al. (2000)\n\n\n$b_{act,2}$\n?\n0.596\n0.596\n0.596\nStephenson and Williams (1982)\n\n\n$b_{act,3}$\n?\n0.00\n0.00\n0.00\nStephenson and Williams (1982)\n\n\n$kCa$\nmol/L\n8.00 Ã— 10âˆ’6\n8.00 Ã— 10âˆ’6\n8.00 Ã— 10âˆ’6\nKistemaker et al. (2005)\n\n\n$\\gamma_0$\n-\n1.00 Ã— 10âˆ’5\n1.00 Ã— 10âˆ’5\n1.00 Ã— 10âˆ’5\nArbitrary small value\n\n\n$q_0$\n-\n5.00 Ã— 10âˆ’3\n5.00 Ã— 10âˆ’3\n5.00 Ã— 10âˆ’3\nHatze (1981)\n\n\n$\\tau_{act}$\nms\n27.0\n27.0\n27.0\nvan Zandwijk et al. (1997)\n\n\n$\\tau_{deact}$\nms\n27.0\n27.0\n27.0\nvan Zandwijk et al. (1997)\n\n\n\n\n\n\n        \n\n\n\n\n\n\n\n\n\n\n\n\nTable S2\n\n\n\n\n\n\n\n\n\n\n\n\nEstimated parameter values of the experimentally measured in situ data using both the traditional as well as the improved method.\n\n\n\n\n\n\n\n\n\n\n\n\n\nUnit\nTraditional method\nImproved method\n\n\nRat 1\nRat 2\nRat 3\nRat 1\nRat 2\nRat 3\n\n\n\n\n$a$\nN\n8.90\n11.3\n10.5\n8.82\n10.0\n11.0\n\n\n$b$\nmm\n76.7\n108\n84.6\n81.9\n105\n90.6\n\n\n$F_{CE}^{max}$\nN\n15.6\n14.1\n17.1\n15.5\n14.1\n17.0\n\n\n$k_{PEE}$\nN/mm2\n9.83\n7.25\n21.9\n28.7\n24.1\n34.8\n\n\n$k_{SEE}$\nN/mm2\n608\n688\n654\n952\n1260\n1050\n\n\n$L_{CE}^{opt}$\nmm\n12.4\n12.9\n12.3\n13.7\n14.7\n13.3\n\n\n$L_{PEE}^0$\nmm\n12.4\n12.4\n13.3\n15.1\n15.6\n14.5\n\n\n$L_{SEE}^0$\nmm\n29.0\n29.7\n25.1\n28.8\n29.3\n25.2\n\n\n$\\tau_{act}$\nms\n43.0\n32.4\n23.6\n55.2\n57.7\n41.6\n\n\n$\\tau_{deact}$\nms\n23.8\n20.9\n19.7\n27.1\n25.3\n22.4\n\n\n\n\n\n\n        \n\n\n\n\n\n\n\n\n\n\n\n\nTable S3\n\n\n\n\n\n\n\n\n\n\n\n\nRoot mean squared differences between experimentally measured SEE force histories and those predicted by Hill-type MTC model after estimating all contraction and excitation dynamics parameter values.\n\n\n\nTraditional method\nImproved method\n\n\nQR\nSR\nISOM\nSSC\nQR\nSR\nISOM\nSSC\n\n\n\n\nRat 1\n5.6 Â± 3.4\n5.6 Â± 0.8\n6.8 Â± 3.2\n6.2 Â± 3.0\n3.3 Â± 1.5\n2.8 Â± 0.9\n5.4 Â± 3.0\n5.4 Â± 3.1\n\n\nRat 2\n4.2 Â± 1.5\n5.0 Â± 0.6\n4.3 Â± 1.6\n4.6 Â± 2.2\n2.7 Â± 1.6\n2.1 Â± 0.5\n4.2 Â± 2.6\n4.2 Â± 2.0\n\n\nRat 3\n6.4 Â± 2.3\n6.8 Â± 1.0\n6.1 Â± 2.1\n5.5 Â± 2.7\n4.2 Â± 1.8\n2.6 Â± 0.5\n4.9 Â± 2.3\n5.0 Â± 2.7\n\n\nAvg Â± Std\n5.4 Â± 2.6\n5.8 Â± 1.1\n5.7 Â± 2.7\n5.4 Â± 2.7\n3.4 Â± 1.8\n2.5 Â± 0.7\n4.8 Â± 2.7\n4.9 Â± 2.7"
  },
  {
    "objectID": "analysis/readme.html",
    "href": "analysis/readme.html",
    "title": "Analysis",
    "section": "",
    "text": "On these pages, you can find the complete analysis accompanying our manuscript. The analysis is divided into three parts, corresponding to the three main sections in the Results of our manuscript.",
    "crumbs": [
      "{{< iconify fa6-solid magnifying-glass-chart >}} Analysis",
      "Analysis"
    ]
  },
  {
    "objectID": "analysis/readme.html#parameter-accuracy",
    "href": "analysis/readme.html#parameter-accuracy",
    "title": "Analysis",
    "section": "1. Parameter accuracy",
    "text": "1. Parameter accuracy\nSection: â€˜Evaluating parameter value estimation accuracy â€“ simulated dataâ€™\nThis page contains the analyses used to assess how accurately muscleâ€“tendon complex parameters can be retrieved from simulated experiments that mimic quick-release, step-ramp, and isometric experiments performed on real muscle.\nUsing a Hill-type muscleâ€“tendon complex model with known parameter values, we evaluated how well both the traditional estimation method (which does not account for muscle fibre shortening during quick-releases) and the improved estimation method (which accounts for muscle fibre shortening during quick-releases) recover the underlying muscle property values.",
    "crumbs": [
      "{{< iconify fa6-solid magnifying-glass-chart >}} Analysis",
      "Analysis"
    ]
  },
  {
    "objectID": "analysis/readme.html#sensitivity-analysis",
    "href": "analysis/readme.html#sensitivity-analysis",
    "title": "Analysis",
    "section": "2. Sensitivity analysis",
    "text": "2. Sensitivity analysis\nSection: â€˜Sensitivity analysisâ€™\nThis page contains the Monte Carlo simulation to examine the robustness of the estimated muscle properties and the analysis used to examine the interdependency of the estimated muscle properties. .\nUsing Monte Carlo simulations with systematic perturbations of the experimental data, we quantified how variations in the data influence the estimated parameters. In the second analysis, we systematically varied individual muscle property values to assess the sensitivity of the estimation procedure and to quantify dependencies among the estimated muscle properties.",
    "crumbs": [
      "{{< iconify fa6-solid magnifying-glass-chart >}} Analysis",
      "Analysis"
    ]
  },
  {
    "objectID": "analysis/readme.html#model-predictions",
    "href": "analysis/readme.html#model-predictions",
    "title": "Analysis",
    "section": "3. Model predictions",
    "text": "3. Model predictions\nSection: â€˜Evaluating model predictions â€“ in situ dataâ€™\nThis page contains the analyses used to estimate muscle properties from in situ data of rat m. gastrocnemius medialis.\nUsing the estimated parameters, we predicted series elastic element (SEE) force. Model predictions were evaluated against quick-release, step-ramp, and isometric experiments, as well as independently measured stretchâ€“shortening cycles.",
    "crumbs": [
      "{{< iconify fa6-solid magnifying-glass-chart >}} Analysis",
      "Analysis"
    ]
  }
]